"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/html.ts
var html_exports = {};
__export(html_exports, {
  $global: () => $global,
  attr: () => attr,
  attrTag: () => attrTag,
  attrTags: () => attrTags,
  attrs: () => attrs,
  classAttr: () => classAttr,
  commentSeparator: () => commentSeparator,
  compat: () => compat,
  controllable_detailsOrDialog_open: () => controllable_detailsOrDialog_open,
  controllable_input_checked: () => controllable_input_checked,
  controllable_input_checkedValue: () => controllable_input_checkedValue,
  controllable_input_value: () => controllable_input_value,
  controllable_select_value: () => controllable_select_value,
  controllable_textarea_value: () => controllable_textarea_value,
  createContent: () => createContent,
  createTemplate: () => createTemplate,
  dynamicTag: () => dynamicTag,
  ensureScopeWithId: () => ensureScopeWithId,
  escapeScript: () => escapeScript,
  escapeStyle: () => escapeStyle,
  escapeXML: () => escapeXML,
  forIn: () => forIn,
  forInBy: () => forInBy,
  forOf: () => forOf,
  forOfBy: () => forOfBy,
  forTo: () => forTo,
  forToBy: () => forToBy,
  fork: () => fork,
  getScopeById: () => getScopeById,
  hoist: () => hoist,
  markResumeNode: () => markResumeNode,
  nextScopeId: () => nextScopeId,
  nextTagId: () => nextTagId,
  nodeRef: () => nodeRef,
  optionValueAttr: () => optionValueAttr,
  partialAttrs: () => partialAttrs,
  peekNextScopeId: () => peekNextScopeId,
  register: () => register2,
  registerContent: () => registerContent,
  resumeClosestBranch: () => resumeClosestBranch,
  resumeConditional: () => resumeConditional,
  resumeForIn: () => resumeForIn,
  resumeForOf: () => resumeForOf,
  resumeForTo: () => resumeForTo,
  serializeGuard: () => serializeGuard,
  serializeIf: () => serializeIf,
  setTagVar: () => setTagVar,
  styleAttr: () => styleAttr,
  toString: () => toString,
  tryContent: () => tryContent,
  write: () => write,
  writeAttrsAndContent: () => writeAttrsAndContent,
  writeContent: () => writeContent,
  writeEffect: () => writeEffect,
  writeExistingScope: () => writeExistingScope,
  writePartialAttrsAndContent: () => writePartialAttrsAndContent,
  writeScope: () => writeScope,
  writeSubscribe: () => writeSubscribe,
  writeTrailers: () => writeTrailers
});
module.exports = __toCommonJS(html_exports);

// src/common/attr-tag.ts
var empty = [];
var rest = true ? Symbol("Attribute Tag") : Symbol();
function attrTag(attrs2) {
  attrs2[Symbol.iterator] = attrTagIterator;
  attrs2[rest] = empty;
  return attrs2;
}
function attrTags(first, attrs2) {
  if (first) {
    if (first[rest] === empty) {
      first[rest] = [attrs2];
    } else {
      first[rest].push(attrs2);
    }
    return first;
  }
  return attrTag(attrs2);
}
function* attrTagIterator() {
  yield this;
  yield* this[rest];
}

// src/common/helpers.ts
function classValue(classValue2) {
  return toDelimitedString(classValue2, " ", stringifyClassObject);
}
function stringifyClassObject(name, value) {
  return value ? name : "";
}
function styleValue(styleValue2) {
  return toDelimitedString(styleValue2, ";", stringifyStyleObject);
}
function stringifyStyleObject(name, value) {
  return value || value === 0 ? name + ":" + value : "";
}
function toDelimitedString(val, delimiter, stringify) {
  let str = "";
  let sep = "";
  let part;
  if (val) {
    if (typeof val !== "object") {
      str += val;
    } else if (Array.isArray(val)) {
      for (const v of val) {
        part = toDelimitedString(v, delimiter, stringify);
        if (part) {
          str += sep + part;
          sep = delimiter;
        }
      }
    } else {
      for (const name in val) {
        part = stringify(name, val[name]);
        if (part) {
          str += sep + part;
          sep = delimiter;
        }
      }
    }
  }
  return str;
}
function isEventHandler(name) {
  return /^on[A-Z-]/.test(name);
}
function getEventHandlerName(name) {
  return name[2] === "-" ? name.slice(3) : name.slice(2).toLowerCase();
}
function isVoid(value) {
  return value == null || value === false;
}
function normalizeDynamicRenderer(value) {
  return value ? value.content || value.default || value : void 0;
}

// src/html/content.ts
function toString(val) {
  return val ? val + "" : val === 0 ? "0" : "";
}
var unsafeXMLReg = /[<&]/g;
var replaceUnsafeXML = (c) => c === "&" ? "&amp;" : "&lt;";
var escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;
function escapeXML(val) {
  return val ? escapeXMLStr(val + "") : val === 0 ? "0" : "&zwj;";
}
function escapeTextAreaValue(val) {
  return val ? escapeXMLStr(val + "") : val === 0 ? "0" : "";
}
var unsafeScriptReg = /<\/script/g;
var escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, "\\x3C/script") : str;
function escapeScript(val) {
  return val ? escapeScriptStr(val + "") : val === 0 ? "0" : "";
}
var unsafeStyleReg = /<\/style/g;
var escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, "\\3C/style") : str;
function escapeStyle(val) {
  return val ? escapeStyleStr(val + "") : val === 0 ? "0" : "";
}

// src/common/for.ts
function forIn(obj, cb) {
  for (const key in obj) {
    cb(key, obj[key]);
  }
}
function forOf(list, cb) {
  if (list) {
    let i = 0;
    for (const item of list) {
      cb(item, i++);
    }
  }
}
function forTo(to, from, step, cb) {
  const start = from || 0;
  const delta = step || 1;
  for (let steps = (to - start) / delta, i = 0; i <= steps; i++) {
    cb(start + i * delta);
  }
}

// src/html/for.ts
function forOfBy(by, item, index) {
  if (by) {
    if (typeof by === "string") {
      return item[by];
    }
    return by(item, index);
  }
  return index;
}
function forInBy(by, name, value) {
  if (by) {
    return by(name, value);
  }
  return name;
}
function forToBy(by, index) {
  if (by) {
    return by(index);
  }
  return index;
}

// src/html/inlined-runtimes.ts
var WALKER_RUNTIME_CODE = true ? (
  /* js */
  `((runtimeId) => (
(self[runtimeId] = (
  renderId,
  prefix = runtimeId + renderId,
  prefixLen = prefix.length,
  lookup = {},
  visits = [],
  doc = document,
  walker = doc.createTreeWalker(
    doc,
    129 /* NodeFilter.SHOW_COMMENT | NodeFilter.SHOW_ELEMENT */,
  ),
) =>
  doc = (self[runtimeId][renderId] = {
    i: prefix,
    d: doc,
    l: lookup,
    v: visits,
    x() {},
    w(node, op, id) {
      while ((node = walker.nextNode())) {
        doc.x(
          (op =
            (op = node.data) &&
            !op.indexOf(prefix) &&
            ((lookup[(id = op.slice(prefixLen + 1))] = node), op[prefixLen])),
          id,
          node,
        );

        if (op > "#") {
          visits.push(node);
        }
      }
    },
  })),
self[runtimeId]
))`
) : `(e=>(self[e]=(l,d=e+l,f=d.length,o={},n=[],s=document,t=s.createTreeWalker(s,129))=>s=self[e][l]={i:d,d:s,l:o,v:n,x(){},w(e,l,x){for(;e=t.nextNode();)s.x(l=(l=e.data)&&!l.indexOf(d)&&(o[x=l.slice(f+1)]=e,l[f]),x,e),l>"#"&&n.push(e)}},self[e]))`;
var REORDER_RUNTIME_CODE = true ? (
  /* js */
  `((runtime) => {
let onNextSibling,
  placeholder,
  nextSibling,
  placeholders = {},
  replace = (marker, container) => {
    marker.replaceWith(...container.childNodes);
    container.remove();
  };
runtime.d.head.append(
  runtime.d.querySelector("style[" + runtime.i + "]") || "",
);
runtime.j = {};
runtime.x = (op, id, node, start, placeholderCallback) => {
  if (op == "#") {
    (placeholders[id] = placeholder).i++;
  } else if (node == nextSibling) {
    onNextSibling();
  }

  if (node.tagName == "T" && (id = node.getAttribute(runtime.i))) {
    start = runtime.l["^" + id];

    if (start) {
      placeholders[id] = {
        i: 1,
        c(end = runtime.l[id] || node) {
          for (
            ;
            (nextSibling = end.previousSibling || start).remove(),
            start != nextSibling;
          );
          replace(end, node);
        },
      };
    }

    nextSibling = node.nextSibling;
    placeholder = placeholders[id];
    onNextSibling = () => {
      start || replace(runtime.l[id], node);
      if (!--placeholder.i) {
        placeholder.c();
      }
    };

    // repurpose "op" for callbacks ...carefully
    if (op = runtime.j[id]) {
      placeholderCallback = placeholder.c;
      placeholder.c = () => placeholderCallback() + op(runtime.r);
    }
  }
};
})`
) : `(e=>{let i,l,t,r={},c=(e,i)=>{e.replaceWith(...i.childNodes),i.remove()};e.d.head.append(e.d.querySelector("style["+e.i+"]")||""),e.j={},e.x=(d,o,n,a,g)=>{"#"==d?(r[o]=l).i++:n==t&&i(),"T"==n.tagName&&(o=n.getAttribute(e.i))&&((a=e.l["^"+o])&&(r[o]={i:1,c(i=e.l[o]||n){for(;(t=i.previousSibling||a).remove(),a!=t;);c(i,n)}}),t=n.nextSibling,l=r[o],i=()=>{a||c(e.l[o],n),--l.i||l.c()},(d=e.j[o])&&(g=l.c,l.c=()=>g()+d(e.r)))}})`;

// src/html/serializer.ts
var kTouchedIterator = Symbol();
var { hasOwnProperty } = {};
var Generator = function* () {
}().constructor;
var AsyncGenerator = async function* () {
}().constructor;
patchIteratorNext(Generator.prototype);
patchIteratorNext(AsyncGenerator.prototype);
var REGISTRY = /* @__PURE__ */ new WeakMap();
var KNOWN_SYMBOLS = (() => {
  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();
  for (const name of Object.getOwnPropertyNames(Symbol)) {
    const symbol = Symbol[name];
    if (typeof symbol === "symbol") {
      KNOWN_SYMBOLS2.set(symbol, "Symbol." + name);
    }
  }
  return KNOWN_SYMBOLS2;
})();
var KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([
  // This is by no means an exhaustive list,
  // but it should cover most of the built-in functions.
  [AggregateError, "AggregateError"],
  [Array, "Array"],
  [Array.from, "Array.from"],
  [Array.isArray, "Array.isArray"],
  [Array.of, "Array.of"],
  [ArrayBuffer, "ArrayBuffer"],
  [ArrayBuffer.isView, "ArrayBuffer.isView"],
  [Atomics.add, "Atomics.add"],
  [Atomics.and, "Atomics.and"],
  [Atomics.compareExchange, "Atomics.compareExchange"],
  [Atomics.exchange, "Atomics.exchange"],
  [Atomics.isLockFree, "Atomics.isLockFree"],
  [Atomics.load, "Atomics.load"],
  [Atomics.notify, "Atomics.notify"],
  [Atomics.or, "Atomics.or"],
  [Atomics.store, "Atomics.store"],
  [Atomics.sub, "Atomics.sub"],
  [Atomics.wait, "Atomics.wait"],
  [BigInt, "BigInt"],
  [BigInt.asIntN, "BigInt.asIntN"],
  [BigInt.asUintN, "BigInt.asUintN"],
  [BigInt64Array, "BigInt64Array"],
  [BigInt64Array.from, "BigInt64Array.from"],
  [BigInt64Array.of, "BigInt64Array.of"],
  [BigUint64Array, "BigUint64Array"],
  [BigUint64Array.from, "BigUint64Array.from"],
  [BigUint64Array.of, "BigUint64Array.of"],
  [Boolean, "Boolean"],
  [console.assert, "console.assert"],
  [console.clear, "console.clear"],
  [console.count, "console.count"],
  [console.countReset, "console.countReset"],
  [console.debug, "console.debug"],
  [console.dir, "console.dir"],
  [console.dirxml, "console.dirxml"],
  [console.error, "console.error"],
  [console.group, "console.group"],
  [console.groupCollapsed, "console.groupCollapsed"],
  [console.groupEnd, "console.groupEnd"],
  [console.info, "console.info"],
  [console.log, "console.log"],
  [console.table, "console.table"],
  [console.time, "console.time"],
  [console.timeEnd, "console.timeEnd"],
  [console.timeLog, "console.timeLog"],
  [console.timeStamp, "console.timeStamp"],
  [console.trace, "console.trace"],
  [console.warn, "console.warn"],
  [DataView, "DataView"],
  [Date, "Date"],
  [Date.now, "Date.now"],
  [Date.parse, "Date.parse"],
  [Date.UTC, "Date.UTC"],
  [decodeURI, "decodeURI"],
  [decodeURIComponent, "decodeURIComponent"],
  [encodeURI, "encodeURI"],
  [encodeURIComponent, "encodeURIComponent"],
  [Error, "Error"],
  [EvalError, "EvalError"],
  [Float32Array, "Float32Array"],
  [Float32Array.from, "Float32Array.from"],
  [Float32Array.of, "Float32Array.of"],
  [Float64Array, "Float64Array"],
  [Float64Array.from, "Float64Array.from"],
  [Float64Array.of, "Float64Array.of"],
  [Function, "Function"],
  [globalThis.atob, "atob"],
  [globalThis.btoa, "btoa"],
  [globalThis.clearImmediate, "clearImmediate"],
  [globalThis.clearInterval, "clearInterval"],
  [globalThis.clearTimeout, "clearTimeout"],
  [globalThis.crypto?.getRandomValues, "crypto.getRandomValues"],
  [globalThis.crypto?.randomUUID, "crypto.randomUUID"],
  [globalThis.fetch, "fetch"],
  [globalThis.performance?.now, "performance.now"],
  [globalThis.queueMicrotask, "queueMicrotask"],
  [globalThis.setImmediate, "setImmediate"],
  [globalThis.setInterval, "setInterval"],
  [globalThis.setTimeout, "setTimeout"],
  [globalThis.structuredClone, "structuredClone"],
  [globalThis.URL, "URL"],
  [globalThis.URLSearchParams, "URLSearchParams"],
  [globalThis.WritableStream, "WritableStream"],
  [Int16Array, "Int16Array"],
  [Int16Array.from, "Int16Array.from"],
  [Int16Array.of, "Int16Array.of"],
  [Int32Array, "Int32Array"],
  [Int32Array.from, "Int32Array.from"],
  [Int32Array.of, "Int32Array.of"],
  [Int8Array, "Int8Array"],
  [Int8Array.from, "Int8Array.from"],
  [Int8Array.of, "Int8Array.of"],
  [Intl.Collator, "Intl.Collator"],
  [Intl.DateTimeFormat, "Intl.DateTimeFormat"],
  [Intl.DisplayNames, "Intl.DisplayNames"],
  [Intl.getCanonicalLocales, "Intl.getCanonicalLocales"],
  [Intl.ListFormat, "Intl.ListFormat"],
  [Intl.Locale, "Intl.Locale"],
  [Intl.NumberFormat, "Intl.NumberFormat"],
  [Intl.PluralRules, "Intl.PluralRules"],
  [Intl.RelativeTimeFormat, "Intl.RelativeTimeFormat"],
  [Intl.Segmenter, "Intl.Segmenter"],
  [Intl.supportedValuesOf, "Intl.supportedValuesOf"],
  [isFinite, "isFinite"],
  [isNaN, "isNaN"],
  [JSON.parse, "JSON.parse"],
  [JSON.stringify, "JSON.stringify"],
  [Map, "Map"],
  [Map.groupBy, "Map.groupBy"],
  [Math.abs, "Math.abs"],
  [Math.acos, "Math.acos"],
  [Math.acosh, "Math.acosh"],
  [Math.asin, "Math.asin"],
  [Math.asinh, "Math.asinh"],
  [Math.atan, "Math.atan"],
  [Math.atan2, "Math.atan2"],
  [Math.atanh, "Math.atanh"],
  [Math.cbrt, "Math.cbrt"],
  [Math.ceil, "Math.ceil"],
  [Math.clz32, "Math.clz32"],
  [Math.cos, "Math.cos"],
  [Math.cosh, "Math.cosh"],
  [Math.exp, "Math.exp"],
  [Math.expm1, "Math.expm1"],
  [Math.floor, "Math.floor"],
  [Math.fround, "Math.fround"],
  [Math.hypot, "Math.hypot"],
  [Math.imul, "Math.imul"],
  [Math.log, "Math.log"],
  [Math.log10, "Math.log10"],
  [Math.log1p, "Math.log1p"],
  [Math.log2, "Math.log2"],
  [Math.max, "Math.max"],
  [Math.min, "Math.min"],
  [Math.pow, "Math.pow"],
  [Math.random, "Math.random"],
  [Math.round, "Math.round"],
  [Math.sign, "Math.sign"],
  [Math.sin, "Math.sin"],
  [Math.sinh, "Math.sinh"],
  [Math.sqrt, "Math.sqrt"],
  [Math.tan, "Math.tan"],
  [Math.tanh, "Math.tanh"],
  [Math.trunc, "Math.trunc"],
  [Number, "Number"],
  [Number.isFinite, "Number.isFinite"],
  [Number.isInteger, "Number.isInteger"],
  [Number.isNaN, "Number.isNaN"],
  [Number.isSafeInteger, "Number.isSafeInteger"],
  [Number.parseFloat, "Number.parseFloat"],
  [Number.parseInt, "Number.parseInt"],
  [Object, "Object"],
  [Object.assign, "Object.assign"],
  [Object.create, "Object.create"],
  [Object.defineProperties, "Object.defineProperties"],
  [Object.defineProperty, "Object.defineProperty"],
  [Object.entries, "Object.entries"],
  [Object.freeze, "Object.freeze"],
  [Object.fromEntries, "Object.fromEntries"],
  [Object.getOwnPropertyDescriptor, "Object.getOwnPropertyDescriptor"],
  [Object.getOwnPropertyDescriptors, "Object.getOwnPropertyDescriptors"],
  [Object.getOwnPropertyNames, "Object.getOwnPropertyNames"],
  [Object.getOwnPropertySymbols, "Object.getOwnPropertySymbols"],
  [Object.getPrototypeOf, "Object.getPrototypeOf"],
  [Object.is, "Object.is"],
  [Object.isExtensible, "Object.isExtensible"],
  [Object.isFrozen, "Object.isFrozen"],
  [Object.isSealed, "Object.isSealed"],
  [Object.keys, "Object.keys"],
  [Object.preventExtensions, "Object.preventExtensions"],
  [Object.seal, "Object.seal"],
  [Object.setPrototypeOf, "Object.setPrototypeOf"],
  [Object.values, "Object.values"],
  [parseFloat, "parseFloat"],
  [parseInt, "parseInt"],
  [Promise, "Promise"],
  [Proxy, "Proxy"],
  [RangeError, "RangeError"],
  [ReferenceError, "ReferenceError"],
  [Reflect.apply, "Reflect.apply"],
  [Reflect.construct, "Reflect.construct"],
  [Reflect.defineProperty, "Reflect.defineProperty"],
  [Reflect.deleteProperty, "Reflect.deleteProperty"],
  [Reflect.get, "Reflect.get"],
  [Reflect.getOwnPropertyDescriptor, "Reflect.getOwnPropertyDescriptor"],
  [Reflect.getPrototypeOf, "Reflect.getPrototypeOf"],
  [Reflect.has, "Reflect.has"],
  [Reflect.isExtensible, "Reflect.isExtensible"],
  [Reflect.ownKeys, "Reflect.ownKeys"],
  [Reflect.preventExtensions, "Reflect.preventExtensions"],
  [Reflect.set, "Reflect.set"],
  [Reflect.setPrototypeOf, "Reflect.setPrototypeOf"],
  [RegExp, "RegExp"],
  [Set, "Set"],
  [String, "String"],
  [String.fromCharCode, "String.fromCharCode"],
  [String.fromCodePoint, "String.fromCodePoint"],
  [String.raw, "String.raw"],
  [Symbol, "Symbol"],
  [Symbol.for, "Symbol.for"],
  [SyntaxError, "SyntaxError"],
  [TypeError, "TypeError"],
  [Uint16Array, "Uint16Array"],
  [Uint16Array.from, "Uint16Array.from"],
  [Uint16Array.of, "Uint16Array.of"],
  [Uint32Array, "Uint32Array"],
  [Uint32Array.from, "Uint32Array.from"],
  [Uint32Array.of, "Uint32Array.of"],
  [Uint8Array, "Uint8Array"],
  [Uint8Array.from, "Uint8Array.from"],
  [Uint8Array.of, "Uint8Array.of"],
  [Uint8ClampedArray, "Uint8ClampedArray"],
  [Uint8ClampedArray.from, "Uint8ClampedArray.from"],
  [Uint8ClampedArray.of, "Uint8ClampedArray.of"],
  [URIError, "URIError"],
  [WeakMap, "WeakMap"],
  [WeakSet, "WeakSet"]
]);
var KNOWN_OBJECTS = /* @__PURE__ */ new Map([
  [Atomics, "Atomics"],
  [console, "console"],
  [globalThis, "globalThis"],
  [globalThis.crypto, "crypto"],
  [Intl, "Intl"],
  [JSON, "JSON"],
  [Math, "Math"],
  [Reflect, "Reflect"]
]);
var State = class {
  ids = 0;
  flush = 0;
  flushed = false;
  wroteUndefined = false;
  buf = [];
  refs = /* @__PURE__ */ new WeakMap();
  assigned = /* @__PURE__ */ new Set();
  boundary = void 0;
  mutations = [];
};
var Reference = class {
  constructor(parent, accessor, flush, pos = null, id = null) {
    this.parent = parent;
    this.accessor = accessor;
    this.flush = flush;
    this.pos = pos;
    this.id = id;
    this.parent = parent;
    this.accessor = accessor;
    this.flush = flush;
    this.pos = pos;
    this.id = id;
  }
  init = "";
  assigns = null;
};
var DEBUG = /* @__PURE__ */ new WeakMap();
function setDebugInfo(obj, file, loc, vars) {
  DEBUG.set(obj, { file, loc, vars });
}
var Serializer = class {
  #state = new State();
  get flushed() {
    return this.#state.flushed;
  }
  stringify(val, boundary) {
    try {
      this.#state.flushed = false;
      this.#state.boundary = boundary;
      return writeRoot(this.#state, val);
    } finally {
      this.#state.flush++;
      this.#state.buf = [];
    }
  }
  nextId() {
    return nextId(this.#state);
  }
  symbol(id) {
    const symbol = Symbol();
    this.#state.refs.set(symbol, new Reference(null, null, 0, null, id));
    return symbol;
  }
  writeCall(value, object, property, spread) {
    const state = this.#state;
    state.mutations.push({
      type: 0 /* call */,
      value,
      object,
      property,
      spread
    });
    state.flushed = true;
  }
  writeAssign(value, object, property) {
    const state = this.#state;
    state.mutations.push({
      type: 1 /* assign */,
      value,
      object,
      property
    });
    state.flushed = true;
  }
};
function register(id, val, scope) {
  REGISTRY.set(val, {
    id,
    scope,
    access: "_._" + toAccess(toObjectKey(id)),
    getter: false
  });
  return val;
}
function getRegistered(val) {
  const registered = REGISTRY.get(val);
  if (registered) {
    return { id: registered.id, scope: registered.scope };
  }
}
function writeRoot(state, root) {
  const { buf, assigned, mutations } = state;
  const hadBuf = buf.length !== 0;
  let result = "";
  if (hadBuf) {
    buf.push(",");
  }
  if (writeProp(state, root, null, "")) {
    const rootRef = state.refs.get(root);
    if (rootRef) {
      const rootId = ensureId(state, rootRef);
      if (assigned.size || mutations.length) {
        assigned.delete(rootRef);
        writeAssigned(state);
        buf.push(
          "," + (rootRef.assigns ? assignsToString(rootRef.assigns, rootId) : rootId)
        );
      }
    }
    result = "(";
    buf.push(")");
  } else {
    if (hadBuf) {
      buf.pop();
      writeAssigned(state);
    }
    result = "{";
    buf.push("}");
  }
  for (const chunk of buf) {
    result += chunk;
  }
  if (state.wroteUndefined) {
    state.wroteUndefined = false;
    return "(_,$)=>" + result;
  } else {
    return "_=>" + result;
  }
}
function writeAssigned(state) {
  if (state.assigned.size) {
    for (const valueRef of state.assigned) {
      if (valueRef.init) {
        if (valueRef.assigns) {
          state.buf.push(
            "," + assignsToString(valueRef.assigns, valueRef.init)
          );
        } else {
          state.buf.push("," + valueRef.init);
        }
        valueRef.init = "";
      } else if (valueRef.assigns) {
        state.buf.push("," + assignsToString(valueRef.assigns, valueRef.id));
      }
    }
    state.assigned = /* @__PURE__ */ new Set();
  }
  if (state.mutations.length) {
    for (const mutation of state.mutations) {
      const objectStartIndex = state.buf.push(
        state.buf.length === 0 ? "(" : ",("
      );
      if (writeProp(state, mutation.object, null, "")) {
        const objectRef = state.refs.get(mutation.object);
        if (objectRef && !objectRef.id) {
          objectRef.id = nextRefAccess(state);
          state.buf[objectStartIndex] = objectRef.id + "=" + state.buf[objectStartIndex];
        }
      } else {
        state.buf.push("void 0");
      }
      const valueStartIndex = state.buf.push(
        mutation.type === 0 /* call */ ? ")" + (mutation.property === void 0 ? "" : toAccess(toObjectKey(mutation.property))) + "(" + (mutation.spread ? "..." : "") : toAccess(toObjectKey(mutation.property)) + "="
      );
      if (writeProp(state, mutation.value, null, "")) {
        const valueRef = state.refs.get(mutation.value);
        if (valueRef && !valueRef.id) {
          valueRef.id = nextRefAccess(state);
          state.buf[valueStartIndex] = valueRef.id + "=" + state.buf[valueStartIndex];
        }
      } else {
        state.buf.push("void 0");
      }
      state.buf.push(")");
    }
    state.mutations = [];
    if (state.assigned.size) {
      writeAssigned(state);
    }
  }
}
function writeProp(state, val, parent, accessor) {
  switch (typeof val) {
    case "string":
      return writeString(state, val);
    case "number":
      return writeNumber(state, val);
    case "boolean":
      return writeBoolean(state, val);
    case "bigint":
      return writeBigInt(state, val);
    case "symbol":
      return writeSymbol(state, val, parent, accessor);
    case "function":
      return writeFunction(state, val, parent, accessor);
    case "object":
      return writeObject(state, val, parent, accessor);
    default:
      throwUnserializable(state, val, parent, accessor);
      return false;
  }
}
function writeReferenceOr(state, write2, val, parent, accessor) {
  let ref = state.refs.get(val);
  if (ref) {
    if (ref.init) {
      addAssignment(ref, ensureId(state, parent) + toAccess(accessor));
      return false;
    }
    if (isCircular(parent, ref)) {
      if (!ref.assigns) {
        ensureId(state, ref);
        state.assigned.add(ref);
      }
      addAssignment(ref, ensureId(state, parent) + toAccess(accessor));
      return false;
    }
    state.buf.push(ensureId(state, ref));
    return true;
  }
  const registered = REGISTRY.get(val);
  if (registered)
    return writeRegistered(state, val, parent, accessor, registered);
  state.refs.set(
    val,
    ref = new Reference(parent, accessor, state.flush, state.buf.length)
  );
  if (true) {
    ref.debug = DEBUG.get(val);
  }
  if (write2(state, val, ref)) return true;
  state.refs.delete(ref);
  return false;
}
function writeRegistered(state, val, parent, accessor, { access, scope, getter }) {
  if (scope) {
    const scopeRef = state.refs.get(scope);
    const fnRef = new Reference(
      parent,
      accessor,
      state.flush,
      state.buf.length
    );
    state.refs.set(val, fnRef);
    if (getter) {
      if (scopeRef) {
        state.buf.push("()=>" + ensureId(state, scopeRef) + access);
        return true;
      }
      state.buf.push("(s=>()=>s" + access + ")(");
      writeProp(state, scope, parent, "");
      state.buf.push(")");
      const newScopeRef = state.refs.get(scope);
      if (newScopeRef) ensureId(state, newScopeRef);
      return true;
    }
    if (scopeRef) {
      if (parent && (state.assigned.has(scopeRef) || isCircular(parent, scopeRef))) {
        state.assigned.add(parent);
        state.assigned.add(fnRef);
        fnRef.init = access + "(" + ensureId(state, scopeRef) + ")";
        addAssignment(fnRef, ensureId(state, parent) + toAccess(accessor));
        return false;
      }
      state.buf.push(access + "(" + ensureId(state, scopeRef) + ")");
    } else {
      const pos = state.buf.push("") - 1;
      const assigns = state.assigned.size;
      writeProp(state, scope, parent, "");
      const scopeRef2 = parent && state.refs.get(scope);
      const scopeId = scopeRef2 && ensureId(state, scopeRef2);
      if (scopeId && assigns !== state.assigned.size) {
        state.assigned.add(parent);
        state.assigned.add(fnRef);
        fnRef.init = access + "(" + scopeId + ")";
        addAssignment(fnRef, ensureId(state, parent) + toAccess(accessor));
      } else {
        state.buf[pos] = access + "(" + state.buf[pos];
        state.buf.push(")");
      }
    }
  } else {
    state.buf.push(access);
  }
  return true;
}
function writeString(state, val) {
  state.buf.push(quote(val, 0));
  return true;
}
function writeNumber(state, val) {
  state.buf.push(val + "");
  return true;
}
function writeBoolean(state, val) {
  state.buf.push(val ? "!0" : "!1");
  return true;
}
function writeBigInt(state, val) {
  state.buf.push(val + "n");
  return true;
}
function writeFunction(state, val, parent, accessor) {
  const wellKnownFunction = KNOWN_FUNCTIONS.get(val);
  if (wellKnownFunction) {
    state.buf.push(wellKnownFunction);
    return true;
  }
  return writeReferenceOr(state, writeNever, val, parent, accessor);
}
function writeSymbol(state, val, parent, accessor) {
  const wellKnownSymbol = KNOWN_SYMBOLS.get(val);
  if (wellKnownSymbol) {
    state.buf.push(wellKnownSymbol);
    return true;
  }
  const key = Symbol.keyFor(val);
  if (key !== void 0) {
    state.buf.push("Symbol.for(" + quote(key, 0) + ")");
    return true;
  }
  return writeReferenceOr(state, writeUnknownSymbol, val, parent, accessor);
}
function writeUnknownSymbol(state) {
  state.buf.push("Symbol()");
  return true;
}
function writeNever(state, val, ref) {
  throwUnserializable(state, val, ref);
  return false;
}
function writeNull(state) {
  state.buf.push("null");
  return true;
}
function writeObject(state, val, parent, accessor) {
  if (val === null) return writeNull(state);
  const wellKnownObject = KNOWN_OBJECTS.get(val);
  if (wellKnownObject) {
    state.buf.push(wellKnownObject);
    return true;
  }
  return writeReferenceOr(state, writeUnknownObject, val, parent, accessor);
}
function writeUnknownObject(state, val, ref) {
  switch (val.constructor) {
    case void 0:
      return writeNullObject(state, val, ref);
    case Object:
      return writePlainObject(state, val, ref);
    case Array:
      return writeArray(state, val, ref);
    case Date:
      return writeDate(state, val);
    case RegExp:
      return writeRegExp(state, val);
    case Promise:
      return writePromise(state, val, ref);
    case Map:
      return writeMap(state, val, ref);
    case Set:
      return writeSet(state, val, ref);
    case Generator:
      return writeGenerator(state, val, ref);
    case AsyncGenerator:
      return writeAsyncGenerator(state, val, ref);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return writeError(state, val, ref);
    case AggregateError:
      return writeAggregateError(state, val, ref);
    case ArrayBuffer:
      return writeArrayBuffer(state, val);
    case Int8Array:
    case Uint8Array:
    case Uint8ClampedArray:
    case Int16Array:
    case Uint16Array:
    case Int32Array:
    case Uint32Array:
    case Float32Array:
    case Float64Array:
      return writeTypedArray(state, val, ref);
    case WeakSet:
      return writeWeakSet(state);
    case WeakMap:
      return writeWeakMap(state);
    // The following references use `globalThis`
    // since they are not implemented by all runtimes.
    case globalThis.URL:
      return writeURL(state, val);
    case globalThis.URLSearchParams:
      return writeURLSearchParams(state, val);
    case globalThis.Headers:
      return writeHeaders(state, val);
    case globalThis.FormData:
      return writeFormData(state, val);
    case globalThis.ReadableStream:
      return writeReadableStream(state, val, ref);
    case globalThis.Request:
      return writeRequest(state, val, ref);
    case globalThis.Response:
      return writeResponse(state, val, ref);
  }
  throwUnserializable(state, val, ref);
  return false;
}
function writePlainObject(state, val, ref) {
  state.buf.push("{");
  writeObjectProps(state, val, ref);
  state.buf.push("}");
  return true;
}
function writeArray(state, val, ref) {
  let sep = "[";
  for (let i = 0; i < val.length; i++) {
    const item = val[i];
    state.buf.push(sep);
    sep = ",";
    if (item === void 0) {
      state.wroteUndefined = true;
      state.buf.push("$");
    } else {
      writeProp(state, item, ref, "" + i);
    }
  }
  if (sep === "[") {
    state.buf.push("[]");
  } else {
    state.buf.push("]");
  }
  return true;
}
function writeDate(state, val) {
  state.buf.push('new Date("' + val.toISOString() + '")');
  return true;
}
function writeRegExp(state, val) {
  state.buf.push(val + "");
  return true;
}
function writePromise(state, val, ref) {
  const { boundary } = state;
  if (!boundary) return false;
  const pId = nextRefAccess(state);
  const pRef = new Reference(ref, null, state.flush, null, pId);
  state.buf.push("new Promise((f,r)=>" + pId + "={f,r})");
  val.then(
    (v) => writeAsyncCall(state, boundary, pRef, "f", v, pId),
    (v) => writeAsyncCall(state, boundary, pRef, "r", v, pId)
  );
  boundary.startAsync();
  return true;
}
function writeMap(state, val, ref) {
  if (!val.size) {
    state.buf.push("new Map");
    return true;
  }
  const arrayRef = new Reference(
    ref,
    null,
    state.flush,
    null,
    nextRefAccess(state)
  );
  const items = [];
  let assigns;
  let i = 0;
  if (val.size < 25) {
    for (let [itemKey, itemValue] of val) {
      if (itemKey === val) {
        itemKey = void 0;
        (assigns ||= []).push("a[" + i + "][0]");
      }
      if (itemValue === val) {
        itemValue = void 0;
        (assigns ||= []).push("a[" + i + "][1]");
      }
      i = items.push(
        itemValue === void 0 ? itemKey === void 0 ? [] : [itemKey] : [itemKey, itemValue]
      );
    }
    if (assigns) {
      state.buf.push(
        "((m,a)=>(" + assignsToString(assigns, "m") + ",a.forEach(i=>m.set(i[0],i[1])),m))(new Map," + arrayRef.id + "="
      );
    } else {
      state.buf.push("new Map(" + arrayRef.id + "=");
    }
    writeArray(state, items, arrayRef);
    state.buf.push(")");
  } else {
    for (let [itemKey, itemValue] of val) {
      if (itemKey === val) {
        itemKey = 0;
        (assigns ||= []).push("a[" + i + "]");
      }
      if (itemValue === val) {
        itemValue = 0;
        (assigns ||= []).push("a[" + (i + 1) + "]");
      }
      i = items.push(itemKey, itemValue);
    }
    if (assigns) {
      state.buf.push(
        "(a=>a.reduce((m,v,i)=>i%2?m:m.set(v,a[i+1])," + assignsToString(assigns, "new Map") + "))(" + arrayRef.id + "="
      );
    } else {
      state.buf.push(
        "(a=>a.reduce((m,v,i)=>i%2?m:m.set(v,a[i+1]),new Map))(" + arrayRef.id + "="
      );
    }
    writeArray(state, items, arrayRef);
    state.buf.push(")");
  }
  return true;
}
function writeSet(state, val, ref) {
  if (!val.size) {
    state.buf.push("new Set");
    return true;
  }
  const items = [];
  let assigns;
  let i = 0;
  for (let item of val) {
    if (item === val) {
      item = 0;
      (assigns ||= []).push("i[" + i + "]");
    }
    i = items.push(item);
  }
  const arrayRef = new Reference(
    ref,
    null,
    state.flush,
    null,
    nextRefAccess(state)
  );
  state.buf.push(
    (assigns ? "((s,i)=>(" + assignsToString(assigns, "s") + ",i.forEach(i=>s.add(i)),s))(new Set," : "new Set(") + arrayRef.id + "="
  );
  writeArray(state, items, arrayRef);
  state.buf.push(")");
  return true;
}
function writeArrayBuffer(state, val) {
  let result = "";
  if (val.byteLength) {
    const view = new Int8Array(val);
    result = hasOnlyZeros(view) ? "new ArrayBuffer(" + val.byteLength + ")" : "new Int8Array(" + typedArrayToInitString(view) + ").buffer";
  } else {
    result = "new ArrayBuffer";
  }
  state.buf.push(result);
  return true;
}
function writeTypedArray(state, val, ref) {
  if (val.byteOffset || state.refs.has(val.buffer)) {
    state.buf.push("new " + val.constructor.name + "(");
    writeProp(state, val.buffer, ref, "buffer");
    state.buf.push(val.byteOffset ? "," + val.byteOffset + ")" : ")");
  } else {
    state.refs.set(val.buffer, new Reference(ref, "buffer", state.flush, null));
    state.buf.push(
      "new " + val.constructor.name + (val.length === 0 ? "" : "(" + (hasOnlyZeros(val) ? val.length : typedArrayToInitString(val)) + ")")
    );
  }
  return true;
}
function writeWeakSet(state) {
  state.buf.push("new WeakSet");
  return true;
}
function writeWeakMap(state) {
  state.buf.push("new WeakMap");
  return true;
}
function writeError(state, val, ref) {
  const result = "new " + val.constructor.name + "(" + quote(val.message + "", 0);
  if (val.cause) {
    state.buf.push(result + ",{cause:");
    writeProp(state, val.cause, ref, "cause");
    state.buf.push("})");
  } else {
    state.buf.push(result + ")");
  }
  return true;
}
function writeAggregateError(state, val, ref) {
  state.buf.push("new AggregateError(");
  writeProp(state, val.errors, ref, "errors");
  if (val.message) {
    state.buf.push("," + quote(val.message + "", 0) + ")");
  } else {
    state.buf.push(")");
  }
  return true;
}
function writeURL(state, val) {
  state.buf.push("new URL(" + quote(val.toString(), 0) + ")");
  return true;
}
function writeURLSearchParams(state, val) {
  const str = val.toString();
  if (str) {
    state.buf.push("new URLSearchParams(" + quote(str, 0) + ")");
  } else {
    state.buf.push("new URLSearchParams");
  }
  return true;
}
function writeHeaders(state, val) {
  const headers = stringEntriesToProps(val);
  state.buf.push("new Headers" + (headers ? "({" + headers + "})" : ""));
  return true;
}
function writeFormData(state, val) {
  let sep = "[";
  let valStr = "";
  for (const [key, value] of val) {
    if (typeof value === "string") {
      valStr += sep + quote(key, 0) + "," + quote(value, 0);
      sep = ",";
    }
  }
  if (sep === "[") {
    state.buf.push("new FormData");
  } else {
    state.buf.push(
      valStr + "].reduce((f,v,i,a)=>i%2&&f.append(v,a[i+1])||f,new FormData)"
    );
  }
  return true;
}
function writeRequest(state, val, ref) {
  let sep = "";
  const hasBody = val.body && !val.bodyUsed && val.duplex === "half";
  state.buf.push("new Request(" + quote(val.url, 0));
  if (hasBody) {
    state.buf.push(",{body:");
    if (writeProp(state, val.body, ref, "body")) {
      state.buf.push(',duplex:"half"');
      sep = ",";
    } else {
      state.buf.pop();
    }
  }
  let options = "";
  if (val.cache !== "default") {
    options += sep + "cache:" + quote(val.cache, 0);
    sep = ",";
  }
  if (val.credentials !== "same-origin") {
    options += sep + "credentials:" + quote(val.credentials, 0);
    sep = ",";
  }
  const headers = stringEntriesToProps(val.headers);
  state.refs.set(val.headers, new Reference(ref, "headers", state.flush, null));
  if (headers) {
    options += sep + "headers:{" + headers + "}";
    sep = ",";
  }
  if (val.integrity) {
    options += sep + "integrity:" + quote(val.integrity, 0);
    sep = ",";
  }
  if (val.keepalive) {
    options += sep + "keepalive:true";
    sep = ",";
  }
  if (val.method !== "GET") {
    options += sep + "method:" + quote(val.method, 0);
    sep = ",";
  }
  if (val.mode !== "cors") {
    options += sep + "mode:" + quote(val.mode, 0);
    sep = ",";
  }
  if (val.redirect !== "follow") {
    options += sep + "redirect:" + quote(val.redirect, 0);
    sep = ",";
  }
  if (val.referrer !== "about:client") {
    options += sep + "referrer:" + quote(val.referrer, 0);
    sep = ",";
  }
  if (val.referrerPolicy) {
    options += sep + "referrerPolicy:" + quote(val.referrerPolicy, 0);
    sep = ",";
  }
  state.buf.push(
    hasBody ? options + "})" : options ? ",{" + options + "})" : ")"
  );
  return true;
}
function writeResponse(state, val, ref) {
  let sep = "";
  let options = "";
  if (val.status !== 200) {
    options += "status:" + val.status;
    sep = ",";
  }
  if (val.statusText) {
    options += sep + "statusText:" + quote(val.statusText, 0);
    sep = ",";
  }
  const headers = stringEntriesToProps(val.headers);
  state.refs.set(val.headers, new Reference(ref, "headers", state.flush, null));
  if (headers) {
    options += sep + "headers:{" + headers + "}";
    sep = ",";
  }
  if (!val.body || val.bodyUsed) {
    state.buf.push(
      "new Response" + (options ? "(null,{" + options + "})" : "")
    );
  } else {
    state.buf.push("new Response(");
    state.buf.push(
      (writeProp(state, val.body, ref, "body") ? "" : "null") + (options ? ",{" + options + "})" : ")")
    );
  }
  return true;
}
function writeReadableStream(state, val, ref) {
  const { boundary } = state;
  if (!boundary || val.locked) return false;
  const reader = val.getReader();
  const iterId = nextRefAccess(state);
  const iterRef = new Reference(ref, null, state.flush, null, iterId);
  const onFulfilled = ({ value, done }) => {
    if (done) {
      writeAsyncCall(state, boundary, iterRef, "r", value);
    } else if (!boundary.signal.aborted) {
      reader.read().then(onFulfilled, onRejected);
      boundary.startAsync();
      writeAsyncCall(state, boundary, iterRef, "f", value);
    }
  };
  const onRejected = (reason) => {
    writeAsyncCall(state, boundary, iterRef, "j", reason);
  };
  state.buf.push(
    "new ReadableStream({start(c){(async(_,f,v,l,i,p=a=>l=new Promise((r,j)=>{f=_.r=r;_.j=j}),a=((_.f=v=>{f(v);a.push(p())}),[p()]))=>{for(i of a)v=await i,i==l?c.close():c.enqueue(v)})(" + iterId + "={}).catch(e=>c.error(e))}})"
  );
  reader.read().then(onFulfilled, onRejected);
  boundary.startAsync();
  return true;
}
function writeGenerator(state, iter, ref) {
  if (iter[kTouchedIterator]) {
    state.buf.push("(async function*(){}())");
    return true;
  }
  let sep = "";
  state.buf.push("(function*(){");
  while (true) {
    const { value, done } = iter.next();
    if (done) {
      if (value !== void 0) {
        state.buf.push(sep + "return ");
        writeProp(state, value, ref, "");
      }
      break;
    }
    if (value === void 0) {
      state.buf.push(sep + "yield");
    } else {
      state.buf.push(sep + "yield ");
      writeProp(state, value, ref, "");
    }
    sep = ";";
  }
  state.buf.push("})()");
  return true;
}
function writeAsyncGenerator(state, iter, ref) {
  if (iter[kTouchedIterator]) {
    state.buf.push("(async function*(){}())");
    return true;
  }
  const { boundary } = state;
  if (!boundary) return false;
  const iterId = nextRefAccess(state);
  const iterRef = new Reference(ref, null, state.flush, null, iterId);
  const onFulfilled = ({ value, done }) => {
    if (done) {
      writeAsyncCall(state, boundary, iterRef, "r", value);
    } else if (!boundary.signal.aborted) {
      iter.next().then(onFulfilled, onRejected);
      boundary.startAsync();
      writeAsyncCall(state, boundary, iterRef, "f", value);
    }
  };
  const onRejected = (reason) => {
    writeAsyncCall(state, boundary, iterRef, "j", reason);
  };
  state.buf.push(
    "(async function*(_,f,v,l,i,p=a=>l=new Promise((r,j)=>{f=_.r=r;_.j=j}),a=((_.f=v=>{f(v);a.push(p())}),[p()])){for(i of a)v=await i,i!=l&&(yield v);return v})(" + iterId + "={})"
  );
  iter.next().then(onFulfilled, onRejected);
  boundary.startAsync();
  return true;
}
function writeNullObject(state, val, ref) {
  state.buf.push("{");
  state.buf.push(writeObjectProps(state, val, ref) + "__proto__:null}");
  return true;
}
function writeObjectProps(state, val, ref) {
  let sep = "";
  for (const key in val) {
    if (hasOwnProperty.call(val, key)) {
      const escapedKey = toObjectKey(key);
      state.buf.push(sep + escapedKey + ":");
      if (writeProp(
        state,
        val[key],
        ref,
        escapedKey
      )) {
        sep = ",";
      } else {
        state.buf.pop();
      }
    }
  }
  if (hasSymbolIterator(val)) {
    const iterArr = [...val];
    switch (iterArr.length) {
      case 0:
        state.buf.push(sep + "*[Symbol.iterator](){}");
        break;
      case 1:
        state.buf.push(
          sep + "*[Symbol.iterator](){yield " + (iterArr[0] === val ? "this" : ensureId(state, ref)) + "}"
        );
        break;
      default: {
        const iterRef = new Reference(
          ref,
          null,
          state.flush,
          null,
          nextRefAccess(state)
        );
        state.buf.push(sep + "*[(" + iterRef.id + "=");
        writeArray(state, iterArr, iterRef);
        state.buf.push(",Symbol.iterator)](){yield*" + iterRef.id + "}");
        break;
      }
    }
    sep = ",";
  }
  return sep;
}
function writeAsyncCall(state, boundary, ref, method, value, preferredValueId = null) {
  if (boundary.signal.aborted) return;
  state.flushed = true;
  const valueStartIndex = state.buf.push(
    (state.buf.length === 0 ? "" : ",") + ref.id + "." + method + "("
  );
  if (writeProp(state, value, ref, "")) {
    const valueRef = state.refs.get(value);
    if (valueRef && !valueRef.id) {
      valueRef.id = preferredValueId || nextRefAccess(state);
      state.buf[valueStartIndex] = valueRef.id + "=" + state.buf[valueStartIndex];
    }
  }
  state.buf.push(")");
  boundary.endAsync();
}
function throwUnserializable(state, cause, ref = null, accessor = "") {
  if (cause !== void 0 && state.boundary?.abort) {
    let message = "Unable to serialize";
    let access = "";
    while (ref?.accessor) {
      const debug = ref.parent?.debug;
      if (debug) {
        const varLoc = debug.vars?.[ref.accessor];
        let debugAccess = ref.accessor;
        let debugLoc = debug.loc;
        if (varLoc) {
          if (Array.isArray(varLoc)) {
            debugAccess = varLoc[0];
            if (varLoc[1]) debugLoc = varLoc[1];
          } else {
            debugLoc = varLoc;
          }
        }
        message += ` ${JSON.stringify(debugAccess)} in ${debug.file}`;
        if (debugLoc) message += `:${debugLoc}`;
        break;
      }
      access = toAccess(ref.accessor) + access;
      ref = ref.parent;
    }
    if (accessor) {
      access = toAccess(accessor) + access;
    }
    if (access[0] === ".") {
      access = access.slice(1);
    }
    if (access) {
      message += ` (reading ${access})`;
    }
    const err = new TypeError(message, { cause });
    err.stack = void 0;
    state.boundary.abort(err);
  }
}
function isCircular(parent, ref) {
  let cur = parent;
  while (cur) {
    if (cur === ref) return true;
    cur = cur.parent;
  }
  return false;
}
function toObjectKey(name) {
  if (name === "") {
    return '""';
  }
  const startChar = name[0];
  if (isDigit(startChar)) {
    if (startChar === "0") {
      if (name !== "0") {
        return quote(name, 1);
      }
    } else {
      for (let i = 1; i < name.length; i++) {
        if (!isDigit(name[i])) {
          return quote(name, i);
        }
      }
    }
  } else if (isWord(startChar)) {
    for (let i = 1; i < name.length; i++) {
      if (!isWordOrDigit(name[i])) {
        return quote(name, i);
      }
    }
  } else {
    return quote(name, 0);
  }
  return name;
}
function toAccess(accessor) {
  const start = accessor[0];
  return start === '"' || start >= "0" && start <= "9" ? "[" + accessor + "]" : "." + accessor;
}
function quote(str, startPos) {
  let result = "";
  let lastPos = 0;
  for (let i = startPos; i < str.length; i++) {
    let replacement;
    switch (str[i]) {
      case '"':
        replacement = '\\"';
        break;
      case "\\":
        replacement = "\\\\";
        break;
      case "<":
        replacement = "\\x3C";
        break;
      case "\n":
        replacement = "\\n";
        break;
      case "\r":
        replacement = "\\r";
        break;
      case "\u2028":
        replacement = "\\u2028";
        break;
      case "\u2029":
        replacement = "\\u2029";
        break;
      default:
        continue;
    }
    result += str.slice(lastPos, i) + replacement;
    lastPos = i + 1;
  }
  return '"' + (lastPos === startPos ? str : result + str.slice(lastPos)) + '"';
}
function ensureId(state, ref) {
  return ref.id || assignId(state, ref);
}
function assignId(state, ref) {
  const { pos } = ref;
  ref.id = nextRefAccess(state);
  if (pos !== null && ref.flush === state.flush) {
    if (pos === 0) {
      state.buf[0] = ref.id + "=" + state.buf[0];
    } else {
      state.buf[pos - 1] += ref.id + "=";
    }
    return ref.id;
  }
  let cur = ref;
  let accessPrevValue = "";
  do {
    accessPrevValue = toAccess(cur.accessor) + accessPrevValue;
    const parent = cur.parent;
    if (parent.id) {
      accessPrevValue = parent.id + accessPrevValue;
      break;
    }
    if (parent.flush === state.flush) {
      accessPrevValue = ensureId(state, parent) + accessPrevValue;
      break;
    }
    cur = parent;
  } while (cur);
  return ref.id + "=" + accessPrevValue;
}
function assignsToString(assigns, value) {
  if (assigns.length > 100) {
    return "($=>(" + assigns.join("=$,") + "=$))(" + value + ")";
  }
  return assigns.join("=") + "=" + value;
}
function addAssignment(ref, assign) {
  if (ref.assigns) {
    ref.assigns.push(assign);
  } else {
    ref.assigns = [assign];
  }
}
function nextRefAccess(state) {
  return "_." + nextId(state);
}
function nextId(state) {
  const c = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
  let n = state.ids++;
  let r = c[n % 53];
  for (n = n / 53 | 0; n; n >>>= 6) {
    r += c[n & 63];
  }
  return r;
}
function hasSymbolIterator(value) {
  return Symbol.iterator in value;
}
function stringEntriesToProps(entries) {
  let result = "";
  let sep = "";
  for (const [key, value] of entries) {
    result += sep + toObjectKey(key) + ":" + quote(value, 0);
    sep = ",";
  }
  return result;
}
function typedArrayToInitString(view) {
  let result = "[";
  let sep = "";
  for (let i = 0; i < view.length; i++) {
    result += sep + view[i];
    sep = ",";
  }
  result += "]";
  return result;
}
function hasOnlyZeros(typedArray) {
  for (let i = 0; i < typedArray.length; i++) {
    if (typedArray[i] !== 0) return false;
  }
  return true;
}
function isWordOrDigit(char) {
  return isWord(char) || isDigit(char);
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function isWord(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
}
function patchIteratorNext(proto) {
  const { next } = proto;
  proto.next = function(value) {
    this[kTouchedIterator] = 1;
    return next.call(this, value);
  };
}

// src/html/writer.ts
var $chunk;
var NOOP = () => {
};
var K_SCOPE_ID = Symbol("Scope ID");
function getChunk() {
  return $chunk;
}
function getContext(key) {
  return $chunk.context?.[key];
}
function getState() {
  return $chunk.boundary.state;
}
function getScopeId(scope) {
  return scope[K_SCOPE_ID];
}
function write(html) {
  $chunk.writeHTML(html);
}
function writeScript(script) {
  $chunk.writeScript(script);
}
function writeEffect(scopeId, registryId) {
  $chunk.boundary.state.needsMainRuntime = true;
  $chunk.writeEffect(scopeId, registryId);
}
function writeContent(nodeAccessor, scopeId, content, serializeReason) {
  const shouldResume = serializeReason !== 0;
  const render2 = normalizeServerRender(content);
  const branchId = peekNextScopeId();
  if (render2) {
    if (shouldResume) {
      withBranchId(branchId, render2);
    } else {
      render2();
    }
  }
  const rendered = peekNextScopeId() !== branchId;
  if (rendered) {
    if (shouldResume) {
      writeScope(scopeId, {
        ["ConditionalScope:" /* ConditionalScope */ + nodeAccessor]: writeScope(
          branchId,
          {}
        ),
        ["ConditionalRenderer:" /* ConditionalRenderer */ + nodeAccessor]: render2?.___id
      });
    }
  } else {
    nextScopeId();
  }
}
function normalizeServerRender(value) {
  const renderer = normalizeDynamicRenderer(value);
  if (renderer) {
    if (typeof renderer === "function") {
      return renderer;
    } else if (true) {
      throw new Error(
        `Invalid \`content\` attribute. Received ${typeof value}`
      );
    }
  }
}
var kPendingContexts = Symbol("Pending Contexts");
function withContext(key, value, cb) {
  const ctx = $chunk.context ||= { [kPendingContexts]: 0 };
  const prev = ctx[key];
  ctx[kPendingContexts]++;
  ctx[key] = value;
  try {
    return cb();
  } finally {
    ctx[kPendingContexts]--;
    ctx[key] = prev;
  }
}
function setTagVar(parentScopeId, scopeOffsetAccessor, childScopeId, registryId) {
  ensureScopeWithId(parentScopeId)[scopeOffsetAccessor] = nextScopeId();
  ensureScopeWithId(childScopeId)["#TagVariable" /* TagVariable */] = register2(
    {},
    registryId,
    parentScopeId
  );
}
function register2(val, id, scopeId) {
  return scopeId === void 0 ? register(id, val) : register(id, val, ensureScopeWithId(scopeId));
}
function nextTagId() {
  const state = $chunk.boundary.state;
  const { $global: $global2 } = state;
  return "s" + $global2.runtimeId + $global2.renderId + (state.tagId++).toString(36);
}
function nextScopeId() {
  return $chunk.boundary.state.scopeId++;
}
function peekNextScopeId() {
  return $chunk.boundary.state.scopeId;
}
function getScopeById(scopeId) {
  if (scopeId !== void 0) {
    return $chunk.boundary.state.scopes.get(scopeId);
  }
}
function serializeIf(condition, key) {
  return condition && (condition === 1 || condition[key]) ? 1 : void 0;
}
function serializeGuard(condition, key) {
  return condition && (condition === 1 || condition[key]) ? 1 : 0;
}
function markResumeNode(scopeId, accessor, shouldResume) {
  if (shouldResume === 0) return "";
  const { state } = $chunk.boundary;
  state.needsMainRuntime = true;
  return state.mark("*" /* Node */, scopeId + " " + accessor);
}
function commentSeparator(shouldResume) {
  return shouldResume === 0 ? "" : "<!>";
}
function nodeRef(scopeId, id) {
  const getter = () => {
    if (true) {
      throw new Error("Cannot read a node reference on the server.");
    }
  };
  return id ? register2(getter, id, scopeId) : getter;
}
function hoist(scopeId, id) {
  const getter = () => {
    if (true) {
      throw new Error("Cannot read a hoisted value on the server.");
    }
  };
  getter[Symbol.iterator] = getter;
  return id ? register2(getter, id, scopeId) : getter;
}
function resumeClosestBranch(scopeId) {
  const branchId = $chunk.context?.[branchIdKey];
  if (branchId !== void 0 && branchId !== scopeId) {
    writeScope(scopeId, { ["#ClosestBranchId" /* ClosestBranchId */]: branchId });
  }
}
var branchIdKey = Symbol();
function withBranchId(branchId, cb) {
  return withContext(branchIdKey, branchId, cb);
}
function resumeForOf(list, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  const { state } = $chunk.boundary;
  const resumeBranch = serializeBranch !== 0;
  const resumeMarker = serializeMarker !== 0;
  let singleNodeBranchIds = "";
  if (resumeBranch) {
    const loopScopes = /* @__PURE__ */ new Map();
    forOf(list, (item, index) => {
      const branchId = peekNextScopeId();
      if (resumeMarker) {
        if (singleNode) {
          singleNodeBranchIds = " " + branchId + singleNodeBranchIds;
        } else {
          $chunk.writeHTML(
            state.mark("[" /* BranchStart */, branchId + (index ? " " : ""))
          );
        }
      }
      withBranchId(branchId, () => {
        cb(item, index);
        loopScopes.set(forOfBy(by, item, index), writeScope(branchId, {}));
      });
    });
    if (loopScopes.size) {
      writeScope(scopeId, {
        ["LoopScopeMap:" /* LoopScopeMap */ + accessor]: loopScopes
      });
    }
  } else {
    forOf(list, cb);
  }
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeForIn(obj, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  const { state } = $chunk.boundary;
  const resumeBranch = serializeBranch !== 0;
  const resumeMarker = serializeMarker !== 0;
  let singleNodeBranchIds = "";
  if (resumeBranch) {
    const loopScopes = /* @__PURE__ */ new Map();
    let sep = "";
    forIn(obj, (key, value) => {
      const branchId = peekNextScopeId();
      if (resumeMarker) {
        if (singleNode) {
          singleNodeBranchIds = " " + branchId + singleNodeBranchIds;
        } else {
          $chunk.writeHTML(
            state.mark("[" /* BranchStart */, branchId + sep)
          );
          sep = " ";
        }
      }
      withBranchId(branchId, () => {
        cb(key, value);
        loopScopes.set(forInBy(by, key, value), writeScope(branchId, {}));
      });
    });
    if (loopScopes.size) {
      writeScope(scopeId, {
        ["LoopScopeMap:" /* LoopScopeMap */ + accessor]: loopScopes
      });
    }
  } else {
    forIn(obj, cb);
  }
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeForTo(to, from, step, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  const { state } = $chunk.boundary;
  const resumeBranch = serializeBranch !== 0;
  const resumeMarker = serializeMarker !== 0;
  let singleNodeBranchIds = "";
  if (resumeBranch) {
    const loopScopes = /* @__PURE__ */ new Map();
    let sep = "";
    forTo(to, from, step, (i) => {
      const branchId = peekNextScopeId();
      if (resumeMarker) {
        if (singleNode) {
          singleNodeBranchIds = " " + branchId + singleNodeBranchIds;
        } else {
          $chunk.writeHTML(
            state.mark("[" /* BranchStart */, branchId + sep)
          );
          sep = " ";
        }
      }
      withBranchId(branchId, () => {
        cb(i);
        loopScopes.set(forToBy(by, i), writeScope(branchId, {}));
      });
    });
    if (loopScopes.size) {
      writeScope(scopeId, {
        ["LoopScopeMap:" /* LoopScopeMap */ + accessor]: loopScopes
      });
    }
  } else {
    forTo(to, from, step, cb);
  }
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeConditional(cb, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  const { state } = $chunk.boundary;
  const resumeBranch = serializeBranch !== 0;
  const resumeMarker = serializeMarker !== 0;
  const branchId = peekNextScopeId();
  if (resumeMarker && resumeBranch && !singleNode) {
    $chunk.writeHTML(state.mark("[" /* BranchStart */, branchId + ""));
  }
  const branchIndex = resumeBranch ? withBranchId(branchId, cb) : cb();
  const shouldWriteBranch = resumeBranch && branchIndex !== void 0;
  if (shouldWriteBranch) {
    writeScope(scopeId, {
      ["ConditionalRenderer:" /* ConditionalRenderer */ + accessor]: resumeMarker ? branchIndex : void 0,
      ["ConditionalScope:" /* ConditionalScope */ + accessor]: writeScope(branchId, {})
    });
  }
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + (shouldWriteBranch ? " " + branchId : "")
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function writeBranchEnd(scopeId, accessor, resumeMarker, parentEndTag, mark) {
  const endTag = parentEndTag || "";
  if (resumeMarker) {
    if (mark) {
      $chunk.writeHTML(mark + endTag);
    } else {
      $chunk.writeHTML(endTag + markResumeNode(scopeId, accessor));
    }
  } else {
    $chunk.writeHTML(endTag);
  }
}
var writeScope = (scopeId, partialScope) => {
  const { state } = $chunk.boundary;
  const { scopes } = state;
  let scope = scopes.get(scopeId);
  state.needsMainRuntime = true;
  if (scope) {
    Object.assign(scope, partialScope);
  } else {
    scope = partialScope;
    scope[K_SCOPE_ID] = scopeId;
    state.scopes.set(scopeId, scope);
  }
  if (state.writeScopes) {
    state.writeScopes[scopeId] = scope;
  } else {
    state.writeScopes = { [scopeId]: scope };
  }
  return scope;
};
if (true) {
  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {
    const scope = writeScope2(scopeId, partialScope);
    if (file && loc !== void 0) {
      setDebugInfo(scope, file, loc, vars);
    }
    return scope;
  })(writeScope);
}
function writeExistingScope(scopeId) {
  return writeScope(scopeId, ensureScopeWithId(scopeId));
}
function ensureScopeWithId(scopeId) {
  const { state } = $chunk.boundary;
  let scope = state.scopes.get(scopeId);
  if (!scope) {
    scope = { [K_SCOPE_ID]: scopeId };
    state.scopes.set(scopeId, scope);
  }
  return scope;
}
function $global() {
  return $chunk.boundary.state.$global;
}
function fork(scopeId, accessor, promise, content, serializeMarker) {
  const resumeMarker = serializeMarker !== 0;
  if (!isPromise(promise)) {
    if (resumeMarker) {
      const branchId = peekNextScopeId();
      $chunk.writeHTML(
        $chunk.boundary.state.mark("[" /* BranchStart */, branchId + "")
      );
      content(promise);
      writeScope(scopeId, {
        ["ConditionalScope:" /* ConditionalScope */ + accessor]: writeScope(branchId, {})
      });
      $chunk.writeHTML(
        $chunk.boundary.state.mark(
          "]" /* BranchEnd */,
          scopeId + " " + accessor
        )
      );
    } else {
      content(promise);
    }
    return;
  }
  const chunk = $chunk;
  const { boundary } = chunk;
  chunk.next = $chunk = new Chunk(boundary, chunk.next, chunk.context);
  chunk.async = true;
  if (chunk.context?.[kPendingContexts]) {
    chunk.context = { ...chunk.context, [kPendingContexts]: 0 };
  }
  boundary.startAsync();
  promise.then(
    (value) => {
      if (chunk.async) {
        chunk.async = false;
        if (!boundary.signal.aborted) {
          chunk.render(() => {
            if (resumeMarker) {
              const branchId = peekNextScopeId();
              $chunk.writeHTML(
                $chunk.boundary.state.mark(
                  "[" /* BranchStart */,
                  branchId + ""
                )
              );
              content(value);
              boundary.state.serializer.writeAssign(
                writeScope(branchId, {}),
                ensureScopeWithId(scopeId),
                "ConditionalScope:" /* ConditionalScope */ + accessor
              );
              $chunk.writeHTML(
                $chunk.boundary.state.mark(
                  "]" /* BranchEnd */,
                  scopeId + " " + accessor
                )
              );
            } else {
              content(value);
            }
          });
          boundary.endAsync(chunk);
        }
      }
    },
    (err) => {
      chunk.async = false;
      boundary.abort(err);
    }
  );
}
function tryContent(scopeId, accessor, content, input) {
  const branchId = peekNextScopeId();
  $chunk.writeHTML(
    $chunk.boundary.state.mark("[" /* BranchStart */, branchId + "")
  );
  const catchContent = normalizeDynamicRenderer(input.catch);
  const placeholderContent = normalizeDynamicRenderer(input.placeholder);
  if (catchContent) {
    tryCatch(
      placeholderContent ? () => tryPlaceholder(content, placeholderContent) : content,
      catchContent
    );
  } else if (placeholderContent) {
    tryPlaceholder(content, placeholderContent);
  } else {
    content();
  }
  writeScope(branchId, {
    ["#BranchAccessor" /* BranchAccessor */]: accessor,
    ["#CatchContent" /* CatchContent */]: catchContent,
    ["#PlaceholderContent" /* PlaceholderContent */]: placeholderContent
  });
  writeScope(scopeId, {
    ["ConditionalScope:" /* ConditionalScope */ + accessor]: getScopeById(branchId)
  });
  $chunk.writeHTML(
    $chunk.boundary.state.mark(
      "]" /* BranchEnd */,
      scopeId + " " + accessor
    )
  );
}
function tryPlaceholder(content, placeholder) {
  const chunk = $chunk;
  const { boundary } = chunk;
  const body = new Chunk(boundary, null, chunk.context);
  if (body === body.render(content)) {
    chunk.append(body);
    return;
  }
  chunk.next = $chunk = new Chunk(boundary, chunk.next, body.context);
  chunk.placeholderBody = body;
  chunk.placeholderRender = placeholder;
}
function tryCatch(content, catchContent) {
  const chunk = $chunk;
  const { boundary } = chunk;
  const { state } = boundary;
  const catchBoundary = new Boundary(state);
  const body = new Chunk(catchBoundary, null, chunk.context);
  const bodyEnd = body.render(content);
  if (catchBoundary.signal.aborted) {
    catchContent(catchBoundary.signal.reason);
    return;
  }
  if (body === bodyEnd) {
    chunk.append(body);
    return;
  }
  const reorderId = state.nextReorderId();
  const endMarker = state.mark("!" /* PlaceholderEnd */, reorderId);
  const bodyNext = bodyEnd.next = $chunk = new Chunk(boundary, chunk.next, body.context);
  chunk.next = body;
  chunk.writeHTML(state.mark("!^" /* Placeholder */, reorderId));
  bodyEnd.writeHTML(endMarker);
  boundary.startAsync();
  catchBoundary.onNext = () => {
    if (boundary.signal.aborted) return;
    if (catchBoundary.signal.aborted) {
      if (!bodyEnd.consumed) {
        let cur = body;
        let writeMarker = true;
        do {
          const next = cur.next;
          if (cur.boundary !== catchBoundary) {
            cur.boundary.abort(catchBoundary.signal.reason);
          }
          if (writeMarker && !cur.consumed) {
            writeMarker = false;
            cur.async = false;
            cur.next = bodyNext;
            cur.html = endMarker;
            cur.scripts = cur.effects = cur.lastEffect = "";
            cur.placeholderBody = cur.placeholderRender = cur.reorderId = null;
          }
          cur = next;
        } while (cur !== bodyNext);
      }
      const catchChunk = new Chunk(boundary, null, chunk.context);
      catchChunk.reorderId = reorderId;
      catchChunk.render(catchContent, catchBoundary.signal.reason);
      state.reorder(catchChunk);
      boundary.endAsync();
    } else if (!catchBoundary.count) {
      boundary.endAsync();
    } else {
      boundary.onNext();
    }
  };
}
var State2 = class {
  constructor($global2) {
    this.$global = $global2;
    this.$global = $global2;
    if ($global2.cspNonce) {
      this.nonceAttr = " nonce" + attrAssignment($global2.cspNonce);
    }
  }
  tagId = 1;
  scopeId = 1;
  reorderId = 1;
  lastSerializedScopeId = this.scopeId;
  hasGlobals = false;
  needsMainRuntime = false;
  hasMainRuntime = false;
  hasReorderRuntime = false;
  hasWrittenResume = false;
  walkOnNextFlush = false;
  trailerHTML = "";
  resumes = "";
  nonceAttr = "";
  serializer = new Serializer();
  writeReorders = null;
  scopes = /* @__PURE__ */ new Map();
  writeScopes = null;
  get runtimePrefix() {
    const { $global: $global2 } = this;
    return $global2.runtimeId + "." + $global2.renderId;
  }
  get commentPrefix() {
    const { $global: $global2 } = this;
    return $global2.runtimeId + $global2.renderId;
  }
  reorder(chunk) {
    if (this.writeReorders) {
      this.writeReorders.push(chunk);
    } else {
      this.needsMainRuntime = true;
      this.writeReorders = [chunk];
    }
  }
  nextReorderId() {
    const c = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789";
    let n = this.reorderId++;
    let r = c[n % 54];
    for (n = n / 54 | 0; n; n >>>= 6) {
      r += c[n & 63];
    }
    return r;
  }
  mark(code, str) {
    return "<!--" + this.commentPrefix + code + str + "-->";
  }
};
var Boundary = class extends AbortController {
  constructor(state, parent) {
    super();
    this.state = state;
    this.state = state;
    this.signal.addEventListener("abort", () => {
      this.count = 0;
      this.state = new State2(this.state.$global);
      this.onNext();
    });
    if (parent) {
      if (parent.aborted) {
        this.abort(parent.reason);
      } else {
        parent.addEventListener("abort", () => {
          this.abort(parent.reason);
        });
      }
    }
  }
  onNext = NOOP;
  count = 0;
  get done() {
    flushSerializer(this);
    return !this.count;
  }
  startAsync() {
    if (!this.signal.aborted) {
      this.count++;
    }
  }
  endAsync(chunk) {
    if (!this.signal.aborted && this.count) {
      this.count--;
      if (chunk?.reorderId) {
        this.state.reorder(chunk);
      }
      this.onNext();
    }
  }
};
var Chunk = class {
  constructor(boundary, next, context) {
    this.boundary = boundary;
    this.next = next;
    this.context = context;
    this.boundary = boundary;
    this.next = next;
    this.context = context;
  }
  html = "";
  scripts = "";
  effects = "";
  lastEffect = "";
  async = false;
  consumed = false;
  reorderId = null;
  placeholderBody = null;
  placeholderRender = null;
  writeHTML(html) {
    this.html += html;
  }
  writeEffect(scopeId, registryId) {
    if (this.lastEffect === registryId) {
      this.effects += "," + scopeId;
    } else {
      this.lastEffect = registryId;
      this.effects = concatEffects(
        this.effects,
        '"' + registryId + '",' + scopeId
      );
    }
  }
  writeScript(script) {
    this.scripts = concatScripts(this.scripts, script);
  }
  append(chunk) {
    this.html += chunk.html;
    this.effects = concatEffects(this.effects, chunk.effects);
    this.scripts = concatScripts(this.scripts, chunk.scripts);
    this.lastEffect = chunk.lastEffect || this.lastEffect;
  }
  flushPlaceholder() {
    if (this.placeholderBody) {
      const body = this.placeholderBody.consume();
      if (body.async) {
        const { state } = this.boundary;
        const reorderId = body.reorderId = state.nextReorderId();
        this.writeHTML(state.mark("!^" /* Placeholder */, reorderId));
        const after = this.render(this.placeholderRender);
        if (after !== this) {
          this.boundary.abort(
            new Error("An @placeholder cannot contain async content.")
          );
        }
        after.writeHTML(state.mark("!" /* PlaceholderEnd */, reorderId));
        state.reorder(body);
      } else {
        body.next = this.next;
        this.next = body;
      }
      this.placeholderRender = this.placeholderBody = null;
    }
  }
  consume() {
    let cur = this;
    if (cur.next && !cur.async) {
      let html = "";
      let effects = "";
      let scripts = "";
      let lastEffect = "";
      do {
        cur.flushPlaceholder();
        html += cur.html;
        effects = concatEffects(effects, cur.effects);
        scripts = concatScripts(scripts, cur.scripts);
        lastEffect = cur.lastEffect || lastEffect;
        cur.consumed = true;
        cur = cur.next;
      } while (cur.next && !cur.async);
      cur.html = html + cur.html;
      cur.effects = concatEffects(effects, cur.effects);
      cur.scripts = concatScripts(scripts, cur.scripts);
      cur.lastEffect = lastEffect;
    }
    return cur;
  }
  render(content, val) {
    const prev = $chunk;
    $chunk = this;
    try {
      content(val);
      return $chunk;
    } catch (err) {
      this.boundary.abort(err);
      return this;
    } finally {
      $chunk = prev;
    }
  }
  flushScript() {
    flushSerializer(this.boundary);
    const { boundary, effects } = this;
    const { state } = boundary;
    const { $global: $global2, runtimePrefix, nonceAttr } = state;
    let { html, scripts } = this;
    let hasWalk = state.walkOnNextFlush;
    if (hasWalk) state.walkOnNextFlush = false;
    if (state.needsMainRuntime && !state.hasMainRuntime) {
      state.hasMainRuntime = true;
      scripts = concatScripts(
        scripts,
        WALKER_RUNTIME_CODE + '("' + $global2.runtimeId + '")("' + $global2.renderId + '")'
      );
    }
    if (effects) {
      hasWalk = true;
      state.resumes = state.resumes ? state.resumes + "," + effects : effects;
    }
    if (state.resumes) {
      if (state.hasWrittenResume) {
        scripts = concatScripts(
          scripts,
          runtimePrefix + ".r.push(" + state.resumes + ")"
        );
      } else {
        state.hasWrittenResume = true;
        scripts = concatScripts(
          scripts,
          runtimePrefix + ".r=[" + state.resumes + "]"
        );
      }
    }
    if (state.writeReorders) {
      hasWalk = true;
      if (!state.hasReorderRuntime) {
        state.hasReorderRuntime = true;
        html += "<style " + state.commentPrefix + nonceAttr + ">t{display:none}</style>";
        scripts = concatScripts(
          scripts,
          REORDER_RUNTIME_CODE + "(" + runtimePrefix + ")"
        );
      }
      for (const reorderedChunk of state.writeReorders) {
        const { reorderId } = reorderedChunk;
        let reorderHTML = "";
        let reorderEffects = "";
        let reorderScripts = "";
        let cur = reorderedChunk;
        reorderedChunk.reorderId = null;
        for (; ; ) {
          cur.flushPlaceholder();
          const { next } = cur;
          cur.consumed = true;
          reorderHTML += cur.html;
          reorderEffects = concatEffects(reorderEffects, cur.effects);
          reorderScripts = concatScripts(reorderScripts, cur.scripts);
          if (cur.async) {
            reorderHTML += state.mark(
              "#" /* ReorderMarker */,
              cur.reorderId = state.nextReorderId()
            );
            cur.html = cur.effects = cur.scripts = cur.lastEffect = "";
            cur.next = null;
          }
          if (next) {
            cur = next;
          } else {
            break;
          }
        }
        if (reorderEffects) {
          if (!state.hasWrittenResume) {
            state.hasWrittenResume = true;
            scripts = concatScripts(
              scripts,
              runtimePrefix + ".r=[]"
            );
          }
          reorderScripts = concatScripts(
            reorderScripts,
            "_.push(" + reorderEffects + ")"
          );
        }
        scripts = concatScripts(
          scripts,
          reorderScripts && runtimePrefix + ".j." + reorderId + "=_=>{" + reorderScripts + "}"
        );
        html += "<t " + state.commentPrefix + "=" + reorderId + ">" + reorderHTML + "</t>";
      }
      state.writeReorders = null;
    }
    if (hasWalk) {
      scripts = concatScripts(scripts, runtimePrefix + ".w()");
    }
    this.html = html;
    this.scripts = scripts;
    this.effects = this.lastEffect = state.resumes = "";
    return this;
  }
  flushHTML() {
    this.flushScript();
    const { boundary, scripts } = this;
    const { state } = boundary;
    const { $global: $global2, nonceAttr } = state;
    const { __flush__ } = $global2;
    let { html } = this;
    this.html = this.scripts = "";
    if (scripts) {
      html += "<script" + nonceAttr + ">" + scripts + "</script>";
    }
    if (__flush__) {
      $global2.__flush__ = void 0;
      html = __flush__($global2, html);
    }
    if (!boundary.count) {
      html += state.trailerHTML;
    }
    return html;
  }
};
function flushSerializer(boundary) {
  const { state } = boundary;
  const { writeScopes, serializer } = state;
  const { flushed } = serializer;
  if (writeScopes || flushed) {
    const serializeData = [];
    let { lastSerializedScopeId } = state;
    if (!state.hasGlobals) {
      state.hasGlobals = true;
      serializeData.push(getFilteredGlobals(state.$global));
    }
    for (const key in writeScopes) {
      const scope = writeScopes[key];
      const scopeId = getScopeId(scope);
      const scopeIdDelta = scopeId - lastSerializedScopeId;
      lastSerializedScopeId = scopeId + 1;
      if (scopeIdDelta) serializeData.push(scopeIdDelta);
      serializeData.push(scope);
    }
    state.resumes = concatEffects(
      state.resumes,
      serializer.stringify(serializeData, boundary)
    );
    state.lastSerializedScopeId = lastSerializedScopeId;
    state.writeScopes = null;
    if (flushed) {
      state.walkOnNextFlush = true;
    }
  }
}
function writeTrailers(html) {
  $chunk.boundary.state.trailerHTML += html;
}
function concatEffects(a, b) {
  return a ? b ? a + "," + b : a : b;
}
function concatScripts(a, b) {
  return a ? b ? a + ";" + b : a : b;
}
var tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));
var tickQueue;
function queueTick(cb) {
  if (tickQueue) {
    tickQueue.add(cb);
  } else {
    tickQueue = /* @__PURE__ */ new Set([cb]);
    tick(flushTickQueue);
  }
}
function offTick(cb) {
  tickQueue?.delete(cb);
}
function flushTickQueue() {
  const queue = tickQueue;
  tickQueue = void 0;
  for (const cb of queue) {
    cb(true);
  }
}
function isPromise(value) {
  return value != null && typeof value.then === "function";
}
function getFilteredGlobals($global2) {
  if (!$global2) return 0;
  const serializedGlobals = $global2.serializedGlobals;
  if (!serializedGlobals) return 0;
  let filtered = 0;
  if (Array.isArray(serializedGlobals)) {
    for (const key of serializedGlobals) {
      const value = $global2[key];
      if (value !== void 0) {
        if (filtered) {
          filtered[key] = value;
        } else {
          filtered = { [key]: value };
        }
      }
    }
  } else {
    for (const key in serializedGlobals) {
      if (serializedGlobals[key]) {
        const value = $global2[key];
        if (value !== void 0) {
          if (filtered) {
            filtered[key] = value;
          } else {
            filtered = { [key]: value };
          }
        }
      }
    }
  }
  return filtered;
}
function writeSubscribe(subscribers, scope) {
  $chunk.boundary.state.serializer.writeCall(scope, subscribers, "add");
  return scope;
}

// src/html/attrs.ts
function classAttr(value) {
  return stringAttr("class", classValue(value));
}
function styleAttr(value) {
  return stringAttr("style", styleValue(value));
}
function optionValueAttr(value) {
  const selectedValue = getContext(kSelectedValue);
  return attr("value", value) + (!isVoid(value) && (Array.isArray(selectedValue) ? selectedValue.includes(value) : selectedValue === value) ? " selected" : "");
}
var kSelectedValue = Symbol("selectedValue");
function controllable_select_value(scopeId, nodeAccessor, value, valueChange, content) {
  if (valueChange) {
    writeControlledScope(
      3 /* SelectValue */,
      scopeId,
      nodeAccessor,
      value,
      valueChange
    );
  }
  if (content) {
    withContext(kSelectedValue, value, content);
  }
}
function controllable_textarea_value(scopeId, nodeAccessor, value, valueChange) {
  if (valueChange) {
    writeControlledScope(
      2 /* InputValue */,
      scopeId,
      nodeAccessor,
      void 0,
      valueChange
    );
  }
  return escapeTextAreaValue(value);
}
function controllable_input_value(scopeId, nodeAccessor, value, valueChange) {
  if (valueChange) {
    writeControlledScope(
      2 /* InputValue */,
      scopeId,
      nodeAccessor,
      void 0,
      valueChange
    );
  }
  return attr("value", value);
}
function controllable_input_checked(scopeId, nodeAccessor, checked, checkedChange) {
  if (checkedChange) {
    writeControlledScope(
      0 /* InputChecked */,
      scopeId,
      nodeAccessor,
      void 0,
      checkedChange
    );
  }
  return attr("checked", checked);
}
function controllable_input_checkedValue(scopeId, nodeAccessor, checkedValue, checkedValueChange, value) {
  const multiple = Array.isArray(checkedValue);
  const valueAttr = attr("value", value);
  if (checkedValueChange) {
    writeControlledScope(
      1 /* InputCheckedValue */,
      scopeId,
      nodeAccessor,
      checkedValue,
      checkedValueChange
    );
  }
  return (multiple ? checkedValue.includes(value) : checkedValue === value) ? valueAttr + " checked" : valueAttr;
}
function controllable_detailsOrDialog_open(scopeId, nodeAccessor, open, openChange) {
  if (openChange) {
    writeControlledScope(
      4 /* DetailsOrDialogOpen */,
      scopeId,
      nodeAccessor,
      open,
      openChange
    );
  }
  return attr("open", open);
}
function attr(name, value) {
  return isVoid(value) ? "" : nonVoidAttr(name, value);
}
function attrs(data, nodeAccessor, scopeId, tagName) {
  let result = "";
  let skip = /[\s/>"'=]/;
  let events;
  switch (tagName) {
    case "input":
      if (data.checkedChange) {
        result += controllable_input_checked(
          scopeId,
          nodeAccessor,
          data.checked,
          data.checkedChange
        );
      } else if (data.checkedValue || data.checkedValueChange) {
        result += controllable_input_checkedValue(
          scopeId,
          nodeAccessor,
          data.checkedValue,
          data.checkedValueChange,
          data.value
        );
      } else if (data.valueChange) {
        result += controllable_input_value(
          scopeId,
          nodeAccessor,
          data.value,
          data.valueChange
        );
      } else {
        break;
      }
      skip = /^(?:value|checked(?:Value)?)(?:Change)?$|[\s/>"'=]/;
      break;
    case "select":
    case "textarea":
      if (data.value || data.valueChange) {
        skip = /^value(?:Change)?$|[\s/>"'=]/;
      }
      break;
    case "option":
      if (data.value) {
        result += optionValueAttr(data.value);
        skip = /^value$|[\s/>"'=]/;
      }
      break;
    case "details":
    case "dialog":
      if (data.openChange) {
        result += controllable_detailsOrDialog_open(
          scopeId,
          nodeAccessor,
          data.open,
          data.openChange
        );
        skip = /^open(?:Change)?$|[\s/>"'=]/;
      }
      break;
  }
  for (const name in data) {
    const value = data[name];
    switch (name) {
      case "class":
        result += classAttr(value);
        break;
      case "style":
        result += styleAttr(value);
        break;
      case "":
      case "content":
        break;
      default:
        if (!isVoid(value)) {
          if (isEventHandler(name)) {
            if (!events) {
              events = {};
              writeScope(scopeId, {
                ["EventAttributes:" /* EventAttributes */ + nodeAccessor]: events
              });
            }
            events[getEventHandlerName(name)] = value;
          } else if (!skip.test(name)) {
            result += nonVoidAttr(name, value);
          }
        }
        break;
    }
  }
  return result;
}
function writeAttrsAndContent(data, nodeAccessor, scopeId, tagName, serializeReason) {
  write(`${attrs(data, nodeAccessor, scopeId, tagName)}>`);
  writeContent(nodeAccessor, scopeId, data?.content, serializeReason);
}
function partialAttrs(data, skip, nodeAccessor, scopeId, tagName) {
  const partial = {};
  for (const key in data) {
    if (!skip[key]) partial[key] = data[key];
  }
  return attrs(partial, nodeAccessor, scopeId, tagName);
}
function writePartialAttrsAndContent(data, skip, nodeAccessor, scopeId, tagName, serializeReason) {
  write(`${partialAttrs(data, skip, nodeAccessor, scopeId, tagName)}>`);
  writeContent(nodeAccessor, scopeId, data?.content, serializeReason);
}
function writeControlledScope(type, scopeId, nodeAccessor, value, valueChange) {
  writeScope(scopeId, {
    ["ControlledType:" /* ControlledType */ + nodeAccessor]: type,
    ["ControlledValue:" /* ControlledValue */ + nodeAccessor]: value,
    ["ControlledHandler:" /* ControlledHandler */ + nodeAccessor]: valueChange
  });
}
function stringAttr(name, value) {
  return value && " " + name + attrAssignment(value);
}
function nonVoidAttr(name, value) {
  switch (typeof value) {
    case "string":
      return " " + name + attrAssignment(value);
    case "boolean":
      return " " + name;
    case "number":
      return " " + name + "=" + value;
    case "object":
      if (value instanceof RegExp) {
        return " " + name + attrAssignment(value.source);
      }
      break;
  }
  return " " + name + attrAssignment(value + "");
}
var singleQuoteAttrReplacements = /'|&(?=#?\w+;)/g;
var doubleQuoteAttrReplacements = /"|&(?=#?\w+;)/g;
var needsQuotedAttr = /["'>\s]|&#?\w+;|\/$/g;
function attrAssignment(value) {
  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '"') ? "='" + escapeSingleQuotedAttrValue(value) + "'" : '="' + escapeDoubleQuotedAttrValue(value) + '"' : "=" + value : "";
}
function escapeSingleQuotedAttrValue(value) {
  return singleQuoteAttrReplacements.test(value) ? value.replace(
    singleQuoteAttrReplacements,
    replaceUnsafeSingleQuoteAttrChar
  ) : value;
}
function replaceUnsafeSingleQuoteAttrChar(match) {
  return match === "'" ? "&#39;" : "&amp;";
}
function escapeDoubleQuotedAttrValue(value) {
  return doubleQuoteAttrReplacements.test(value) ? value.replace(
    doubleQuoteAttrReplacements,
    replaceUnsafeDoubleQuoteAttrChar
  ) : value;
}
function replaceUnsafeDoubleQuoteAttrChar(match) {
  return match === '"' ? "&#34;" : "&amp;";
}

// src/common/compat-meta.ts
var prefix = true ? "$compat_" : "$C_";
var RENDERER_REGISTER_ID = prefix + (true ? "renderer" : "r");
var SET_SCOPE_REGISTER_ID = prefix + (true ? "setScope" : "s");
var RENDER_BODY_ID = prefix + (true ? "renderBody" : "b");

// src/common/meta.ts
var DEFAULT_RUNTIME_ID = "M";
var DEFAULT_RENDER_ID = "_";

// src/html/template.ts
var createTemplate = (templateId, renderer) => {
  renderer.render = render;
  renderer._ = renderer;
  if (true) {
    renderer.mount = () => {
      throw new Error(
        `mount() is not implemented for the HTML compilation of a Marko template`
      );
    };
  }
  return registerContent(templateId, renderer);
};
function isTemplate(renderer) {
  return !!renderer._;
}
function render(input = {}) {
  let { $global: $global2 } = input;
  if ($global2) {
    ({ $global: $global2, ...input } = input);
    $global2 = {
      runtimeId: DEFAULT_RUNTIME_ID,
      renderId: DEFAULT_RENDER_ID,
      ...$global2
    };
  } else {
    $global2 = { runtimeId: DEFAULT_RUNTIME_ID, renderId: DEFAULT_RENDER_ID };
  }
  const head = new Chunk(
    new Boundary(new State2($global2), $global2.signal),
    null,
    null
  );
  head.render(this, input);
  return new ServerRendered(head);
}
var ServerRendered = class {
  #head;
  #cachedPromise = null;
  constructor(head) {
    this.#head = head;
  }
  [Symbol.asyncIterator]() {
    let resolve;
    let reject;
    let value = "";
    let done = false;
    let aborted = false;
    let reason;
    const boundary = this.#read(
      (html) => {
        value += html;
        if (resolve) {
          resolve({ value, done });
          value = "";
        }
      },
      (err) => {
        aborted = true;
        reason = err;
        if (reject) {
          reject(err);
        }
      },
      () => {
        done = true;
        if (resolve) {
          resolve({ value, done: !value });
          value = "";
        }
      }
    );
    return {
      next() {
        if (aborted) {
          return Promise.reject(reason);
        } else if (value) {
          const result = { value, done: false };
          value = "";
          return Promise.resolve(result);
        } else if (done) {
          return Promise.resolve({ value: "", done });
        } else {
          return new Promise(exec);
        }
      },
      throw(error) {
        if (!(done || aborted)) {
          boundary?.abort(error);
        }
        return Promise.resolve({ value: "", done: true });
      },
      return(value2) {
        if (!(done || aborted)) {
          boundary?.abort(new Error("Iterator returned before consumed."));
        }
        return Promise.resolve({ value: value2, done: true });
      }
    };
    function exec(_resolve, _reject) {
      resolve = _resolve;
      reject = _reject;
    }
  }
  pipe(stream) {
    this.#read(
      (html) => {
        stream.write(html);
      },
      (err) => {
        const socket = "socket" in stream && stream.socket;
        if (socket && typeof socket.destroySoon === "function") {
          socket.destroySoon();
        }
        if (!stream.emit?.("error", err)) {
          throw err;
        }
      },
      () => {
        stream.end();
      }
    );
  }
  toReadable() {
    let cancelled = false;
    let boundary;
    const encoder = new TextEncoder();
    return new ReadableStream({
      start: (ctrl) => {
        boundary = this.#read(
          (html) => {
            ctrl.enqueue(encoder.encode(html));
          },
          (err) => {
            boundary = void 0;
            if (!cancelled) {
              ctrl.error(err);
            }
          },
          () => {
            boundary = void 0;
            ctrl.close();
          }
        );
      },
      cancel: (reason) => {
        cancelled = true;
        boundary?.abort(reason);
      }
    });
  }
  then(onfulfilled, onrejected) {
    return this.#promise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.#promise().catch(onrejected);
  }
  finally(onfinally) {
    return this.#promise().finally(onfinally);
  }
  #promise() {
    return this.#cachedPromise ||= new Promise((resolve, reject) => {
      const head = this.#head;
      this.#head = null;
      if (!head) {
        return reject(new Error("Cannot read from a consumed render result"));
      }
      const { boundary } = head;
      (boundary.onNext = () => {
        if (boundary.signal.aborted) {
          boundary.onNext = NOOP2;
          reject(boundary.signal.reason);
        } else if (boundary.done) {
          resolve(head.consume().flushHTML());
        }
      })();
    });
  }
  #read(onWrite, onAbort, onClose) {
    let tick2 = true;
    let head = this.#head;
    this.#head = null;
    if (!head) {
      onAbort(new Error("Cannot read from a consumed render result"));
      return;
    }
    const { boundary } = head;
    const onNext = boundary.onNext = (write2) => {
      if (boundary.signal.aborted) {
        if (!tick2) offTick(onNext);
        boundary.onNext = NOOP2;
        onAbort(boundary.signal.reason);
      } else {
        const { done } = boundary;
        if (done || write2) {
          const html = (head = head.consume()).flushHTML();
          if (html) onWrite(html);
          if (done) {
            if (!tick2) offTick(onNext);
            onClose();
          } else {
            tick2 = true;
          }
        } else if (tick2) {
          tick2 = false;
          queueTick(onNext);
        }
      }
    };
    onNext();
    return boundary;
  }
  toString() {
    const head = this.#head;
    this.#head = null;
    if (!head) throw new Error("Cannot read from a consumed render result");
    const { boundary } = head;
    if (!boundary.done) {
      throw new Error("Cannot consume asynchronous render with 'toString'");
    }
    if (boundary.signal.aborted) throw boundary.signal.reason;
    return head.consume().flushHTML();
  }
};
function NOOP2() {
}

// src/html/dynamic-tag.ts
var voidElementsReg = /^(?:area|b(?:ase|r)|col|embed|hr|i(?:mg|nput)|link|meta|param|source|track|wbr)$/;
var dynamicTag = (scopeId, accessor, tag, inputOrArgs, content, inputIsArgs, serializeReason) => {
  const shouldResume = serializeReason !== 0;
  const renderer = normalizeDynamicRenderer(tag);
  if (true) {
    if (renderer && typeof renderer !== "function" && typeof renderer !== "string") {
      throw new Error(`Invalid renderer passed for dynamic tag: ${renderer}`);
    }
  }
  const state = getState();
  const branchId = peekNextScopeId();
  let result;
  if (typeof renderer === "string") {
    const input = (inputIsArgs ? inputOrArgs[0] : inputOrArgs) || {};
    const renderContent = content || normalizeDynamicRenderer(input.content);
    nextScopeId();
    write(`<${renderer}${attrs(input, accessor, scopeId, renderer)}>`);
    if (!voidElementsReg.test(renderer)) {
      const renderNativeTag = () => {
        if (renderer === "textarea") {
          if (content) {
            throw new Error(
              "A dynamic tag rendering a `<textarea>` cannot have `content` and must use the `value` attribute instead."
            );
          }
          write(
            controllable_textarea_value(
              scopeId,
              accessor,
              input.value,
              input.valueChange
            )
          );
        } else if (renderContent) {
          if (typeof renderContent !== "function") {
            throw new Error(
              `Body content is not supported for the \`<${renderer}>\` tag.`
            );
          }
          if (renderer === "select" && ("value" in input || "valueChange" in input)) {
            controllable_select_value(
              scopeId,
              accessor,
              input.value,
              input.valueChange,
              renderContent
            );
          } else {
            renderContent();
          }
        }
      };
      if (shouldResume) {
        withBranchId(branchId, renderNativeTag);
      } else {
        renderNativeTag();
      }
      write(`</${renderer}>`);
    } else if (content) {
      throw new Error(
        `Body content is not supported for the \`<${renderer}>\` tag.`
      );
    }
    if (shouldResume) {
      write(
        state.mark(
          "|" /* BranchSingleNode */,
          scopeId + " " + accessor + " " + branchId
        )
      );
    }
  } else {
    if (shouldResume) {
      write(state.mark("[" /* BranchStart */, branchId + ""));
    }
    const render2 = () => {
      if (renderer) {
        if (isTemplate(renderer)) {
          const input = inputIsArgs ? inputOrArgs[0] : inputOrArgs;
          return renderer(
            content ? { ...input, content } : input,
            shouldResume ? 1 : 0
          );
        }
        return inputIsArgs ? renderer(...inputOrArgs) : renderer(
          content ? { ...inputOrArgs, content } : inputOrArgs
        );
      } else if (content) {
        return content();
      }
    };
    result = shouldResume ? withBranchId(branchId, render2) : render2();
    if (shouldResume) {
      write(state.mark("]" /* BranchEnd */, scopeId + " " + accessor));
    }
  }
  const rendered = peekNextScopeId() !== branchId;
  if (rendered) {
    if (shouldResume) {
      writeScope(scopeId, {
        ["ConditionalScope:" /* ConditionalScope */ + accessor]: writeScope(branchId, {}),
        ["ConditionalRenderer:" /* ConditionalRenderer */ + accessor]: renderer?.___id || renderer
      });
    }
  } else {
    nextScopeId();
  }
  return result;
};
function createContent(id, fn) {
  fn.___id = id;
  return fn;
}
function registerContent(id, fn, scopeId) {
  return register2(createContent(id, fn), id, scopeId);
}
function patchDynamicTag(patch) {
  dynamicTag = /* @__PURE__ */ ((originalDynamicTag) => (scopeId, accessor, tag, input, content, inputIsArgs, resume) => {
    const patched = patch(scopeId, accessor, tag);
    patched.___id = tag;
    return originalDynamicTag(
      scopeId,
      accessor,
      patched,
      input,
      content,
      inputIsArgs,
      resume
    );
  })(dynamicTag);
}

// src/html/compat.ts
var K_TAGS_API_STATE = Symbol();
var COMPAT_REGISTRY = /* @__PURE__ */ new WeakMap();
var compat = {
  fork,
  write,
  writeScript,
  nextScopeId,
  isTagsAPI(fn) {
    return !!fn.___id;
  },
  patchDynamicTag,
  writeSetScopeForComponent(m5c) {
    const scopeId = nextScopeId();
    writeScope(scopeId, { m5c });
    writeEffect(scopeId, SET_SCOPE_REGISTER_ID);
  },
  toJSON() {
    let compatRegistered = COMPAT_REGISTRY.get(this);
    if (!compatRegistered) {
      const registered = getRegistered(this);
      if (registered) {
        const scopeId = getScopeId(registered.scope);
        if (scopeId !== void 0) {
          writeScope(scopeId, {});
        }
        COMPAT_REGISTRY.set(
          this,
          compatRegistered = [registered.id, scopeId]
        );
      }
    }
    return compatRegistered;
  },
  render(renderer, willRerender, classAPIOut, component, input) {
    const $global2 = classAPIOut.global;
    let state = $global2[K_TAGS_API_STATE] ||= getChunk()?.boundary.state;
    if (!state) {
      $global2.runtimeId ||= DEFAULT_RUNTIME_ID;
      $global2.renderId ||= $global2.componentIdPrefix || DEFAULT_RENDER_ID;
      $global2[K_TAGS_API_STATE] = state = new State2($global2);
    }
    const boundary = new Boundary(state);
    const head = new Chunk(
      boundary,
      null,
      null
    );
    let normalizedInput = input;
    if ("renderBody" in input) {
      normalizedInput = {};
      for (const key in input) {
        normalizedInput[key === "renderBody" ? "content" : key] = input[key];
      }
    }
    head.render(() => {
      if (willRerender) {
        const scopeId = peekNextScopeId();
        writeScope(scopeId, { m5c: component.id });
        writeEffect(scopeId, SET_SCOPE_REGISTER_ID);
      }
      if (isTemplate(renderer) && willRerender) {
        renderer(normalizedInput, 1);
      } else {
        renderer(normalizedInput);
      }
    });
    const asyncOut = classAPIOut.beginAsync();
    queueMicrotask(
      boundary.onNext = () => {
        if (boundary.signal.aborted) {
          asyncOut.error(boundary.signal.reason);
        } else if (boundary.done) {
          const { scripts, html } = head.consume().flushScript();
          asyncOut.script(scripts);
          asyncOut.write(html);
          asyncOut.end();
        }
      }
    );
  },
  registerRenderer(renderer, id) {
    return register(
      RENDERER_REGISTER_ID,
      renderer,
      register(id, () => {
      })
    );
  },
  registerRenderBody(fn) {
    register(RENDER_BODY_ID, fn);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  $global,
  attr,
  attrTag,
  attrTags,
  attrs,
  classAttr,
  commentSeparator,
  compat,
  controllable_detailsOrDialog_open,
  controllable_input_checked,
  controllable_input_checkedValue,
  controllable_input_value,
  controllable_select_value,
  controllable_textarea_value,
  createContent,
  createTemplate,
  dynamicTag,
  ensureScopeWithId,
  escapeScript,
  escapeStyle,
  escapeXML,
  forIn,
  forInBy,
  forOf,
  forOfBy,
  forTo,
  forToBy,
  fork,
  getScopeById,
  hoist,
  markResumeNode,
  nextScopeId,
  nextTagId,
  nodeRef,
  optionValueAttr,
  partialAttrs,
  peekNextScopeId,
  register,
  registerContent,
  resumeClosestBranch,
  resumeConditional,
  resumeForIn,
  resumeForOf,
  resumeForTo,
  serializeGuard,
  serializeIf,
  setTagVar,
  styleAttr,
  toString,
  tryContent,
  write,
  writeAttrsAndContent,
  writeContent,
  writeEffect,
  writeExistingScope,
  writePartialAttrsAndContent,
  writeScope,
  writeSubscribe,
  writeTrailers
});
