"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/html.ts
var html_exports = {};
__export(html_exports, {
  $global: () => $global,
  attr: () => attr,
  attrTag: () => attrTag,
  attrTags: () => attrTags,
  attrs: () => attrs,
  classAttr: () => classAttr,
  commentSeparator: () => commentSeparator,
  compat: () => compat,
  controllable_detailsOrDialog_open: () => controllable_detailsOrDialog_open,
  controllable_input_checked: () => controllable_input_checked,
  controllable_input_checkedValue: () => controllable_input_checkedValue,
  controllable_input_value: () => controllable_input_value,
  controllable_select_value: () => controllable_select_value,
  controllable_textarea_value: () => controllable_textarea_value,
  createContent: () => createContent,
  createTemplate: () => createTemplate,
  dynamicTag: () => dynamicTag,
  ensureScopeWithId: () => ensureScopeWithId,
  escapeScript: () => escapeScript,
  escapeStyle: () => escapeStyle,
  escapeXML: () => escapeXML,
  forIn: () => forIn,
  forInBy: () => forInBy,
  forOf: () => forOf,
  forOfBy: () => forOfBy,
  forTo: () => forTo,
  forToBy: () => forToBy,
  fork: () => fork,
  getScopeById: () => getScopeById,
  hoist: () => hoist,
  markResumeNode: () => markResumeNode,
  nextScopeId: () => nextScopeId,
  nextTagId: () => nextTagId,
  nodeRef: () => nodeRef,
  optionValueAttr: () => optionValueAttr,
  partialAttrs: () => partialAttrs,
  peekNextScopeId: () => peekNextScopeId,
  register: () => register2,
  registerContent: () => registerContent,
  resumeClosestBranch: () => resumeClosestBranch,
  resumeConditional: () => resumeConditional,
  resumeForIn: () => resumeForIn,
  resumeForOf: () => resumeForOf,
  resumeForTo: () => resumeForTo,
  serializeGuard: () => serializeGuard,
  serializeIf: () => serializeIf,
  setTagVar: () => setTagVar,
  styleAttr: () => styleAttr,
  toString: () => toString,
  tryContent: () => tryContent,
  write: () => write,
  writeAttrsAndContent: () => writeAttrsAndContent,
  writeContent: () => writeContent,
  writeEffect: () => writeEffect,
  writeExistingScope: () => writeExistingScope,
  writePartialAttrsAndContent: () => writePartialAttrsAndContent,
  writeScope: () => writeScope,
  writeSubscribe: () => writeSubscribe,
  writeTrailers: () => writeTrailers
});
module.exports = __toCommonJS(html_exports);

// src/common/attr-tag.ts
var empty = [], rest = Symbol();
function attrTag(attrs2) {
  return attrs2[Symbol.iterator] = attrTagIterator, attrs2[rest] = empty, attrs2;
}
function attrTags(first, attrs2) {
  return first ? (first[rest] === empty ? first[rest] = [attrs2] : first[rest].push(attrs2), first) : attrTag(attrs2);
}
function* attrTagIterator() {
  yield this, yield* this[rest];
}

// src/common/helpers.ts
function classValue(classValue2) {
  return toDelimitedString(classValue2, " ", stringifyClassObject);
}
function stringifyClassObject(name, value) {
  return value ? name : "";
}
function styleValue(styleValue2) {
  return toDelimitedString(styleValue2, ";", stringifyStyleObject);
}
function stringifyStyleObject(name, value) {
  return value || value === 0 ? name + ":" + value : "";
}
function toDelimitedString(val, delimiter, stringify) {
  let str = "", sep = "", part;
  if (val)
    if (typeof val != "object")
      str += val;
    else if (Array.isArray(val))
      for (let v of val)
        part = toDelimitedString(v, delimiter, stringify), part && (str += sep + part, sep = delimiter);
    else
      for (let name in val)
        part = stringify(name, val[name]), part && (str += sep + part, sep = delimiter);
  return str;
}
function isEventHandler(name) {
  return /^on[A-Z-]/.test(name);
}
function getEventHandlerName(name) {
  return name[2] === "-" ? name.slice(3) : name.slice(2).toLowerCase();
}
function isVoid(value) {
  return value == null || value === !1;
}
function normalizeDynamicRenderer(value) {
  return value ? value.content || value.default || value : void 0;
}

// src/html/content.ts
function toString(val) {
  return val ? val + "" : val === 0 ? "0" : "";
}
var unsafeXMLReg = /[<&]/g, replaceUnsafeXML = (c) => c === "&" ? "&amp;" : "&lt;", escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;
function escapeXML(val) {
  return val ? escapeXMLStr(val + "") : val === 0 ? "0" : "&zwj;";
}
function escapeTextAreaValue(val) {
  return val ? escapeXMLStr(val + "") : val === 0 ? "0" : "";
}
var unsafeScriptReg = /<\/script/g, escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, "\\x3C/script") : str;
function escapeScript(val) {
  return val ? escapeScriptStr(val + "") : val === 0 ? "0" : "";
}
var unsafeStyleReg = /<\/style/g, escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, "\\3C/style") : str;
function escapeStyle(val) {
  return val ? escapeStyleStr(val + "") : val === 0 ? "0" : "";
}

// src/common/for.ts
function forIn(obj, cb) {
  for (let key in obj)
    cb(key, obj[key]);
}
function forOf(list, cb) {
  if (list) {
    let i = 0;
    for (let item of list)
      cb(item, i++);
  }
}
function forTo(to, from, step, cb) {
  let start = from || 0, delta = step || 1;
  for (let steps = (to - start) / delta, i = 0; i <= steps; i++)
    cb(start + i * delta);
}

// src/html/for.ts
function forOfBy(by, item, index) {
  return by ? typeof by == "string" ? item[by] : by(item, index) : index;
}
function forInBy(by, name, value) {
  return by ? by(name, value) : name;
}
function forToBy(by, index) {
  return by ? by(index) : index;
}

// src/html/inlined-runtimes.ts
var WALKER_RUNTIME_CODE = '(e=>(self[e]=(l,d=e+l,f=d.length,o={},n=[],s=document,t=s.createTreeWalker(s,129))=>s=self[e][l]={i:d,d:s,l:o,v:n,x(){},w(e,l,x){for(;e=t.nextNode();)s.x(l=(l=e.data)&&!l.indexOf(d)&&(o[x=l.slice(f+1)]=e,l[f]),x,e),l>"#"&&n.push(e)}},self[e]))', REORDER_RUNTIME_CODE = '(e=>{let i,l,t,r={},c=(e,i)=>{e.replaceWith(...i.childNodes),i.remove()};e.d.head.append(e.d.querySelector("style["+e.i+"]")||""),e.j={},e.x=(d,o,n,a,g)=>{"#"==d?(r[o]=l).i++:n==t&&i(),"T"==n.tagName&&(o=n.getAttribute(e.i))&&((a=e.l["^"+o])&&(r[o]={i:1,c(i=e.l[o]||n){for(;(t=i.previousSibling||a).remove(),a!=t;);c(i,n)}}),t=n.nextSibling,l=r[o],i=()=>{a||c(e.l[o],n),--l.i||l.c()},(d=e.j[o])&&(g=l.c,l.c=()=>g()+d(e.r)))}})';

// src/html/serializer.ts
var kTouchedIterator = Symbol(), { hasOwnProperty } = {}, Generator = function* () {
}().constructor, AsyncGenerator = async function* () {
}().constructor;
patchIteratorNext(Generator.prototype);
patchIteratorNext(AsyncGenerator.prototype);
var REGISTRY = /* @__PURE__ */ new WeakMap(), KNOWN_SYMBOLS = (() => {
  let KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();
  for (let name of Object.getOwnPropertyNames(Symbol)) {
    let symbol = Symbol[name];
    typeof symbol == "symbol" && KNOWN_SYMBOLS2.set(symbol, "Symbol." + name);
  }
  return KNOWN_SYMBOLS2;
})(), KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([
  // This is by no means an exhaustive list,
  // but it should cover most of the built-in functions.
  [AggregateError, "AggregateError"],
  [Array, "Array"],
  [Array.from, "Array.from"],
  [Array.isArray, "Array.isArray"],
  [Array.of, "Array.of"],
  [ArrayBuffer, "ArrayBuffer"],
  [ArrayBuffer.isView, "ArrayBuffer.isView"],
  [Atomics.add, "Atomics.add"],
  [Atomics.and, "Atomics.and"],
  [Atomics.compareExchange, "Atomics.compareExchange"],
  [Atomics.exchange, "Atomics.exchange"],
  [Atomics.isLockFree, "Atomics.isLockFree"],
  [Atomics.load, "Atomics.load"],
  [Atomics.notify, "Atomics.notify"],
  [Atomics.or, "Atomics.or"],
  [Atomics.store, "Atomics.store"],
  [Atomics.sub, "Atomics.sub"],
  [Atomics.wait, "Atomics.wait"],
  [BigInt, "BigInt"],
  [BigInt.asIntN, "BigInt.asIntN"],
  [BigInt.asUintN, "BigInt.asUintN"],
  [BigInt64Array, "BigInt64Array"],
  [BigInt64Array.from, "BigInt64Array.from"],
  [BigInt64Array.of, "BigInt64Array.of"],
  [BigUint64Array, "BigUint64Array"],
  [BigUint64Array.from, "BigUint64Array.from"],
  [BigUint64Array.of, "BigUint64Array.of"],
  [Boolean, "Boolean"],
  [console.assert, "console.assert"],
  [console.clear, "console.clear"],
  [console.count, "console.count"],
  [console.countReset, "console.countReset"],
  [console.debug, "console.debug"],
  [console.dir, "console.dir"],
  [console.dirxml, "console.dirxml"],
  [console.error, "console.error"],
  [console.group, "console.group"],
  [console.groupCollapsed, "console.groupCollapsed"],
  [console.groupEnd, "console.groupEnd"],
  [console.info, "console.info"],
  [console.log, "console.log"],
  [console.table, "console.table"],
  [console.time, "console.time"],
  [console.timeEnd, "console.timeEnd"],
  [console.timeLog, "console.timeLog"],
  [console.timeStamp, "console.timeStamp"],
  [console.trace, "console.trace"],
  [console.warn, "console.warn"],
  [DataView, "DataView"],
  [Date, "Date"],
  [Date.now, "Date.now"],
  [Date.parse, "Date.parse"],
  [Date.UTC, "Date.UTC"],
  [decodeURI, "decodeURI"],
  [decodeURIComponent, "decodeURIComponent"],
  [encodeURI, "encodeURI"],
  [encodeURIComponent, "encodeURIComponent"],
  [Error, "Error"],
  [EvalError, "EvalError"],
  [Float32Array, "Float32Array"],
  [Float32Array.from, "Float32Array.from"],
  [Float32Array.of, "Float32Array.of"],
  [Float64Array, "Float64Array"],
  [Float64Array.from, "Float64Array.from"],
  [Float64Array.of, "Float64Array.of"],
  [Function, "Function"],
  [globalThis.atob, "atob"],
  [globalThis.btoa, "btoa"],
  [globalThis.clearImmediate, "clearImmediate"],
  [globalThis.clearInterval, "clearInterval"],
  [globalThis.clearTimeout, "clearTimeout"],
  [globalThis.crypto?.getRandomValues, "crypto.getRandomValues"],
  [globalThis.crypto?.randomUUID, "crypto.randomUUID"],
  [globalThis.fetch, "fetch"],
  [globalThis.performance?.now, "performance.now"],
  [globalThis.queueMicrotask, "queueMicrotask"],
  [globalThis.setImmediate, "setImmediate"],
  [globalThis.setInterval, "setInterval"],
  [globalThis.setTimeout, "setTimeout"],
  [globalThis.structuredClone, "structuredClone"],
  [globalThis.URL, "URL"],
  [globalThis.URLSearchParams, "URLSearchParams"],
  [globalThis.WritableStream, "WritableStream"],
  [Int16Array, "Int16Array"],
  [Int16Array.from, "Int16Array.from"],
  [Int16Array.of, "Int16Array.of"],
  [Int32Array, "Int32Array"],
  [Int32Array.from, "Int32Array.from"],
  [Int32Array.of, "Int32Array.of"],
  [Int8Array, "Int8Array"],
  [Int8Array.from, "Int8Array.from"],
  [Int8Array.of, "Int8Array.of"],
  [Intl.Collator, "Intl.Collator"],
  [Intl.DateTimeFormat, "Intl.DateTimeFormat"],
  [Intl.DisplayNames, "Intl.DisplayNames"],
  [Intl.getCanonicalLocales, "Intl.getCanonicalLocales"],
  [Intl.ListFormat, "Intl.ListFormat"],
  [Intl.Locale, "Intl.Locale"],
  [Intl.NumberFormat, "Intl.NumberFormat"],
  [Intl.PluralRules, "Intl.PluralRules"],
  [Intl.RelativeTimeFormat, "Intl.RelativeTimeFormat"],
  [Intl.Segmenter, "Intl.Segmenter"],
  [Intl.supportedValuesOf, "Intl.supportedValuesOf"],
  [isFinite, "isFinite"],
  [isNaN, "isNaN"],
  [JSON.parse, "JSON.parse"],
  [JSON.stringify, "JSON.stringify"],
  [Map, "Map"],
  [Map.groupBy, "Map.groupBy"],
  [Math.abs, "Math.abs"],
  [Math.acos, "Math.acos"],
  [Math.acosh, "Math.acosh"],
  [Math.asin, "Math.asin"],
  [Math.asinh, "Math.asinh"],
  [Math.atan, "Math.atan"],
  [Math.atan2, "Math.atan2"],
  [Math.atanh, "Math.atanh"],
  [Math.cbrt, "Math.cbrt"],
  [Math.ceil, "Math.ceil"],
  [Math.clz32, "Math.clz32"],
  [Math.cos, "Math.cos"],
  [Math.cosh, "Math.cosh"],
  [Math.exp, "Math.exp"],
  [Math.expm1, "Math.expm1"],
  [Math.floor, "Math.floor"],
  [Math.fround, "Math.fround"],
  [Math.hypot, "Math.hypot"],
  [Math.imul, "Math.imul"],
  [Math.log, "Math.log"],
  [Math.log10, "Math.log10"],
  [Math.log1p, "Math.log1p"],
  [Math.log2, "Math.log2"],
  [Math.max, "Math.max"],
  [Math.min, "Math.min"],
  [Math.pow, "Math.pow"],
  [Math.random, "Math.random"],
  [Math.round, "Math.round"],
  [Math.sign, "Math.sign"],
  [Math.sin, "Math.sin"],
  [Math.sinh, "Math.sinh"],
  [Math.sqrt, "Math.sqrt"],
  [Math.tan, "Math.tan"],
  [Math.tanh, "Math.tanh"],
  [Math.trunc, "Math.trunc"],
  [Number, "Number"],
  [Number.isFinite, "Number.isFinite"],
  [Number.isInteger, "Number.isInteger"],
  [Number.isNaN, "Number.isNaN"],
  [Number.isSafeInteger, "Number.isSafeInteger"],
  [Number.parseFloat, "Number.parseFloat"],
  [Number.parseInt, "Number.parseInt"],
  [Object, "Object"],
  [Object.assign, "Object.assign"],
  [Object.create, "Object.create"],
  [Object.defineProperties, "Object.defineProperties"],
  [Object.defineProperty, "Object.defineProperty"],
  [Object.entries, "Object.entries"],
  [Object.freeze, "Object.freeze"],
  [Object.fromEntries, "Object.fromEntries"],
  [Object.getOwnPropertyDescriptor, "Object.getOwnPropertyDescriptor"],
  [Object.getOwnPropertyDescriptors, "Object.getOwnPropertyDescriptors"],
  [Object.getOwnPropertyNames, "Object.getOwnPropertyNames"],
  [Object.getOwnPropertySymbols, "Object.getOwnPropertySymbols"],
  [Object.getPrototypeOf, "Object.getPrototypeOf"],
  [Object.is, "Object.is"],
  [Object.isExtensible, "Object.isExtensible"],
  [Object.isFrozen, "Object.isFrozen"],
  [Object.isSealed, "Object.isSealed"],
  [Object.keys, "Object.keys"],
  [Object.preventExtensions, "Object.preventExtensions"],
  [Object.seal, "Object.seal"],
  [Object.setPrototypeOf, "Object.setPrototypeOf"],
  [Object.values, "Object.values"],
  [parseFloat, "parseFloat"],
  [parseInt, "parseInt"],
  [Promise, "Promise"],
  [Proxy, "Proxy"],
  [RangeError, "RangeError"],
  [ReferenceError, "ReferenceError"],
  [Reflect.apply, "Reflect.apply"],
  [Reflect.construct, "Reflect.construct"],
  [Reflect.defineProperty, "Reflect.defineProperty"],
  [Reflect.deleteProperty, "Reflect.deleteProperty"],
  [Reflect.get, "Reflect.get"],
  [Reflect.getOwnPropertyDescriptor, "Reflect.getOwnPropertyDescriptor"],
  [Reflect.getPrototypeOf, "Reflect.getPrototypeOf"],
  [Reflect.has, "Reflect.has"],
  [Reflect.isExtensible, "Reflect.isExtensible"],
  [Reflect.ownKeys, "Reflect.ownKeys"],
  [Reflect.preventExtensions, "Reflect.preventExtensions"],
  [Reflect.set, "Reflect.set"],
  [Reflect.setPrototypeOf, "Reflect.setPrototypeOf"],
  [RegExp, "RegExp"],
  [Set, "Set"],
  [String, "String"],
  [String.fromCharCode, "String.fromCharCode"],
  [String.fromCodePoint, "String.fromCodePoint"],
  [String.raw, "String.raw"],
  [Symbol, "Symbol"],
  [Symbol.for, "Symbol.for"],
  [SyntaxError, "SyntaxError"],
  [TypeError, "TypeError"],
  [Uint16Array, "Uint16Array"],
  [Uint16Array.from, "Uint16Array.from"],
  [Uint16Array.of, "Uint16Array.of"],
  [Uint32Array, "Uint32Array"],
  [Uint32Array.from, "Uint32Array.from"],
  [Uint32Array.of, "Uint32Array.of"],
  [Uint8Array, "Uint8Array"],
  [Uint8Array.from, "Uint8Array.from"],
  [Uint8Array.of, "Uint8Array.of"],
  [Uint8ClampedArray, "Uint8ClampedArray"],
  [Uint8ClampedArray.from, "Uint8ClampedArray.from"],
  [Uint8ClampedArray.of, "Uint8ClampedArray.of"],
  [URIError, "URIError"],
  [WeakMap, "WeakMap"],
  [WeakSet, "WeakSet"]
]), KNOWN_OBJECTS = /* @__PURE__ */ new Map([
  [Atomics, "Atomics"],
  [console, "console"],
  [globalThis, "globalThis"],
  [globalThis.crypto, "crypto"],
  [Intl, "Intl"],
  [JSON, "JSON"],
  [Math, "Math"],
  [Reflect, "Reflect"]
]), State = class {
  ids = 0;
  flush = 0;
  flushed = !1;
  wroteUndefined = !1;
  buf = [];
  refs = /* @__PURE__ */ new WeakMap();
  assigned = /* @__PURE__ */ new Set();
  boundary = void 0;
  mutations = [];
}, Reference = class {
  constructor(parent, accessor, flush, pos = null, id = null) {
    this.parent = parent;
    this.accessor = accessor;
    this.flush = flush;
    this.pos = pos;
    this.id = id;
    this.parent = parent, this.accessor = accessor, this.flush = flush, this.pos = pos, this.id = id;
  }
  init = "";
  assigns = null;
};
var Serializer = class {
  #state = new State();
  get flushed() {
    return this.#state.flushed;
  }
  stringify(val, boundary) {
    try {
      return this.#state.flushed = !1, this.#state.boundary = boundary, writeRoot(this.#state, val);
    } finally {
      this.#state.flush++, this.#state.buf = [];
    }
  }
  nextId() {
    return nextId(this.#state);
  }
  symbol(id) {
    let symbol = Symbol();
    return this.#state.refs.set(symbol, new Reference(null, null, 0, null, id)), symbol;
  }
  writeCall(value, object, property, spread) {
    let state = this.#state;
    state.mutations.push({
      type: 0 /* call */,
      value,
      object,
      property,
      spread
    }), state.flushed = !0;
  }
  writeAssign(value, object, property) {
    let state = this.#state;
    state.mutations.push({
      type: 1 /* assign */,
      value,
      object,
      property
    }), state.flushed = !0;
  }
};
function register(id, val, scope) {
  return REGISTRY.set(val, {
    id,
    scope,
    access: "_._" + toAccess(toObjectKey(id)),
    getter: !1
  }), val;
}
function getRegistered(val) {
  let registered = REGISTRY.get(val);
  if (registered)
    return { id: registered.id, scope: registered.scope };
}
function writeRoot(state, root) {
  let { buf, assigned, mutations } = state, hadBuf = buf.length !== 0, result = "";
  if (hadBuf && buf.push(","), writeProp(state, root, null, "")) {
    let rootRef = state.refs.get(root);
    if (rootRef) {
      let rootId = ensureId(state, rootRef);
      (assigned.size || mutations.length) && (assigned.delete(rootRef), writeAssigned(state), buf.push(
        "," + (rootRef.assigns ? assignsToString(rootRef.assigns, rootId) : rootId)
      ));
    }
    result = "(", buf.push(")");
  } else
    hadBuf && (buf.pop(), writeAssigned(state)), result = "{", buf.push("}");
  for (let chunk of buf)
    result += chunk;
  return state.wroteUndefined ? (state.wroteUndefined = !1, "(_,$)=>" + result) : "_=>" + result;
}
function writeAssigned(state) {
  if (state.assigned.size) {
    for (let valueRef of state.assigned)
      valueRef.init ? (valueRef.assigns ? state.buf.push(
        "," + assignsToString(valueRef.assigns, valueRef.init)
      ) : state.buf.push("," + valueRef.init), valueRef.init = "") : valueRef.assigns && state.buf.push("," + assignsToString(valueRef.assigns, valueRef.id));
    state.assigned = /* @__PURE__ */ new Set();
  }
  if (state.mutations.length) {
    for (let mutation of state.mutations) {
      let objectStartIndex = state.buf.push(
        state.buf.length === 0 ? "(" : ",("
      );
      if (writeProp(state, mutation.object, null, "")) {
        let objectRef = state.refs.get(mutation.object);
        objectRef && !objectRef.id && (objectRef.id = nextRefAccess(state), state.buf[objectStartIndex] = objectRef.id + "=" + state.buf[objectStartIndex]);
      } else
        state.buf.push("void 0");
      let valueStartIndex = state.buf.push(
        mutation.type === 0 /* call */ ? ")" + (mutation.property === void 0 ? "" : toAccess(toObjectKey(mutation.property))) + "(" + (mutation.spread ? "..." : "") : toAccess(toObjectKey(mutation.property)) + "="
      );
      if (writeProp(state, mutation.value, null, "")) {
        let valueRef = state.refs.get(mutation.value);
        valueRef && !valueRef.id && (valueRef.id = nextRefAccess(state), state.buf[valueStartIndex] = valueRef.id + "=" + state.buf[valueStartIndex]);
      } else
        state.buf.push("void 0");
      state.buf.push(")");
    }
    state.mutations = [], state.assigned.size && writeAssigned(state);
  }
}
function writeProp(state, val, parent, accessor) {
  switch (typeof val) {
    case "string":
      return writeString(state, val);
    case "number":
      return writeNumber(state, val);
    case "boolean":
      return writeBoolean(state, val);
    case "bigint":
      return writeBigInt(state, val);
    case "symbol":
      return writeSymbol(state, val, parent, accessor);
    case "function":
      return writeFunction(state, val, parent, accessor);
    case "object":
      return writeObject(state, val, parent, accessor);
    default:
      return !1;
  }
}
function writeReferenceOr(state, write2, val, parent, accessor) {
  let ref = state.refs.get(val);
  if (ref)
    return ref.init ? (addAssignment(ref, ensureId(state, parent) + toAccess(accessor)), !1) : isCircular(parent, ref) ? (ref.assigns || (ensureId(state, ref), state.assigned.add(ref)), addAssignment(ref, ensureId(state, parent) + toAccess(accessor)), !1) : (state.buf.push(ensureId(state, ref)), !0);
  let registered = REGISTRY.get(val);
  return registered ? writeRegistered(state, val, parent, accessor, registered) : (state.refs.set(
    val,
    ref = new Reference(parent, accessor, state.flush, state.buf.length)
  ), write2(state, val, ref) ? !0 : (state.refs.delete(ref), !1));
}
function writeRegistered(state, val, parent, accessor, { access, scope, getter }) {
  if (scope) {
    let scopeRef = state.refs.get(scope), fnRef = new Reference(
      parent,
      accessor,
      state.flush,
      state.buf.length
    );
    if (state.refs.set(val, fnRef), getter) {
      if (scopeRef)
        return state.buf.push("()=>" + ensureId(state, scopeRef) + access), !0;
      state.buf.push("(s=>()=>s" + access + ")("), writeProp(state, scope, parent, ""), state.buf.push(")");
      let newScopeRef = state.refs.get(scope);
      return newScopeRef && ensureId(state, newScopeRef), !0;
    }
    if (scopeRef) {
      if (parent && (state.assigned.has(scopeRef) || isCircular(parent, scopeRef)))
        return state.assigned.add(parent), state.assigned.add(fnRef), fnRef.init = access + "(" + ensureId(state, scopeRef) + ")", addAssignment(fnRef, ensureId(state, parent) + toAccess(accessor)), !1;
      state.buf.push(access + "(" + ensureId(state, scopeRef) + ")");
    } else {
      let pos = state.buf.push("") - 1, assigns = state.assigned.size;
      writeProp(state, scope, parent, "");
      let scopeRef2 = parent && state.refs.get(scope), scopeId = scopeRef2 && ensureId(state, scopeRef2);
      scopeId && assigns !== state.assigned.size ? (state.assigned.add(parent), state.assigned.add(fnRef), fnRef.init = access + "(" + scopeId + ")", addAssignment(fnRef, ensureId(state, parent) + toAccess(accessor))) : (state.buf[pos] = access + "(" + state.buf[pos], state.buf.push(")"));
    }
  } else
    state.buf.push(access);
  return !0;
}
function writeString(state, val) {
  return state.buf.push(quote(val, 0)), !0;
}
function writeNumber(state, val) {
  return state.buf.push(val + ""), !0;
}
function writeBoolean(state, val) {
  return state.buf.push(val ? "!0" : "!1"), !0;
}
function writeBigInt(state, val) {
  return state.buf.push(val + "n"), !0;
}
function writeFunction(state, val, parent, accessor) {
  let wellKnownFunction = KNOWN_FUNCTIONS.get(val);
  return wellKnownFunction ? (state.buf.push(wellKnownFunction), !0) : writeReferenceOr(state, writeNever, val, parent, accessor);
}
function writeSymbol(state, val, parent, accessor) {
  let wellKnownSymbol = KNOWN_SYMBOLS.get(val);
  if (wellKnownSymbol)
    return state.buf.push(wellKnownSymbol), !0;
  let key = Symbol.keyFor(val);
  return key !== void 0 ? (state.buf.push("Symbol.for(" + quote(key, 0) + ")"), !0) : writeReferenceOr(state, writeUnknownSymbol, val, parent, accessor);
}
function writeUnknownSymbol(state) {
  return state.buf.push("Symbol()"), !0;
}
function writeNever(state, val, ref) {
  return !1;
}
function writeNull(state) {
  return state.buf.push("null"), !0;
}
function writeObject(state, val, parent, accessor) {
  if (val === null) return writeNull(state);
  let wellKnownObject = KNOWN_OBJECTS.get(val);
  return wellKnownObject ? (state.buf.push(wellKnownObject), !0) : writeReferenceOr(state, writeUnknownObject, val, parent, accessor);
}
function writeUnknownObject(state, val, ref) {
  switch (val.constructor) {
    case void 0:
      return writeNullObject(state, val, ref);
    case Object:
      return writePlainObject(state, val, ref);
    case Array:
      return writeArray(state, val, ref);
    case Date:
      return writeDate(state, val);
    case RegExp:
      return writeRegExp(state, val);
    case Promise:
      return writePromise(state, val, ref);
    case Map:
      return writeMap(state, val, ref);
    case Set:
      return writeSet(state, val, ref);
    case Generator:
      return writeGenerator(state, val, ref);
    case AsyncGenerator:
      return writeAsyncGenerator(state, val, ref);
    case Error:
    case EvalError:
    case RangeError:
    case ReferenceError:
    case SyntaxError:
    case TypeError:
    case URIError:
      return writeError(state, val, ref);
    case AggregateError:
      return writeAggregateError(state, val, ref);
    case ArrayBuffer:
      return writeArrayBuffer(state, val);
    case Int8Array:
    case Uint8Array:
    case Uint8ClampedArray:
    case Int16Array:
    case Uint16Array:
    case Int32Array:
    case Uint32Array:
    case Float32Array:
    case Float64Array:
      return writeTypedArray(state, val, ref);
    case WeakSet:
      return writeWeakSet(state);
    case WeakMap:
      return writeWeakMap(state);
    // The following references use `globalThis`
    // since they are not implemented by all runtimes.
    case globalThis.URL:
      return writeURL(state, val);
    case globalThis.URLSearchParams:
      return writeURLSearchParams(state, val);
    case globalThis.Headers:
      return writeHeaders(state, val);
    case globalThis.FormData:
      return writeFormData(state, val);
    case globalThis.ReadableStream:
      return writeReadableStream(state, val, ref);
    case globalThis.Request:
      return writeRequest(state, val, ref);
    case globalThis.Response:
      return writeResponse(state, val, ref);
  }
  return !1;
}
function writePlainObject(state, val, ref) {
  return state.buf.push("{"), writeObjectProps(state, val, ref), state.buf.push("}"), !0;
}
function writeArray(state, val, ref) {
  let sep = "[";
  for (let i = 0; i < val.length; i++) {
    let item = val[i];
    state.buf.push(sep), sep = ",", item === void 0 ? (state.wroteUndefined = !0, state.buf.push("$")) : writeProp(state, item, ref, "" + i);
  }
  return sep === "[" ? state.buf.push("[]") : state.buf.push("]"), !0;
}
function writeDate(state, val) {
  return state.buf.push('new Date("' + val.toISOString() + '")'), !0;
}
function writeRegExp(state, val) {
  return state.buf.push(val + ""), !0;
}
function writePromise(state, val, ref) {
  let { boundary } = state;
  if (!boundary) return !1;
  let pId = nextRefAccess(state), pRef = new Reference(ref, null, state.flush, null, pId);
  return state.buf.push("new Promise((f,r)=>" + pId + "={f,r})"), val.then(
    (v) => writeAsyncCall(state, boundary, pRef, "f", v, pId),
    (v) => writeAsyncCall(state, boundary, pRef, "r", v, pId)
  ), boundary.startAsync(), !0;
}
function writeMap(state, val, ref) {
  if (!val.size)
    return state.buf.push("new Map"), !0;
  let arrayRef = new Reference(
    ref,
    null,
    state.flush,
    null,
    nextRefAccess(state)
  ), items = [], assigns, i = 0;
  if (val.size < 25) {
    for (let [itemKey, itemValue] of val)
      itemKey === val && (itemKey = void 0, (assigns ||= []).push("a[" + i + "][0]")), itemValue === val && (itemValue = void 0, (assigns ||= []).push("a[" + i + "][1]")), i = items.push(
        itemValue === void 0 ? itemKey === void 0 ? [] : [itemKey] : [itemKey, itemValue]
      );
    assigns ? state.buf.push(
      "((m,a)=>(" + assignsToString(assigns, "m") + ",a.forEach(i=>m.set(i[0],i[1])),m))(new Map," + arrayRef.id + "="
    ) : state.buf.push("new Map(" + arrayRef.id + "="), writeArray(state, items, arrayRef), state.buf.push(")");
  } else {
    for (let [itemKey, itemValue] of val)
      itemKey === val && (itemKey = 0, (assigns ||= []).push("a[" + i + "]")), itemValue === val && (itemValue = 0, (assigns ||= []).push("a[" + (i + 1) + "]")), i = items.push(itemKey, itemValue);
    assigns ? state.buf.push(
      "(a=>a.reduce((m,v,i)=>i%2?m:m.set(v,a[i+1])," + assignsToString(assigns, "new Map") + "))(" + arrayRef.id + "="
    ) : state.buf.push(
      "(a=>a.reduce((m,v,i)=>i%2?m:m.set(v,a[i+1]),new Map))(" + arrayRef.id + "="
    ), writeArray(state, items, arrayRef), state.buf.push(")");
  }
  return !0;
}
function writeSet(state, val, ref) {
  if (!val.size)
    return state.buf.push("new Set"), !0;
  let items = [], assigns, i = 0;
  for (let item of val)
    item === val && (item = 0, (assigns ||= []).push("i[" + i + "]")), i = items.push(item);
  let arrayRef = new Reference(
    ref,
    null,
    state.flush,
    null,
    nextRefAccess(state)
  );
  return state.buf.push(
    (assigns ? "((s,i)=>(" + assignsToString(assigns, "s") + ",i.forEach(i=>s.add(i)),s))(new Set," : "new Set(") + arrayRef.id + "="
  ), writeArray(state, items, arrayRef), state.buf.push(")"), !0;
}
function writeArrayBuffer(state, val) {
  let result = "";
  if (val.byteLength) {
    let view = new Int8Array(val);
    result = hasOnlyZeros(view) ? "new ArrayBuffer(" + val.byteLength + ")" : "new Int8Array(" + typedArrayToInitString(view) + ").buffer";
  } else
    result = "new ArrayBuffer";
  return state.buf.push(result), !0;
}
function writeTypedArray(state, val, ref) {
  return val.byteOffset || state.refs.has(val.buffer) ? (state.buf.push("new " + val.constructor.name + "("), writeProp(state, val.buffer, ref, "buffer"), state.buf.push(val.byteOffset ? "," + val.byteOffset + ")" : ")")) : (state.refs.set(val.buffer, new Reference(ref, "buffer", state.flush, null)), state.buf.push(
    "new " + val.constructor.name + (val.length === 0 ? "" : "(" + (hasOnlyZeros(val) ? val.length : typedArrayToInitString(val)) + ")")
  )), !0;
}
function writeWeakSet(state) {
  return state.buf.push("new WeakSet"), !0;
}
function writeWeakMap(state) {
  return state.buf.push("new WeakMap"), !0;
}
function writeError(state, val, ref) {
  let result = "new " + val.constructor.name + "(" + quote(val.message + "", 0);
  return val.cause ? (state.buf.push(result + ",{cause:"), writeProp(state, val.cause, ref, "cause"), state.buf.push("})")) : state.buf.push(result + ")"), !0;
}
function writeAggregateError(state, val, ref) {
  return state.buf.push("new AggregateError("), writeProp(state, val.errors, ref, "errors"), val.message ? state.buf.push("," + quote(val.message + "", 0) + ")") : state.buf.push(")"), !0;
}
function writeURL(state, val) {
  return state.buf.push("new URL(" + quote(val.toString(), 0) + ")"), !0;
}
function writeURLSearchParams(state, val) {
  let str = val.toString();
  return str ? state.buf.push("new URLSearchParams(" + quote(str, 0) + ")") : state.buf.push("new URLSearchParams"), !0;
}
function writeHeaders(state, val) {
  let headers = stringEntriesToProps(val);
  return state.buf.push("new Headers" + (headers ? "({" + headers + "})" : "")), !0;
}
function writeFormData(state, val) {
  let sep = "[", valStr = "";
  for (let [key, value] of val)
    typeof value == "string" && (valStr += sep + quote(key, 0) + "," + quote(value, 0), sep = ",");
  return sep === "[" ? state.buf.push("new FormData") : state.buf.push(
    valStr + "].reduce((f,v,i,a)=>i%2&&f.append(v,a[i+1])||f,new FormData)"
  ), !0;
}
function writeRequest(state, val, ref) {
  let sep = "", hasBody = val.body && !val.bodyUsed && val.duplex === "half";
  state.buf.push("new Request(" + quote(val.url, 0)), hasBody && (state.buf.push(",{body:"), writeProp(state, val.body, ref, "body") ? (state.buf.push(',duplex:"half"'), sep = ",") : state.buf.pop());
  let options = "";
  val.cache !== "default" && (options += sep + "cache:" + quote(val.cache, 0), sep = ","), val.credentials !== "same-origin" && (options += sep + "credentials:" + quote(val.credentials, 0), sep = ",");
  let headers = stringEntriesToProps(val.headers);
  return state.refs.set(val.headers, new Reference(ref, "headers", state.flush, null)), headers && (options += sep + "headers:{" + headers + "}", sep = ","), val.integrity && (options += sep + "integrity:" + quote(val.integrity, 0), sep = ","), val.keepalive && (options += sep + "keepalive:true", sep = ","), val.method !== "GET" && (options += sep + "method:" + quote(val.method, 0), sep = ","), val.mode !== "cors" && (options += sep + "mode:" + quote(val.mode, 0), sep = ","), val.redirect !== "follow" && (options += sep + "redirect:" + quote(val.redirect, 0), sep = ","), val.referrer !== "about:client" && (options += sep + "referrer:" + quote(val.referrer, 0), sep = ","), val.referrerPolicy && (options += sep + "referrerPolicy:" + quote(val.referrerPolicy, 0), sep = ","), state.buf.push(
    hasBody ? options + "})" : options ? ",{" + options + "})" : ")"
  ), !0;
}
function writeResponse(state, val, ref) {
  let sep = "", options = "";
  val.status !== 200 && (options += "status:" + val.status, sep = ","), val.statusText && (options += sep + "statusText:" + quote(val.statusText, 0), sep = ",");
  let headers = stringEntriesToProps(val.headers);
  return state.refs.set(val.headers, new Reference(ref, "headers", state.flush, null)), headers && (options += sep + "headers:{" + headers + "}", sep = ","), !val.body || val.bodyUsed ? state.buf.push(
    "new Response" + (options ? "(null,{" + options + "})" : "")
  ) : (state.buf.push("new Response("), state.buf.push(
    (writeProp(state, val.body, ref, "body") ? "" : "null") + (options ? ",{" + options + "})" : ")")
  )), !0;
}
function writeReadableStream(state, val, ref) {
  let { boundary } = state;
  if (!boundary || val.locked) return !1;
  let reader = val.getReader(), iterId = nextRefAccess(state), iterRef = new Reference(ref, null, state.flush, null, iterId), onFulfilled = ({ value, done }) => {
    done ? writeAsyncCall(state, boundary, iterRef, "r", value) : boundary.signal.aborted || (reader.read().then(onFulfilled, onRejected), boundary.startAsync(), writeAsyncCall(state, boundary, iterRef, "f", value));
  }, onRejected = (reason) => {
    writeAsyncCall(state, boundary, iterRef, "j", reason);
  };
  return state.buf.push(
    "new ReadableStream({start(c){(async(_,f,v,l,i,p=a=>l=new Promise((r,j)=>{f=_.r=r;_.j=j}),a=((_.f=v=>{f(v);a.push(p())}),[p()]))=>{for(i of a)v=await i,i==l?c.close():c.enqueue(v)})(" + iterId + "={}).catch(e=>c.error(e))}})"
  ), reader.read().then(onFulfilled, onRejected), boundary.startAsync(), !0;
}
function writeGenerator(state, iter, ref) {
  if (iter[kTouchedIterator])
    return state.buf.push("(async function*(){}())"), !0;
  let sep = "";
  for (state.buf.push("(function*(){"); ; ) {
    let { value, done } = iter.next();
    if (done) {
      value !== void 0 && (state.buf.push(sep + "return "), writeProp(state, value, ref, ""));
      break;
    }
    value === void 0 ? state.buf.push(sep + "yield") : (state.buf.push(sep + "yield "), writeProp(state, value, ref, "")), sep = ";";
  }
  return state.buf.push("})()"), !0;
}
function writeAsyncGenerator(state, iter, ref) {
  if (iter[kTouchedIterator])
    return state.buf.push("(async function*(){}())"), !0;
  let { boundary } = state;
  if (!boundary) return !1;
  let iterId = nextRefAccess(state), iterRef = new Reference(ref, null, state.flush, null, iterId), onFulfilled = ({ value, done }) => {
    done ? writeAsyncCall(state, boundary, iterRef, "r", value) : boundary.signal.aborted || (iter.next().then(onFulfilled, onRejected), boundary.startAsync(), writeAsyncCall(state, boundary, iterRef, "f", value));
  }, onRejected = (reason) => {
    writeAsyncCall(state, boundary, iterRef, "j", reason);
  };
  return state.buf.push(
    "(async function*(_,f,v,l,i,p=a=>l=new Promise((r,j)=>{f=_.r=r;_.j=j}),a=((_.f=v=>{f(v);a.push(p())}),[p()])){for(i of a)v=await i,i!=l&&(yield v);return v})(" + iterId + "={})"
  ), iter.next().then(onFulfilled, onRejected), boundary.startAsync(), !0;
}
function writeNullObject(state, val, ref) {
  return state.buf.push("{"), state.buf.push(writeObjectProps(state, val, ref) + "__proto__:null}"), !0;
}
function writeObjectProps(state, val, ref) {
  let sep = "";
  for (let key in val)
    if (hasOwnProperty.call(val, key)) {
      let escapedKey = toObjectKey(key);
      state.buf.push(sep + escapedKey + ":"), writeProp(
        state,
        val[key],
        ref,
        escapedKey
      ) ? sep = "," : state.buf.pop();
    }
  if (hasSymbolIterator(val)) {
    let iterArr = [...val];
    switch (iterArr.length) {
      case 0:
        state.buf.push(sep + "*[Symbol.iterator](){}");
        break;
      case 1:
        state.buf.push(
          sep + "*[Symbol.iterator](){yield " + (iterArr[0] === val ? "this" : ensureId(state, ref)) + "}"
        );
        break;
      default: {
        let iterRef = new Reference(
          ref,
          null,
          state.flush,
          null,
          nextRefAccess(state)
        );
        state.buf.push(sep + "*[(" + iterRef.id + "="), writeArray(state, iterArr, iterRef), state.buf.push(",Symbol.iterator)](){yield*" + iterRef.id + "}");
        break;
      }
    }
    sep = ",";
  }
  return sep;
}
function writeAsyncCall(state, boundary, ref, method, value, preferredValueId = null) {
  if (boundary.signal.aborted) return;
  state.flushed = !0;
  let valueStartIndex = state.buf.push(
    (state.buf.length === 0 ? "" : ",") + ref.id + "." + method + "("
  );
  if (writeProp(state, value, ref, "")) {
    let valueRef = state.refs.get(value);
    valueRef && !valueRef.id && (valueRef.id = preferredValueId || nextRefAccess(state), state.buf[valueStartIndex] = valueRef.id + "=" + state.buf[valueStartIndex]);
  }
  state.buf.push(")"), boundary.endAsync();
}
function isCircular(parent, ref) {
  let cur = parent;
  for (; cur; ) {
    if (cur === ref) return !0;
    cur = cur.parent;
  }
  return !1;
}
function toObjectKey(name) {
  if (name === "")
    return '""';
  let startChar = name[0];
  if (isDigit(startChar)) {
    if (startChar === "0") {
      if (name !== "0")
        return quote(name, 1);
    } else
      for (let i = 1; i < name.length; i++)
        if (!isDigit(name[i]))
          return quote(name, i);
  } else if (isWord(startChar)) {
    for (let i = 1; i < name.length; i++)
      if (!isWordOrDigit(name[i]))
        return quote(name, i);
  } else
    return quote(name, 0);
  return name;
}
function toAccess(accessor) {
  let start = accessor[0];
  return start === '"' || start >= "0" && start <= "9" ? "[" + accessor + "]" : "." + accessor;
}
function quote(str, startPos) {
  let result = "", lastPos = 0;
  for (let i = startPos; i < str.length; i++) {
    let replacement;
    switch (str[i]) {
      case '"':
        replacement = '\\"';
        break;
      case "\\":
        replacement = "\\\\";
        break;
      case "<":
        replacement = "\\x3C";
        break;
      case `
`:
        replacement = "\\n";
        break;
      case "\r":
        replacement = "\\r";
        break;
      case "\u2028":
        replacement = "\\u2028";
        break;
      case "\u2029":
        replacement = "\\u2029";
        break;
      default:
        continue;
    }
    result += str.slice(lastPos, i) + replacement, lastPos = i + 1;
  }
  return '"' + (lastPos === startPos ? str : result + str.slice(lastPos)) + '"';
}
function ensureId(state, ref) {
  return ref.id || assignId(state, ref);
}
function assignId(state, ref) {
  let { pos } = ref;
  if (ref.id = nextRefAccess(state), pos !== null && ref.flush === state.flush)
    return pos === 0 ? state.buf[0] = ref.id + "=" + state.buf[0] : state.buf[pos - 1] += ref.id + "=", ref.id;
  let cur = ref, accessPrevValue = "";
  do {
    accessPrevValue = toAccess(cur.accessor) + accessPrevValue;
    let parent = cur.parent;
    if (parent.id) {
      accessPrevValue = parent.id + accessPrevValue;
      break;
    }
    if (parent.flush === state.flush) {
      accessPrevValue = ensureId(state, parent) + accessPrevValue;
      break;
    }
    cur = parent;
  } while (cur);
  return ref.id + "=" + accessPrevValue;
}
function assignsToString(assigns, value) {
  return assigns.length > 100 ? "($=>(" + assigns.join("=$,") + "=$))(" + value + ")" : assigns.join("=") + "=" + value;
}
function addAssignment(ref, assign) {
  ref.assigns ? ref.assigns.push(assign) : ref.assigns = [assign];
}
function nextRefAccess(state) {
  return "_." + nextId(state);
}
function nextId(state) {
  let c = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789", n = state.ids++, r = c[n % 53];
  for (n = n / 53 | 0; n; n >>>= 6)
    r += c[n & 63];
  return r;
}
function hasSymbolIterator(value) {
  return Symbol.iterator in value;
}
function stringEntriesToProps(entries) {
  let result = "", sep = "";
  for (let [key, value] of entries)
    result += sep + toObjectKey(key) + ":" + quote(value, 0), sep = ",";
  return result;
}
function typedArrayToInitString(view) {
  let result = "[", sep = "";
  for (let i = 0; i < view.length; i++)
    result += sep + view[i], sep = ",";
  return result += "]", result;
}
function hasOnlyZeros(typedArray) {
  for (let i = 0; i < typedArray.length; i++)
    if (typedArray[i] !== 0) return !1;
  return !0;
}
function isWordOrDigit(char) {
  return isWord(char) || isDigit(char);
}
function isDigit(char) {
  return char >= "0" && char <= "9";
}
function isWord(char) {
  return char >= "a" && char <= "z" || char >= "A" && char <= "Z" || char === "_" || char === "$";
}
function patchIteratorNext(proto) {
  let { next } = proto;
  proto.next = function(value) {
    return this[kTouchedIterator] = 1, next.call(this, value);
  };
}

// src/html/writer.ts
var $chunk, NOOP = () => {
}, K_SCOPE_ID = Symbol("Scope ID");
function getChunk() {
  return $chunk;
}
function getContext(key) {
  return $chunk.context?.[key];
}
function getState() {
  return $chunk.boundary.state;
}
function getScopeId(scope) {
  return scope[K_SCOPE_ID];
}
function write(html) {
  $chunk.writeHTML(html);
}
function writeScript(script) {
  $chunk.writeScript(script);
}
function writeEffect(scopeId, registryId) {
  $chunk.boundary.state.needsMainRuntime = !0, $chunk.writeEffect(scopeId, registryId);
}
function writeContent(nodeAccessor, scopeId, content, serializeReason) {
  let shouldResume = serializeReason !== 0, render2 = normalizeServerRender(content), branchId = peekNextScopeId();
  render2 && (shouldResume ? withBranchId(branchId, render2) : render2()), peekNextScopeId() !== branchId ? shouldResume && writeScope(scopeId, {
    ["d" /* ConditionalScope */ + nodeAccessor]: writeScope(
      branchId,
      {}
    ),
    ["c" /* ConditionalRenderer */ + nodeAccessor]: render2?.h
  }) : nextScopeId();
}
function normalizeServerRender(value) {
  let renderer = normalizeDynamicRenderer(value);
  if (renderer && typeof renderer == "function")
    return renderer;
}
var kPendingContexts = Symbol("Pending Contexts");
function withContext(key, value, cb) {
  let ctx = $chunk.context ||= { [kPendingContexts]: 0 }, prev = ctx[key];
  ctx[kPendingContexts]++, ctx[key] = value;
  try {
    return cb();
  } finally {
    ctx[kPendingContexts]--, ctx[key] = prev;
  }
}
function setTagVar(parentScopeId, scopeOffsetAccessor, childScopeId, registryId) {
  ensureScopeWithId(parentScopeId)[scopeOffsetAccessor] = nextScopeId(), ensureScopeWithId(childScopeId).e = register2(
    {},
    registryId,
    parentScopeId
  );
}
function register2(val, id, scopeId) {
  return scopeId === void 0 ? register(id, val) : register(id, val, ensureScopeWithId(scopeId));
}
function nextTagId() {
  let state = $chunk.boundary.state, { $global: $global2 } = state;
  return "s" + $global2.runtimeId + $global2.renderId + (state.tagId++).toString(36);
}
function nextScopeId() {
  return $chunk.boundary.state.scopeId++;
}
function peekNextScopeId() {
  return $chunk.boundary.state.scopeId;
}
function getScopeById(scopeId) {
  if (scopeId !== void 0)
    return $chunk.boundary.state.scopes.get(scopeId);
}
function serializeIf(condition, key) {
  return condition && (condition === 1 || condition[key]) ? 1 : void 0;
}
function serializeGuard(condition, key) {
  return condition && (condition === 1 || condition[key]) ? 1 : 0;
}
function markResumeNode(scopeId, accessor, shouldResume) {
  if (shouldResume === 0) return "";
  let { state } = $chunk.boundary;
  return state.needsMainRuntime = !0, state.mark("*" /* Node */, scopeId + " " + accessor);
}
function commentSeparator(shouldResume) {
  return shouldResume === 0 ? "" : "<!>";
}
function nodeRef(scopeId, id) {
  let getter = () => {
  };
  return id ? register2(getter, id, scopeId) : getter;
}
function hoist(scopeId, id) {
  let getter = () => {
  };
  return getter[Symbol.iterator] = getter, id ? register2(getter, id, scopeId) : getter;
}
function resumeClosestBranch(scopeId) {
  let branchId = $chunk.context?.[branchIdKey];
  branchId !== void 0 && branchId !== scopeId && writeScope(scopeId, { g: branchId });
}
var branchIdKey = Symbol();
function withBranchId(branchId, cb) {
  return withContext(branchIdKey, branchId, cb);
}
function resumeForOf(list, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  let { state } = $chunk.boundary, resumeBranch = serializeBranch !== 0, resumeMarker = serializeMarker !== 0, singleNodeBranchIds = "";
  if (resumeBranch) {
    let loopScopes = /* @__PURE__ */ new Map();
    forOf(list, (item, index) => {
      let branchId = peekNextScopeId();
      resumeMarker && (singleNode ? singleNodeBranchIds = " " + branchId + singleNodeBranchIds : $chunk.writeHTML(
        state.mark("[" /* BranchStart */, branchId + (index ? " " : ""))
      )), withBranchId(branchId, () => {
        cb(item, index), loopScopes.set(forOfBy(by, item, index), writeScope(branchId, {}));
      });
    }), loopScopes.size && writeScope(scopeId, {
      ["m" /* LoopScopeMap */ + accessor]: loopScopes
    });
  } else
    forOf(list, cb);
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeForIn(obj, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  let { state } = $chunk.boundary, resumeBranch = serializeBranch !== 0, resumeMarker = serializeMarker !== 0, singleNodeBranchIds = "";
  if (resumeBranch) {
    let loopScopes = /* @__PURE__ */ new Map(), sep = "";
    forIn(obj, (key, value) => {
      let branchId = peekNextScopeId();
      resumeMarker && (singleNode ? singleNodeBranchIds = " " + branchId + singleNodeBranchIds : ($chunk.writeHTML(
        state.mark("[" /* BranchStart */, branchId + sep)
      ), sep = " ")), withBranchId(branchId, () => {
        cb(key, value), loopScopes.set(forInBy(by, key, value), writeScope(branchId, {}));
      });
    }), loopScopes.size && writeScope(scopeId, {
      ["m" /* LoopScopeMap */ + accessor]: loopScopes
    });
  } else
    forIn(obj, cb);
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeForTo(to, from, step, cb, by, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  let { state } = $chunk.boundary, resumeBranch = serializeBranch !== 0, resumeMarker = serializeMarker !== 0, singleNodeBranchIds = "";
  if (resumeBranch) {
    let loopScopes = /* @__PURE__ */ new Map(), sep = "";
    forTo(to, from, step, (i) => {
      let branchId = peekNextScopeId();
      resumeMarker && (singleNode ? singleNodeBranchIds = " " + branchId + singleNodeBranchIds : ($chunk.writeHTML(
        state.mark("[" /* BranchStart */, branchId + sep)
      ), sep = " ")), withBranchId(branchId, () => {
        cb(i), loopScopes.set(forToBy(by, i), writeScope(branchId, {}));
      });
    }), loopScopes.size && writeScope(scopeId, {
      ["m" /* LoopScopeMap */ + accessor]: loopScopes
    });
  } else
    forTo(to, from, step, cb);
  writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + singleNodeBranchIds
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function resumeConditional(cb, scopeId, accessor, serializeBranch, serializeMarker, parentEndTag, singleNode) {
  let { state } = $chunk.boundary, resumeBranch = serializeBranch !== 0, resumeMarker = serializeMarker !== 0, branchId = peekNextScopeId();
  resumeMarker && resumeBranch && !singleNode && $chunk.writeHTML(state.mark("[" /* BranchStart */, branchId + ""));
  let branchIndex = resumeBranch ? withBranchId(branchId, cb) : cb(), shouldWriteBranch = resumeBranch && branchIndex !== void 0;
  shouldWriteBranch && writeScope(scopeId, {
    ["c" /* ConditionalRenderer */ + accessor]: resumeMarker ? branchIndex : void 0,
    ["d" /* ConditionalScope */ + accessor]: writeScope(branchId, {})
  }), writeBranchEnd(
    scopeId,
    accessor,
    resumeMarker,
    parentEndTag,
    resumeMarker && (!parentEndTag || resumeBranch) && (singleNode ? state.mark(
      parentEndTag ? "=" /* BranchSingleNodeOnlyChildInParent */ : "|" /* BranchSingleNode */,
      scopeId + " " + accessor + (shouldWriteBranch ? " " + branchId : "")
    ) : state.mark("]" /* BranchEnd */, scopeId + " " + accessor))
  );
}
function writeBranchEnd(scopeId, accessor, resumeMarker, parentEndTag, mark) {
  let endTag = parentEndTag || "";
  resumeMarker ? mark ? $chunk.writeHTML(mark + endTag) : $chunk.writeHTML(endTag + markResumeNode(scopeId, accessor)) : $chunk.writeHTML(endTag);
}
var writeScope = (scopeId, partialScope) => {
  let { state } = $chunk.boundary, { scopes } = state, scope = scopes.get(scopeId);
  return state.needsMainRuntime = !0, scope ? Object.assign(scope, partialScope) : (scope = partialScope, scope[K_SCOPE_ID] = scopeId, state.scopes.set(scopeId, scope)), state.writeScopes ? state.writeScopes[scopeId] = scope : state.writeScopes = { [scopeId]: scope }, scope;
};
function writeExistingScope(scopeId) {
  return writeScope(scopeId, ensureScopeWithId(scopeId));
}
function ensureScopeWithId(scopeId) {
  let { state } = $chunk.boundary, scope = state.scopes.get(scopeId);
  return scope || (scope = { [K_SCOPE_ID]: scopeId }, state.scopes.set(scopeId, scope)), scope;
}
function $global() {
  return $chunk.boundary.state.$global;
}
function fork(scopeId, accessor, promise, content, serializeMarker) {
  let resumeMarker = serializeMarker !== 0;
  if (!isPromise(promise)) {
    if (resumeMarker) {
      let branchId = peekNextScopeId();
      $chunk.writeHTML(
        $chunk.boundary.state.mark("[" /* BranchStart */, branchId + "")
      ), content(promise), writeScope(scopeId, {
        ["d" /* ConditionalScope */ + accessor]: writeScope(branchId, {})
      }), $chunk.writeHTML(
        $chunk.boundary.state.mark(
          "]" /* BranchEnd */,
          scopeId + " " + accessor
        )
      );
    } else
      content(promise);
    return;
  }
  let chunk = $chunk, { boundary } = chunk;
  chunk.next = $chunk = new Chunk(boundary, chunk.next, chunk.context), chunk.async = !0, chunk.context?.[kPendingContexts] && (chunk.context = { ...chunk.context, [kPendingContexts]: 0 }), boundary.startAsync(), promise.then(
    (value) => {
      chunk.async && (chunk.async = !1, boundary.signal.aborted || (chunk.render(() => {
        if (resumeMarker) {
          let branchId = peekNextScopeId();
          $chunk.writeHTML(
            $chunk.boundary.state.mark(
              "[" /* BranchStart */,
              branchId + ""
            )
          ), content(value), boundary.state.serializer.writeAssign(
            writeScope(branchId, {}),
            ensureScopeWithId(scopeId),
            "d" /* ConditionalScope */ + accessor
          ), $chunk.writeHTML(
            $chunk.boundary.state.mark(
              "]" /* BranchEnd */,
              scopeId + " " + accessor
            )
          );
        } else
          content(value);
      }), boundary.endAsync(chunk)));
    },
    (err) => {
      chunk.async = !1, boundary.abort(err);
    }
  );
}
function tryContent(scopeId, accessor, content, input) {
  let branchId = peekNextScopeId();
  $chunk.writeHTML(
    $chunk.boundary.state.mark("[" /* BranchStart */, branchId + "")
  );
  let catchContent = normalizeDynamicRenderer(input.catch), placeholderContent = normalizeDynamicRenderer(input.placeholder);
  catchContent ? tryCatch(
    placeholderContent ? () => tryPlaceholder(content, placeholderContent) : content,
    catchContent
  ) : placeholderContent ? tryPlaceholder(content, placeholderContent) : content(), writeScope(branchId, {
    a: accessor,
    b: catchContent,
    d: placeholderContent
  }), writeScope(scopeId, {
    ["d" /* ConditionalScope */ + accessor]: getScopeById(branchId)
  }), $chunk.writeHTML(
    $chunk.boundary.state.mark(
      "]" /* BranchEnd */,
      scopeId + " " + accessor
    )
  );
}
function tryPlaceholder(content, placeholder) {
  let chunk = $chunk, { boundary } = chunk, body = new Chunk(boundary, null, chunk.context);
  if (body === body.render(content)) {
    chunk.append(body);
    return;
  }
  chunk.next = $chunk = new Chunk(boundary, chunk.next, body.context), chunk.placeholderBody = body, chunk.placeholderRender = placeholder;
}
function tryCatch(content, catchContent) {
  let chunk = $chunk, { boundary } = chunk, { state } = boundary, catchBoundary = new Boundary(state), body = new Chunk(catchBoundary, null, chunk.context), bodyEnd = body.render(content);
  if (catchBoundary.signal.aborted) {
    catchContent(catchBoundary.signal.reason);
    return;
  }
  if (body === bodyEnd) {
    chunk.append(body);
    return;
  }
  let reorderId = state.nextReorderId(), endMarker = state.mark("!" /* PlaceholderEnd */, reorderId), bodyNext = bodyEnd.next = $chunk = new Chunk(boundary, chunk.next, body.context);
  chunk.next = body, chunk.writeHTML(state.mark("!^" /* Placeholder */, reorderId)), bodyEnd.writeHTML(endMarker), boundary.startAsync(), catchBoundary.onNext = () => {
    if (!boundary.signal.aborted)
      if (catchBoundary.signal.aborted) {
        if (!bodyEnd.consumed) {
          let cur = body, writeMarker = !0;
          do {
            let next = cur.next;
            cur.boundary !== catchBoundary && cur.boundary.abort(catchBoundary.signal.reason), writeMarker && !cur.consumed && (writeMarker = !1, cur.async = !1, cur.next = bodyNext, cur.html = endMarker, cur.scripts = cur.effects = cur.lastEffect = "", cur.placeholderBody = cur.placeholderRender = cur.reorderId = null), cur = next;
          } while (cur !== bodyNext);
        }
        let catchChunk = new Chunk(boundary, null, chunk.context);
        catchChunk.reorderId = reorderId, catchChunk.render(catchContent, catchBoundary.signal.reason), state.reorder(catchChunk), boundary.endAsync();
      } else catchBoundary.count ? boundary.onNext() : boundary.endAsync();
  };
}
var State2 = class {
  constructor($global2) {
    this.$global = $global2;
    this.$global = $global2, $global2.cspNonce && (this.nonceAttr = " nonce" + attrAssignment($global2.cspNonce));
  }
  tagId = 1;
  scopeId = 1;
  reorderId = 1;
  lastSerializedScopeId = this.scopeId;
  hasGlobals = !1;
  needsMainRuntime = !1;
  hasMainRuntime = !1;
  hasReorderRuntime = !1;
  hasWrittenResume = !1;
  walkOnNextFlush = !1;
  trailerHTML = "";
  resumes = "";
  nonceAttr = "";
  serializer = new Serializer();
  writeReorders = null;
  scopes = /* @__PURE__ */ new Map();
  writeScopes = null;
  get runtimePrefix() {
    let { $global: $global2 } = this;
    return $global2.runtimeId + "." + $global2.renderId;
  }
  get commentPrefix() {
    let { $global: $global2 } = this;
    return $global2.runtimeId + $global2.renderId;
  }
  reorder(chunk) {
    this.writeReorders ? this.writeReorders.push(chunk) : (this.needsMainRuntime = !0, this.writeReorders = [chunk]);
  }
  nextReorderId() {
    let c = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ$_0123456789", n = this.reorderId++, r = c[n % 54];
    for (n = n / 54 | 0; n; n >>>= 6)
      r += c[n & 63];
    return r;
  }
  mark(code, str) {
    return "<!--" + this.commentPrefix + code + str + "-->";
  }
}, Boundary = class extends AbortController {
  constructor(state, parent) {
    super();
    this.state = state;
    this.state = state, this.signal.addEventListener("abort", () => {
      this.count = 0, this.state = new State2(this.state.$global), this.onNext();
    }), parent && (parent.aborted ? this.abort(parent.reason) : parent.addEventListener("abort", () => {
      this.abort(parent.reason);
    }));
  }
  onNext = NOOP;
  count = 0;
  get done() {
    return flushSerializer(this), !this.count;
  }
  startAsync() {
    this.signal.aborted || this.count++;
  }
  endAsync(chunk) {
    !this.signal.aborted && this.count && (this.count--, chunk?.reorderId && this.state.reorder(chunk), this.onNext());
  }
}, Chunk = class {
  constructor(boundary, next, context) {
    this.boundary = boundary;
    this.next = next;
    this.context = context;
    this.boundary = boundary, this.next = next, this.context = context;
  }
  html = "";
  scripts = "";
  effects = "";
  lastEffect = "";
  async = !1;
  consumed = !1;
  reorderId = null;
  placeholderBody = null;
  placeholderRender = null;
  writeHTML(html) {
    this.html += html;
  }
  writeEffect(scopeId, registryId) {
    this.lastEffect === registryId ? this.effects += "," + scopeId : (this.lastEffect = registryId, this.effects = concatEffects(
      this.effects,
      '"' + registryId + '",' + scopeId
    ));
  }
  writeScript(script) {
    this.scripts = concatScripts(this.scripts, script);
  }
  append(chunk) {
    this.html += chunk.html, this.effects = concatEffects(this.effects, chunk.effects), this.scripts = concatScripts(this.scripts, chunk.scripts), this.lastEffect = chunk.lastEffect || this.lastEffect;
  }
  flushPlaceholder() {
    if (this.placeholderBody) {
      let body = this.placeholderBody.consume();
      if (body.async) {
        let { state } = this.boundary, reorderId = body.reorderId = state.nextReorderId();
        this.writeHTML(state.mark("!^" /* Placeholder */, reorderId));
        let after = this.render(this.placeholderRender);
        after !== this && this.boundary.abort(
          new Error("An @placeholder cannot contain async content.")
        ), after.writeHTML(state.mark("!" /* PlaceholderEnd */, reorderId)), state.reorder(body);
      } else
        body.next = this.next, this.next = body;
      this.placeholderRender = this.placeholderBody = null;
    }
  }
  consume() {
    let cur = this;
    if (cur.next && !cur.async) {
      let html = "", effects = "", scripts = "", lastEffect = "";
      do
        cur.flushPlaceholder(), html += cur.html, effects = concatEffects(effects, cur.effects), scripts = concatScripts(scripts, cur.scripts), lastEffect = cur.lastEffect || lastEffect, cur.consumed = !0, cur = cur.next;
      while (cur.next && !cur.async);
      cur.html = html + cur.html, cur.effects = concatEffects(effects, cur.effects), cur.scripts = concatScripts(scripts, cur.scripts), cur.lastEffect = lastEffect;
    }
    return cur;
  }
  render(content, val) {
    let prev = $chunk;
    $chunk = this;
    try {
      return content(val), $chunk;
    } catch (err) {
      return this.boundary.abort(err), this;
    } finally {
      $chunk = prev;
    }
  }
  flushScript() {
    flushSerializer(this.boundary);
    let { boundary, effects } = this, { state } = boundary, { $global: $global2, runtimePrefix, nonceAttr } = state, { html, scripts } = this, hasWalk = state.walkOnNextFlush;
    if (hasWalk && (state.walkOnNextFlush = !1), state.needsMainRuntime && !state.hasMainRuntime && (state.hasMainRuntime = !0, scripts = concatScripts(
      scripts,
      WALKER_RUNTIME_CODE + '("' + $global2.runtimeId + '")("' + $global2.renderId + '")'
    )), effects && (hasWalk = !0, state.resumes = state.resumes ? state.resumes + "," + effects : effects), state.resumes && (state.hasWrittenResume ? scripts = concatScripts(
      scripts,
      runtimePrefix + ".r.push(" + state.resumes + ")"
    ) : (state.hasWrittenResume = !0, scripts = concatScripts(
      scripts,
      runtimePrefix + ".r=[" + state.resumes + "]"
    ))), state.writeReorders) {
      hasWalk = !0, state.hasReorderRuntime || (state.hasReorderRuntime = !0, html += "<style " + state.commentPrefix + nonceAttr + ">t{display:none}</style>", scripts = concatScripts(
        scripts,
        REORDER_RUNTIME_CODE + "(" + runtimePrefix + ")"
      ));
      for (let reorderedChunk of state.writeReorders) {
        let { reorderId } = reorderedChunk, reorderHTML = "", reorderEffects = "", reorderScripts = "", cur = reorderedChunk;
        for (reorderedChunk.reorderId = null; ; ) {
          cur.flushPlaceholder();
          let { next } = cur;
          if (cur.consumed = !0, reorderHTML += cur.html, reorderEffects = concatEffects(reorderEffects, cur.effects), reorderScripts = concatScripts(reorderScripts, cur.scripts), cur.async && (reorderHTML += state.mark(
            "#" /* ReorderMarker */,
            cur.reorderId = state.nextReorderId()
          ), cur.html = cur.effects = cur.scripts = cur.lastEffect = "", cur.next = null), next)
            cur = next;
          else
            break;
        }
        reorderEffects && (state.hasWrittenResume || (state.hasWrittenResume = !0, scripts = concatScripts(
          scripts,
          runtimePrefix + ".r=[]"
        )), reorderScripts = concatScripts(
          reorderScripts,
          "_.push(" + reorderEffects + ")"
        )), scripts = concatScripts(
          scripts,
          reorderScripts && runtimePrefix + ".j." + reorderId + "=_=>{" + reorderScripts + "}"
        ), html += "<t " + state.commentPrefix + "=" + reorderId + ">" + reorderHTML + "</t>";
      }
      state.writeReorders = null;
    }
    return hasWalk && (scripts = concatScripts(scripts, runtimePrefix + ".w()")), this.html = html, this.scripts = scripts, this.effects = this.lastEffect = state.resumes = "", this;
  }
  flushHTML() {
    this.flushScript();
    let { boundary, scripts } = this, { state } = boundary, { $global: $global2, nonceAttr } = state, { __flush__ } = $global2, { html } = this;
    return this.html = this.scripts = "", scripts && (html += "<script" + nonceAttr + ">" + scripts + "</script>"), __flush__ && ($global2.__flush__ = void 0, html = __flush__($global2, html)), boundary.count || (html += state.trailerHTML), html;
  }
};
function flushSerializer(boundary) {
  let { state } = boundary, { writeScopes, serializer } = state, { flushed } = serializer;
  if (writeScopes || flushed) {
    let serializeData = [], { lastSerializedScopeId } = state;
    state.hasGlobals || (state.hasGlobals = !0, serializeData.push(getFilteredGlobals(state.$global)));
    for (let key in writeScopes) {
      let scope = writeScopes[key], scopeId = getScopeId(scope), scopeIdDelta = scopeId - lastSerializedScopeId;
      lastSerializedScopeId = scopeId + 1, scopeIdDelta && serializeData.push(scopeIdDelta), serializeData.push(scope);
    }
    state.resumes = concatEffects(
      state.resumes,
      serializer.stringify(serializeData, boundary)
    ), state.lastSerializedScopeId = lastSerializedScopeId, state.writeScopes = null, flushed && (state.walkOnNextFlush = !0);
  }
}
function writeTrailers(html) {
  $chunk.boundary.state.trailerHTML += html;
}
function concatEffects(a, b) {
  return a ? b ? a + "," + b : a : b;
}
function concatScripts(a, b) {
  return a ? b ? a + ";" + b : a : b;
}
var tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb)), tickQueue;
function queueTick(cb) {
  tickQueue ? tickQueue.add(cb) : (tickQueue = /* @__PURE__ */ new Set([cb]), tick(flushTickQueue));
}
function offTick(cb) {
  tickQueue?.delete(cb);
}
function flushTickQueue() {
  let queue = tickQueue;
  tickQueue = void 0;
  for (let cb of queue)
    cb(!0);
}
function isPromise(value) {
  return value != null && typeof value.then == "function";
}
function getFilteredGlobals($global2) {
  if (!$global2) return 0;
  let serializedGlobals = $global2.serializedGlobals;
  if (!serializedGlobals) return 0;
  let filtered = 0;
  if (Array.isArray(serializedGlobals))
    for (let key of serializedGlobals) {
      let value = $global2[key];
      value !== void 0 && (filtered ? filtered[key] = value : filtered = { [key]: value });
    }
  else
    for (let key in serializedGlobals)
      if (serializedGlobals[key]) {
        let value = $global2[key];
        value !== void 0 && (filtered ? filtered[key] = value : filtered = { [key]: value });
      }
  return filtered;
}
function writeSubscribe(subscribers, scope) {
  return $chunk.boundary.state.serializer.writeCall(scope, subscribers, "add"), scope;
}

// src/html/attrs.ts
function classAttr(value) {
  return stringAttr("class", classValue(value));
}
function styleAttr(value) {
  return stringAttr("style", styleValue(value));
}
function optionValueAttr(value) {
  let selectedValue = getContext(kSelectedValue);
  return attr("value", value) + (!isVoid(value) && (Array.isArray(selectedValue) ? selectedValue.includes(value) : selectedValue === value) ? " selected" : "");
}
var kSelectedValue = Symbol("selectedValue");
function controllable_select_value(scopeId, nodeAccessor, value, valueChange, content) {
  valueChange && writeControlledScope(
    3 /* SelectValue */,
    scopeId,
    nodeAccessor,
    value,
    valueChange
  ), content && withContext(kSelectedValue, value, content);
}
function controllable_textarea_value(scopeId, nodeAccessor, value, valueChange) {
  return valueChange && writeControlledScope(
    2 /* InputValue */,
    scopeId,
    nodeAccessor,
    void 0,
    valueChange
  ), escapeTextAreaValue(value);
}
function controllable_input_value(scopeId, nodeAccessor, value, valueChange) {
  return valueChange && writeControlledScope(
    2 /* InputValue */,
    scopeId,
    nodeAccessor,
    void 0,
    valueChange
  ), attr("value", value);
}
function controllable_input_checked(scopeId, nodeAccessor, checked, checkedChange) {
  return checkedChange && writeControlledScope(
    0 /* InputChecked */,
    scopeId,
    nodeAccessor,
    void 0,
    checkedChange
  ), attr("checked", checked);
}
function controllable_input_checkedValue(scopeId, nodeAccessor, checkedValue, checkedValueChange, value) {
  let multiple = Array.isArray(checkedValue), valueAttr = attr("value", value);
  return checkedValueChange && writeControlledScope(
    1 /* InputCheckedValue */,
    scopeId,
    nodeAccessor,
    checkedValue,
    checkedValueChange
  ), (multiple ? checkedValue.includes(value) : checkedValue === value) ? valueAttr + " checked" : valueAttr;
}
function controllable_detailsOrDialog_open(scopeId, nodeAccessor, open, openChange) {
  return openChange && writeControlledScope(
    4 /* DetailsOrDialogOpen */,
    scopeId,
    nodeAccessor,
    open,
    openChange
  ), attr("open", open);
}
function attr(name, value) {
  return isVoid(value) ? "" : nonVoidAttr(name, value);
}
function attrs(data, nodeAccessor, scopeId, tagName) {
  let result = "", skip = /[\s/>"'=]/, events;
  switch (tagName) {
    case "input":
      if (data.checkedChange)
        result += controllable_input_checked(
          scopeId,
          nodeAccessor,
          data.checked,
          data.checkedChange
        );
      else if (data.checkedValue || data.checkedValueChange)
        result += controllable_input_checkedValue(
          scopeId,
          nodeAccessor,
          data.checkedValue,
          data.checkedValueChange,
          data.value
        );
      else if (data.valueChange)
        result += controllable_input_value(
          scopeId,
          nodeAccessor,
          data.value,
          data.valueChange
        );
      else
        break;
      skip = /^(?:value|checked(?:Value)?)(?:Change)?$|[\s/>"'=]/;
      break;
    case "select":
    case "textarea":
      (data.value || data.valueChange) && (skip = /^value(?:Change)?$|[\s/>"'=]/);
      break;
    case "option":
      data.value && (result += optionValueAttr(data.value), skip = /^value$|[\s/>"'=]/);
      break;
    case "details":
    case "dialog":
      data.openChange && (result += controllable_detailsOrDialog_open(
        scopeId,
        nodeAccessor,
        data.open,
        data.openChange
      ), skip = /^open(?:Change)?$|[\s/>"'=]/);
      break;
  }
  for (let name in data) {
    let value = data[name];
    switch (name) {
      case "class":
        result += classAttr(value);
        break;
      case "style":
        result += styleAttr(value);
        break;
      case "":
      case "content":
        break;
      default:
        isVoid(value) || (isEventHandler(name) ? (events || (events = {}, writeScope(scopeId, {
          ["i" /* EventAttributes */ + nodeAccessor]: events
        })), events[getEventHandlerName(name)] = value) : skip.test(name) || (result += nonVoidAttr(name, value)));
        break;
    }
  }
  return result;
}
function writeAttrsAndContent(data, nodeAccessor, scopeId, tagName, serializeReason) {
  write(`${attrs(data, nodeAccessor, scopeId, tagName)}>`), writeContent(nodeAccessor, scopeId, data?.content, serializeReason);
}
function partialAttrs(data, skip, nodeAccessor, scopeId, tagName) {
  let partial = {};
  for (let key in data)
    skip[key] || (partial[key] = data[key]);
  return attrs(partial, nodeAccessor, scopeId, tagName);
}
function writePartialAttrsAndContent(data, skip, nodeAccessor, scopeId, tagName, serializeReason) {
  write(`${partialAttrs(data, skip, nodeAccessor, scopeId, tagName)}>`), writeContent(nodeAccessor, scopeId, data?.content, serializeReason);
}
function writeControlledScope(type, scopeId, nodeAccessor, value, valueChange) {
  writeScope(scopeId, {
    ["f" /* ControlledType */ + nodeAccessor]: type,
    ["g" /* ControlledValue */ + nodeAccessor]: value,
    ["e" /* ControlledHandler */ + nodeAccessor]: valueChange
  });
}
function stringAttr(name, value) {
  return value && " " + name + attrAssignment(value);
}
function nonVoidAttr(name, value) {
  switch (typeof value) {
    case "string":
      return " " + name + attrAssignment(value);
    case "boolean":
      return " " + name;
    case "number":
      return " " + name + "=" + value;
    case "object":
      if (value instanceof RegExp)
        return " " + name + attrAssignment(value.source);
      break;
  }
  return " " + name + attrAssignment(value + "");
}
var singleQuoteAttrReplacements = /'|&(?=#?\w+;)/g, doubleQuoteAttrReplacements = /"|&(?=#?\w+;)/g, needsQuotedAttr = /["'>\s]|&#?\w+;|\/$/g;
function attrAssignment(value) {
  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '"') ? "='" + escapeSingleQuotedAttrValue(value) + "'" : '="' + escapeDoubleQuotedAttrValue(value) + '"' : "=" + value : "";
}
function escapeSingleQuotedAttrValue(value) {
  return singleQuoteAttrReplacements.test(value) ? value.replace(
    singleQuoteAttrReplacements,
    replaceUnsafeSingleQuoteAttrChar
  ) : value;
}
function replaceUnsafeSingleQuoteAttrChar(match) {
  return match === "'" ? "&#39;" : "&amp;";
}
function escapeDoubleQuotedAttrValue(value) {
  return doubleQuoteAttrReplacements.test(value) ? value.replace(
    doubleQuoteAttrReplacements,
    replaceUnsafeDoubleQuoteAttrChar
  ) : value;
}
function replaceUnsafeDoubleQuoteAttrChar(match) {
  return match === '"' ? "&#34;" : "&amp;";
}

// src/common/compat-meta.ts
var prefix = "$C_", RENDERER_REGISTER_ID = prefix + "r", SET_SCOPE_REGISTER_ID = prefix + "s", RENDER_BODY_ID = prefix + "b";

// src/common/meta.ts
var DEFAULT_RUNTIME_ID = "M", DEFAULT_RENDER_ID = "_";

// src/html/template.ts
var createTemplate = (templateId, renderer) => (renderer.render = render, renderer._ = renderer, registerContent(templateId, renderer));
function isTemplate(renderer) {
  return !!renderer._;
}
function render(input = {}) {
  let { $global: $global2 } = input;
  $global2 ? ({ $global: $global2, ...input } = input, $global2 = {
    runtimeId: DEFAULT_RUNTIME_ID,
    renderId: DEFAULT_RENDER_ID,
    ...$global2
  }) : $global2 = { runtimeId: DEFAULT_RUNTIME_ID, renderId: DEFAULT_RENDER_ID };
  let head = new Chunk(
    new Boundary(new State2($global2), $global2.signal),
    null,
    null
  );
  return head.render(this, input), new ServerRendered(head);
}
var ServerRendered = class {
  #head;
  #cachedPromise = null;
  constructor(head) {
    this.#head = head;
  }
  [Symbol.asyncIterator]() {
    let resolve, reject, value = "", done = !1, aborted = !1, reason, boundary = this.#read(
      (html) => {
        value += html, resolve && (resolve({ value, done }), value = "");
      },
      (err) => {
        aborted = !0, reason = err, reject && reject(err);
      },
      () => {
        done = !0, resolve && (resolve({ value, done: !value }), value = "");
      }
    );
    return {
      next() {
        if (aborted)
          return Promise.reject(reason);
        if (value) {
          let result = { value, done: !1 };
          return value = "", Promise.resolve(result);
        } else return done ? Promise.resolve({ value: "", done }) : new Promise(exec);
      },
      throw(error) {
        return done || aborted || boundary?.abort(error), Promise.resolve({ value: "", done: !0 });
      },
      return(value2) {
        return done || aborted || boundary?.abort(new Error("Iterator returned before consumed.")), Promise.resolve({ value: value2, done: !0 });
      }
    };
    function exec(_resolve, _reject) {
      resolve = _resolve, reject = _reject;
    }
  }
  pipe(stream) {
    this.#read(
      (html) => {
        stream.write(html);
      },
      (err) => {
        let socket = "socket" in stream && stream.socket;
        if (socket && typeof socket.destroySoon == "function" && socket.destroySoon(), !stream.emit?.("error", err))
          throw err;
      },
      () => {
        stream.end();
      }
    );
  }
  toReadable() {
    let cancelled = !1, boundary, encoder = new TextEncoder();
    return new ReadableStream({
      start: (ctrl) => {
        boundary = this.#read(
          (html) => {
            ctrl.enqueue(encoder.encode(html));
          },
          (err) => {
            boundary = void 0, cancelled || ctrl.error(err);
          },
          () => {
            boundary = void 0, ctrl.close();
          }
        );
      },
      cancel: (reason) => {
        cancelled = !0, boundary?.abort(reason);
      }
    });
  }
  then(onfulfilled, onrejected) {
    return this.#promise().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.#promise().catch(onrejected);
  }
  finally(onfinally) {
    return this.#promise().finally(onfinally);
  }
  #promise() {
    return this.#cachedPromise ||= new Promise((resolve, reject) => {
      let head = this.#head;
      if (this.#head = null, !head)
        return reject(new Error("Cannot read from a consumed render result"));
      let { boundary } = head;
      (boundary.onNext = () => {
        boundary.signal.aborted ? (boundary.onNext = NOOP2, reject(boundary.signal.reason)) : boundary.done && resolve(head.consume().flushHTML());
      })();
    });
  }
  #read(onWrite, onAbort, onClose) {
    let tick2 = !0, head = this.#head;
    if (this.#head = null, !head) {
      onAbort(new Error("Cannot read from a consumed render result"));
      return;
    }
    let { boundary } = head, onNext = boundary.onNext = (write2) => {
      if (boundary.signal.aborted)
        tick2 || offTick(onNext), boundary.onNext = NOOP2, onAbort(boundary.signal.reason);
      else {
        let { done } = boundary;
        if (done || write2) {
          let html = (head = head.consume()).flushHTML();
          html && onWrite(html), done ? (tick2 || offTick(onNext), onClose()) : tick2 = !0;
        } else tick2 && (tick2 = !1, queueTick(onNext));
      }
    };
    return onNext(), boundary;
  }
  toString() {
    let head = this.#head;
    if (this.#head = null, !head) throw new Error("Cannot read from a consumed render result");
    let { boundary } = head;
    if (!boundary.done)
      throw new Error("Cannot consume asynchronous render with 'toString'");
    if (boundary.signal.aborted) throw boundary.signal.reason;
    return head.consume().flushHTML();
  }
};
function NOOP2() {
}

// src/html/dynamic-tag.ts
var voidElementsReg = /^(?:area|b(?:ase|r)|col|embed|hr|i(?:mg|nput)|link|meta|param|source|track|wbr)$/, dynamicTag = (scopeId, accessor, tag, inputOrArgs, content, inputIsArgs, serializeReason) => {
  let shouldResume = serializeReason !== 0, renderer = normalizeDynamicRenderer(tag), state = getState(), branchId = peekNextScopeId(), result;
  if (typeof renderer == "string") {
    let input = (inputIsArgs ? inputOrArgs[0] : inputOrArgs) || {}, renderContent = content || normalizeDynamicRenderer(input.content);
    if (nextScopeId(), write(`<${renderer}${attrs(input, accessor, scopeId, renderer)}>`), !voidElementsReg.test(renderer)) {
      let renderNativeTag = () => {
        if (renderer === "textarea")
          write(
            controllable_textarea_value(
              scopeId,
              accessor,
              input.value,
              input.valueChange
            )
          );
        else if (renderContent) {
          if (typeof renderContent != "function")
            throw new Error(
              `Body content is not supported for the \`<${renderer}>\` tag.`
            );
          renderer === "select" && ("value" in input || "valueChange" in input) ? controllable_select_value(
            scopeId,
            accessor,
            input.value,
            input.valueChange,
            renderContent
          ) : renderContent();
        }
      };
      shouldResume ? withBranchId(branchId, renderNativeTag) : renderNativeTag(), write(`</${renderer}>`);
    }
    shouldResume && write(
      state.mark(
        "|" /* BranchSingleNode */,
        scopeId + " " + accessor + " " + branchId
      )
    );
  } else {
    shouldResume && write(state.mark("[" /* BranchStart */, branchId + ""));
    let render2 = () => {
      if (renderer) {
        if (isTemplate(renderer)) {
          let input = inputIsArgs ? inputOrArgs[0] : inputOrArgs;
          return renderer(
            content ? { ...input, content } : input,
            shouldResume ? 1 : 0
          );
        }
        return inputIsArgs ? renderer(...inputOrArgs) : renderer(
          content ? { ...inputOrArgs, content } : inputOrArgs
        );
      } else if (content)
        return content();
    };
    result = shouldResume ? withBranchId(branchId, render2) : render2(), shouldResume && write(state.mark("]" /* BranchEnd */, scopeId + " " + accessor));
  }
  return peekNextScopeId() !== branchId ? shouldResume && writeScope(scopeId, {
    ["d" /* ConditionalScope */ + accessor]: writeScope(branchId, {}),
    ["c" /* ConditionalRenderer */ + accessor]: renderer?.h || renderer
  }) : nextScopeId(), result;
};
function createContent(id, fn) {
  return fn.h = id, fn;
}
function registerContent(id, fn, scopeId) {
  return register2(createContent(id, fn), id, scopeId);
}
function patchDynamicTag(patch) {
  dynamicTag = /* @__PURE__ */ ((originalDynamicTag) => (scopeId, accessor, tag, input, content, inputIsArgs, resume) => {
    let patched = patch(scopeId, accessor, tag);
    return patched.h = tag, originalDynamicTag(
      scopeId,
      accessor,
      patched,
      input,
      content,
      inputIsArgs,
      resume
    );
  })(dynamicTag);
}

// src/html/compat.ts
var K_TAGS_API_STATE = Symbol(), COMPAT_REGISTRY = /* @__PURE__ */ new WeakMap(), compat = {
  fork,
  write,
  writeScript,
  nextScopeId,
  isTagsAPI(fn) {
    return !!fn.h;
  },
  patchDynamicTag,
  writeSetScopeForComponent(m5c) {
    let scopeId = nextScopeId();
    writeScope(scopeId, { m5c }), writeEffect(scopeId, SET_SCOPE_REGISTER_ID);
  },
  toJSON() {
    let compatRegistered = COMPAT_REGISTRY.get(this);
    if (!compatRegistered) {
      let registered = getRegistered(this);
      if (registered) {
        let scopeId = getScopeId(registered.scope);
        scopeId !== void 0 && writeScope(scopeId, {}), COMPAT_REGISTRY.set(
          this,
          compatRegistered = [registered.id, scopeId]
        );
      }
    }
    return compatRegistered;
  },
  render(renderer, willRerender, classAPIOut, component, input) {
    let $global2 = classAPIOut.global, state = $global2[K_TAGS_API_STATE] ||= getChunk()?.boundary.state;
    state || ($global2.runtimeId ||= DEFAULT_RUNTIME_ID, $global2.renderId ||= $global2.componentIdPrefix || DEFAULT_RENDER_ID, $global2[K_TAGS_API_STATE] = state = new State2($global2));
    let boundary = new Boundary(state), head = new Chunk(
      boundary,
      null,
      null
    ), normalizedInput = input;
    if ("renderBody" in input) {
      normalizedInput = {};
      for (let key in input)
        normalizedInput[key === "renderBody" ? "content" : key] = input[key];
    }
    head.render(() => {
      if (willRerender) {
        let scopeId = peekNextScopeId();
        writeScope(scopeId, { m5c: component.id }), writeEffect(scopeId, SET_SCOPE_REGISTER_ID);
      }
      isTemplate(renderer) && willRerender ? renderer(normalizedInput, 1) : renderer(normalizedInput);
    });
    let asyncOut = classAPIOut.beginAsync();
    queueMicrotask(
      boundary.onNext = () => {
        if (boundary.signal.aborted)
          asyncOut.error(boundary.signal.reason);
        else if (boundary.done) {
          let { scripts, html } = head.consume().flushScript();
          asyncOut.script(scripts), asyncOut.write(html), asyncOut.end();
        }
      }
    );
  },
  registerRenderer(renderer, id) {
    return register(
      RENDERER_REGISTER_ID,
      renderer,
      register(id, () => {
      })
    );
  },
  registerRenderBody(fn) {
    register(RENDER_BODY_ID, fn);
  }
};
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  $global,
  attr,
  attrTag,
  attrTags,
  attrs,
  classAttr,
  commentSeparator,
  compat,
  controllable_detailsOrDialog_open,
  controllable_input_checked,
  controllable_input_checkedValue,
  controllable_input_value,
  controllable_select_value,
  controllable_textarea_value,
  createContent,
  createTemplate,
  dynamicTag,
  ensureScopeWithId,
  escapeScript,
  escapeStyle,
  escapeXML,
  forIn,
  forInBy,
  forOf,
  forOfBy,
  forTo,
  forToBy,
  fork,
  getScopeById,
  hoist,
  markResumeNode,
  nextScopeId,
  nextTagId,
  nodeRef,
  optionValueAttr,
  partialAttrs,
  peekNextScopeId,
  register,
  registerContent,
  resumeClosestBranch,
  resumeConditional,
  resumeForIn,
  resumeForOf,
  resumeForTo,
  serializeGuard,
  serializeIf,
  setTagVar,
  styleAttr,
  toString,
  tryContent,
  write,
  writeAttrsAndContent,
  writeContent,
  writeEffect,
  writeExistingScope,
  writePartialAttrsAndContent,
  writeScope,
  writeSubscribe,
  writeTrailers
});
