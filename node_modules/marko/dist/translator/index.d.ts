import type { Config } from "@marko/compiler";
export declare const tagDiscoveryDirs: string[];
export { default as internalEntryBuilder } from "./util/entry-builder";
export declare const preferAPI = "tags";
export declare const transform: import("@marko/compiler/babel-types").Visitor<unknown>, analyze: import("@marko/compiler/babel-types").Visitor<unknown>, translate: import("@marko/compiler/babel-types").Visitor<unknown>;
export declare const taglibs: (string | {
    migrate: import("@marko/compiler/babel-types").Visitor<unknown>;
    taglibId: string;
    "<attrs>": import("@marko/compiler/babel-utils").Tag;
    "<await>": import("@marko/compiler/babel-utils").Tag;
    "<client>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<const>": import("@marko/compiler/babel-utils").Tag;
    "<debug>": import("@marko/compiler/babel-utils").Tag;
    "<define>": import("@marko/compiler/babel-utils").Tag;
    "<effect>": import("@marko/compiler/babel-utils").Tag;
    "<else-if>": {
        autocomplete: {
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        }[];
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
    };
    "<else>": {
        autocomplete: {
            description: string;
            descriptionMoreURL: string;
        }[];
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
    };
    "<export>": import("@marko/compiler/babel-utils").Tag;
    "<for>": {
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
        attributes: {
            of: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            in: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            to: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            from: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            step: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
        };
        autocomplete: ({
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        } | {
            snippet: string;
            descriptionMoreURL: string;
            description?: undefined;
        })[];
    };
    "<html-comment>": import("@marko/compiler/babel-utils").Tag;
    "<html-script>": import("@marko/compiler/babel-utils").Tag;
    "<html-style>": import("@marko/compiler/babel-utils").Tag;
    "<id>": import("@marko/compiler/babel-utils").Tag;
    "<if>": {
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
        autocomplete: {
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<import>": import("@marko/compiler/babel-utils").Tag;
    "<let>": import("@marko/compiler/babel-utils").Tag;
    "<lifecycle>": import("@marko/compiler/babel-utils").Tag;
    "<log>": import("@marko/compiler/babel-utils").Tag;
    "<return>": import("@marko/compiler/babel-utils").Tag;
    "<script>": import("@marko/compiler/babel-utils").Tag;
    "<server>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<static>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<style>": import("@marko/compiler/babel-utils").Tag;
    "<try>": import("@marko/compiler/babel-utils").Tag;
})[][];
export declare function getRuntimeEntryFiles(output: Config["output"], optimize: boolean): string[];
declare module "@marko/compiler/dist/types" {
    interface ProgramExtra {
    }
    interface FunctionExpressionExtra {
    }
    interface ArrowFunctionExpressionExtra {
    }
    interface MarkoTagExtra {
    }
    interface MarkoTagBodyExtra {
    }
    interface MarkoAttributeExtra {
    }
    interface MarkoSpreadAttributeExtra {
    }
    interface MarkoPlaceholderExtra {
    }
    interface Program {
        extra: ProgramExtra & NodeExtra;
    }
    interface FunctionDeclaration {
        extra?: FunctionDeclarationExtra & NodeExtra;
    }
    interface FunctionExpression {
        extra?: FunctionExpressionExtra & NodeExtra;
    }
    interface ArrowFunctionExpression {
        extra?: ArrowFunctionExpressionExtra & NodeExtra;
    }
    interface MarkoTag {
        extra?: MarkoTagExtra & NodeExtra;
    }
    interface MarkoTagBody {
        extra?: MarkoTagBodyExtra & NodeExtra;
    }
    interface MarkoAttribute {
        extra?: MarkoAttributeExtra & NodeExtra;
    }
    interface MarkoSpreadAttribute {
        extra?: MarkoSpreadAttributeExtra & NodeExtra;
    }
    interface MarkoPlaceholder {
        extra?: MarkoPlaceholderExtra & NodeExtra;
    }
}
