import { types as t } from "@marko/compiler";
import { type Binding, type Sources } from "../../util/references";
export type InputSerializeReason = NonNullable<Sources["input"]>;
export type InputSerializeReasons = [
    InputSerializeReason,
    ...InputSerializeReason[]
];
export declare let cleanIdentifier: t.Identifier;
export declare let scopeIdentifier: t.Identifier;
export declare function isScopeIdentifier(node: t.Node): node is t.Identifier;
export type TemplateExport = {
    id: string;
    binding: Binding;
    props: {
        [prop: string]: TemplateExport;
    } | undefined;
};
export type TemplateExports = TemplateExport["props"];
declare module "@marko/compiler/dist/types" {
    interface ProgramExtra {
        inputSerializeReasons?: InputSerializeReasons;
        returnSerializeReason?: InputSerializeReason | true;
        returnValueExpr?: t.NodeExtra;
        domExports?: {
            template: string;
            walks: string;
            setup: string;
            input: TemplateExport | undefined;
        };
    }
}
declare const _default: {
    migrate: {
        enter(this: unknown, program: t.NodePath<t.Program>): void;
        exit(this: unknown, program: t.NodePath<t.Program>): void;
    };
    analyze: {
        enter(this: unknown, program: t.NodePath<t.Program>): void;
        exit(this: unknown, program: t.NodePath<t.Program>): void;
    };
    translate: {
        enter(this: unknown, program: t.NodePath<t.Program>): void;
        exit(this: unknown, program: t.NodePath<t.Program>): void;
    };
};
export default _default;
export declare function resolveSerializeReasonId(inputSerializeReasons: InputSerializeReasons, reason: InputSerializeReason): number;
