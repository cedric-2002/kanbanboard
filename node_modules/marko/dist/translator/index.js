"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name2 in all)
    __defProp(target, name2, { get: all[name2], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/translator/index.ts
var index_exports = {};
__export(index_exports, {
  analyze: () => analyze,
  getRuntimeEntryFiles: () => getRuntimeEntryFiles,
  internalEntryBuilder: () => entry_builder_default,
  preferAPI: () => preferAPI,
  tagDiscoveryDirs: () => tagDiscoveryDirs,
  taglibs: () => taglibs,
  transform: () => transform,
  translate: () => translate
});
module.exports = __toCommonJS(index_exports);

// src/translator/util/runtime-info.ts
var import_package = require("../../package.json");
var runtime_info_default = {
  name: import_package.name,
  taglibId: "marko-core"
};

// src/translator/core/attrs.ts
var import_compiler = require("@marko/compiler");
var import_babel_utils = require("@marko/compiler/babel-utils");

// src/translator/util/assert.ts
function assertNoSpreadAttrs(tag) {
  for (const attr2 of tag.get("attributes")) {
    if (attr2.isMarkoSpreadAttribute()) {
      throw attr2.buildCodeFrameError(
        `The \`${tag.get("name").node.value}\` tag does not support \`...spread\` attributes.`
      );
    }
  }
}
function assertNoBodyContent(tag) {
  if (tag.node.body.body.length) {
    throw tag.get("name").buildCodeFrameError(
      `The \`${tag.get("name").node.value}\` tag does not support body content.`
    );
  }
}

// src/translator/core/attrs.ts
var attrs_default = {
  migrate: [
    (tag) => {
      (0, import_babel_utils.assertNoArgs)(tag);
      (0, import_babel_utils.assertNoParams)(tag);
      (0, import_babel_utils.assertNoAttributes)(tag);
      assertNoBodyContent(tag);
      (0, import_babel_utils.assertNoAttributeTags)(tag);
      (0, import_babel_utils.diagnosticDeprecate)(tag, {
        label: "The `attrs` tag is deprecated, prefer destructuring `input` via the `const` tag.",
        fix() {
          const tagVar = tag.node.var;
          if (tagVar && !(tagVar.type === "Identifier" && tagVar.name === "input")) {
            const constTag = import_compiler.types.markoTag(
              import_compiler.types.stringLiteral("const"),
              [import_compiler.types.markoAttribute("value", import_compiler.types.identifier("input"))],
              import_compiler.types.markoTagBody([])
            );
            constTag.var = tagVar;
            tag.replaceWith(constTag);
          } else {
            tag.remove();
          }
        }
      });
    }
  ],
  attributes: {},
  autocomplete: [
    {
      displayText: "attrs/{ ... }",
      description: "Use to receive the attributes passed into this template.",
      snippet: "attrs/{ $1 }$2"
    }
  ]
};

// src/translator/core/await.ts
var import_compiler25 = require("@marko/compiler");
var import_babel_utils18 = require("@marko/compiler/babel-utils");

// src/common/accessor.debug.ts
var AccessorPrefix = /* @__PURE__ */ ((AccessorPrefix4) => {
  AccessorPrefix4["ClosureScopes"] = "ClosureScopes:";
  AccessorPrefix4["ClosureSignalIndex"] = "ClosureSignalIndex:";
  AccessorPrefix4["ConditionalRenderer"] = "ConditionalRenderer:";
  AccessorPrefix4["ConditionalScope"] = "ConditionalScope:";
  AccessorPrefix4["ControlledHandler"] = "ControlledHandler:";
  AccessorPrefix4["ControlledType"] = "ControlledType:";
  AccessorPrefix4["ControlledValue"] = "ControlledValue:";
  AccessorPrefix4["DynamicPlaceholderLastChild"] = "DynamicPlaceholderLastChild:";
  AccessorPrefix4["EventAttributes"] = "EventAttributes:";
  AccessorPrefix4["Getter"] = "Getter:";
  AccessorPrefix4["LifecycleAbortController"] = "LifecycleAbortController:";
  AccessorPrefix4["LoopScopeArray"] = "LoopScopeArray:";
  AccessorPrefix4["LoopScopeMap"] = "LoopScopeMap:";
  AccessorPrefix4["Promise"] = "Promise:";
  AccessorPrefix4["TagVariableChange"] = "TagVariableChange:";
  return AccessorPrefix4;
})(AccessorPrefix || {});
var AccessorProp = /* @__PURE__ */ ((AccessorProp4) => {
  AccessorProp4["Owner"] = "_";
  AccessorProp4["BranchAccessor"] = "#BranchAccessor";
  AccessorProp4["CatchContent"] = "#CatchContent";
  AccessorProp4["PlaceholderBranch"] = "#PlaceholderBranch";
  AccessorProp4["PlaceholderContent"] = "#PlaceholderContent";
  AccessorProp4["TagVariable"] = "#TagVariable";
  AccessorProp4["TagVariableChange"] = "#TagVariableChange";
  AccessorProp4["ClosestBranchId"] = "#ClosestBranchId";
  return AccessorProp4;
})(AccessorProp || {});

// src/translator/util/evaluate.ts
var import_babel_utils2 = require("@marko/compiler/babel-utils");
function evaluate(value) {
  let { extra } = value;
  if (!extra) {
    extra = value.extra = {};
  }
  if (extra.confident === void 0) {
    const computed = (0, import_babel_utils2.computeNode)(value);
    if (computed) {
      extra.computed = computed.value;
      extra.confident = true;
      extra.nullable = computed.value == null;
    } else {
      extra.computed = void 0;
      extra.confident = false;
      extra.nullable = isNullableExpr(value);
    }
  }
  return extra;
}
function isNullableExpr(expr) {
  switch (expr.type) {
    case "ArrayExpression":
    case "ArrowFunctionExpression":
    case "BigIntLiteral":
    case "BinaryExpression":
    case "BooleanLiteral":
    case "ClassExpression":
    case "FunctionExpression":
    case "NewExpression":
    case "NumericLiteral":
    case "ObjectExpression":
    case "RegExpLiteral":
    case "StringLiteral":
    case "TemplateLiteral":
    case "UpdateExpression":
      return false;
    case "AssignmentExpression":
      switch (expr.operator) {
        case "=":
          return isNullableExpr(expr.right);
        case "*=":
        case "/=":
        case "%=":
        case "+=":
        case "-=":
        case "<<=":
        case ">>=":
        case ">>>=":
        case "&=":
        case "^=":
        case "|=":
        case "**=":
          return false;
        case "||=":
        case "??=":
          return isNullableExpr(expr.right) || isNullableExpr(expr.left);
        case "&&=":
          return isNullableExpr(expr.left) && isNullableExpr(expr.right);
        default:
          return true;
      }
    case "AwaitExpression":
      return isNullableExpr(expr.argument);
    case "ConditionalExpression":
      return isNullableExpr(expr.consequent) && isNullableExpr(expr.alternate);
    case "LogicalExpression":
      switch (expr.operator) {
        case "||":
        case "??":
          return isNullableExpr(expr.right) || isNullableExpr(expr.left);
        case "&&":
          return isNullableExpr(expr.left) && isNullableExpr(expr.right);
        default:
          return true;
      }
    case "ParenthesizedExpression":
      return isNullableExpr(expr.expression);
    case "SequenceExpression":
      return isNullableExpr(expr.expressions[expr.expressions.length - 1]);
    case "UnaryExpression":
      return expr.operator === "void";
    default:
      return true;
  }
}

// src/translator/util/references.ts
var import_compiler24 = require("@marko/compiler");
var import_babel_utils17 = require("@marko/compiler/babel-utils");

// src/html/serializer.ts
var kTouchedIterator = Symbol();
var { hasOwnProperty } = {};
var Generator = function* () {
}().constructor;
var AsyncGenerator = async function* () {
}().constructor;
patchIteratorNext(Generator.prototype);
patchIteratorNext(AsyncGenerator.prototype);
var KNOWN_SYMBOLS = (() => {
  const KNOWN_SYMBOLS2 = /* @__PURE__ */ new Map();
  for (const name2 of Object.getOwnPropertyNames(Symbol)) {
    const symbol = Symbol[name2];
    if (typeof symbol === "symbol") {
      KNOWN_SYMBOLS2.set(symbol, "Symbol." + name2);
    }
  }
  return KNOWN_SYMBOLS2;
})();
var KNOWN_FUNCTIONS = /* @__PURE__ */ new Map([
  // This is by no means an exhaustive list,
  // but it should cover most of the built-in functions.
  [AggregateError, "AggregateError"],
  [Array, "Array"],
  [Array.from, "Array.from"],
  [Array.isArray, "Array.isArray"],
  [Array.of, "Array.of"],
  [ArrayBuffer, "ArrayBuffer"],
  [ArrayBuffer.isView, "ArrayBuffer.isView"],
  [Atomics.add, "Atomics.add"],
  [Atomics.and, "Atomics.and"],
  [Atomics.compareExchange, "Atomics.compareExchange"],
  [Atomics.exchange, "Atomics.exchange"],
  [Atomics.isLockFree, "Atomics.isLockFree"],
  [Atomics.load, "Atomics.load"],
  [Atomics.notify, "Atomics.notify"],
  [Atomics.or, "Atomics.or"],
  [Atomics.store, "Atomics.store"],
  [Atomics.sub, "Atomics.sub"],
  [Atomics.wait, "Atomics.wait"],
  [BigInt, "BigInt"],
  [BigInt.asIntN, "BigInt.asIntN"],
  [BigInt.asUintN, "BigInt.asUintN"],
  [BigInt64Array, "BigInt64Array"],
  [BigInt64Array.from, "BigInt64Array.from"],
  [BigInt64Array.of, "BigInt64Array.of"],
  [BigUint64Array, "BigUint64Array"],
  [BigUint64Array.from, "BigUint64Array.from"],
  [BigUint64Array.of, "BigUint64Array.of"],
  [Boolean, "Boolean"],
  [console.assert, "console.assert"],
  [console.clear, "console.clear"],
  [console.count, "console.count"],
  [console.countReset, "console.countReset"],
  [console.debug, "console.debug"],
  [console.dir, "console.dir"],
  [console.dirxml, "console.dirxml"],
  [console.error, "console.error"],
  [console.group, "console.group"],
  [console.groupCollapsed, "console.groupCollapsed"],
  [console.groupEnd, "console.groupEnd"],
  [console.info, "console.info"],
  [console.log, "console.log"],
  [console.table, "console.table"],
  [console.time, "console.time"],
  [console.timeEnd, "console.timeEnd"],
  [console.timeLog, "console.timeLog"],
  [console.timeStamp, "console.timeStamp"],
  [console.trace, "console.trace"],
  [console.warn, "console.warn"],
  [DataView, "DataView"],
  [Date, "Date"],
  [Date.now, "Date.now"],
  [Date.parse, "Date.parse"],
  [Date.UTC, "Date.UTC"],
  [decodeURI, "decodeURI"],
  [decodeURIComponent, "decodeURIComponent"],
  [encodeURI, "encodeURI"],
  [encodeURIComponent, "encodeURIComponent"],
  [Error, "Error"],
  [EvalError, "EvalError"],
  [Float32Array, "Float32Array"],
  [Float32Array.from, "Float32Array.from"],
  [Float32Array.of, "Float32Array.of"],
  [Float64Array, "Float64Array"],
  [Float64Array.from, "Float64Array.from"],
  [Float64Array.of, "Float64Array.of"],
  [Function, "Function"],
  [globalThis.atob, "atob"],
  [globalThis.btoa, "btoa"],
  [globalThis.clearImmediate, "clearImmediate"],
  [globalThis.clearInterval, "clearInterval"],
  [globalThis.clearTimeout, "clearTimeout"],
  [globalThis.crypto?.getRandomValues, "crypto.getRandomValues"],
  [globalThis.crypto?.randomUUID, "crypto.randomUUID"],
  [globalThis.fetch, "fetch"],
  [globalThis.performance?.now, "performance.now"],
  [globalThis.queueMicrotask, "queueMicrotask"],
  [globalThis.setImmediate, "setImmediate"],
  [globalThis.setInterval, "setInterval"],
  [globalThis.setTimeout, "setTimeout"],
  [globalThis.structuredClone, "structuredClone"],
  [globalThis.URL, "URL"],
  [globalThis.URLSearchParams, "URLSearchParams"],
  [globalThis.WritableStream, "WritableStream"],
  [Int16Array, "Int16Array"],
  [Int16Array.from, "Int16Array.from"],
  [Int16Array.of, "Int16Array.of"],
  [Int32Array, "Int32Array"],
  [Int32Array.from, "Int32Array.from"],
  [Int32Array.of, "Int32Array.of"],
  [Int8Array, "Int8Array"],
  [Int8Array.from, "Int8Array.from"],
  [Int8Array.of, "Int8Array.of"],
  [Intl.Collator, "Intl.Collator"],
  [Intl.DateTimeFormat, "Intl.DateTimeFormat"],
  [Intl.DisplayNames, "Intl.DisplayNames"],
  [Intl.getCanonicalLocales, "Intl.getCanonicalLocales"],
  [Intl.ListFormat, "Intl.ListFormat"],
  [Intl.Locale, "Intl.Locale"],
  [Intl.NumberFormat, "Intl.NumberFormat"],
  [Intl.PluralRules, "Intl.PluralRules"],
  [Intl.RelativeTimeFormat, "Intl.RelativeTimeFormat"],
  [Intl.Segmenter, "Intl.Segmenter"],
  [Intl.supportedValuesOf, "Intl.supportedValuesOf"],
  [isFinite, "isFinite"],
  [isNaN, "isNaN"],
  [JSON.parse, "JSON.parse"],
  [JSON.stringify, "JSON.stringify"],
  [Map, "Map"],
  [Map.groupBy, "Map.groupBy"],
  [Math.abs, "Math.abs"],
  [Math.acos, "Math.acos"],
  [Math.acosh, "Math.acosh"],
  [Math.asin, "Math.asin"],
  [Math.asinh, "Math.asinh"],
  [Math.atan, "Math.atan"],
  [Math.atan2, "Math.atan2"],
  [Math.atanh, "Math.atanh"],
  [Math.cbrt, "Math.cbrt"],
  [Math.ceil, "Math.ceil"],
  [Math.clz32, "Math.clz32"],
  [Math.cos, "Math.cos"],
  [Math.cosh, "Math.cosh"],
  [Math.exp, "Math.exp"],
  [Math.expm1, "Math.expm1"],
  [Math.floor, "Math.floor"],
  [Math.fround, "Math.fround"],
  [Math.hypot, "Math.hypot"],
  [Math.imul, "Math.imul"],
  [Math.log, "Math.log"],
  [Math.log10, "Math.log10"],
  [Math.log1p, "Math.log1p"],
  [Math.log2, "Math.log2"],
  [Math.max, "Math.max"],
  [Math.min, "Math.min"],
  [Math.pow, "Math.pow"],
  [Math.random, "Math.random"],
  [Math.round, "Math.round"],
  [Math.sign, "Math.sign"],
  [Math.sin, "Math.sin"],
  [Math.sinh, "Math.sinh"],
  [Math.sqrt, "Math.sqrt"],
  [Math.tan, "Math.tan"],
  [Math.tanh, "Math.tanh"],
  [Math.trunc, "Math.trunc"],
  [Number, "Number"],
  [Number.isFinite, "Number.isFinite"],
  [Number.isInteger, "Number.isInteger"],
  [Number.isNaN, "Number.isNaN"],
  [Number.isSafeInteger, "Number.isSafeInteger"],
  [Number.parseFloat, "Number.parseFloat"],
  [Number.parseInt, "Number.parseInt"],
  [Object, "Object"],
  [Object.assign, "Object.assign"],
  [Object.create, "Object.create"],
  [Object.defineProperties, "Object.defineProperties"],
  [Object.defineProperty, "Object.defineProperty"],
  [Object.entries, "Object.entries"],
  [Object.freeze, "Object.freeze"],
  [Object.fromEntries, "Object.fromEntries"],
  [Object.getOwnPropertyDescriptor, "Object.getOwnPropertyDescriptor"],
  [Object.getOwnPropertyDescriptors, "Object.getOwnPropertyDescriptors"],
  [Object.getOwnPropertyNames, "Object.getOwnPropertyNames"],
  [Object.getOwnPropertySymbols, "Object.getOwnPropertySymbols"],
  [Object.getPrototypeOf, "Object.getPrototypeOf"],
  [Object.is, "Object.is"],
  [Object.isExtensible, "Object.isExtensible"],
  [Object.isFrozen, "Object.isFrozen"],
  [Object.isSealed, "Object.isSealed"],
  [Object.keys, "Object.keys"],
  [Object.preventExtensions, "Object.preventExtensions"],
  [Object.seal, "Object.seal"],
  [Object.setPrototypeOf, "Object.setPrototypeOf"],
  [Object.values, "Object.values"],
  [parseFloat, "parseFloat"],
  [parseInt, "parseInt"],
  [Promise, "Promise"],
  [Proxy, "Proxy"],
  [RangeError, "RangeError"],
  [ReferenceError, "ReferenceError"],
  [Reflect.apply, "Reflect.apply"],
  [Reflect.construct, "Reflect.construct"],
  [Reflect.defineProperty, "Reflect.defineProperty"],
  [Reflect.deleteProperty, "Reflect.deleteProperty"],
  [Reflect.get, "Reflect.get"],
  [Reflect.getOwnPropertyDescriptor, "Reflect.getOwnPropertyDescriptor"],
  [Reflect.getPrototypeOf, "Reflect.getPrototypeOf"],
  [Reflect.has, "Reflect.has"],
  [Reflect.isExtensible, "Reflect.isExtensible"],
  [Reflect.ownKeys, "Reflect.ownKeys"],
  [Reflect.preventExtensions, "Reflect.preventExtensions"],
  [Reflect.set, "Reflect.set"],
  [Reflect.setPrototypeOf, "Reflect.setPrototypeOf"],
  [RegExp, "RegExp"],
  [Set, "Set"],
  [String, "String"],
  [String.fromCharCode, "String.fromCharCode"],
  [String.fromCodePoint, "String.fromCodePoint"],
  [String.raw, "String.raw"],
  [Symbol, "Symbol"],
  [Symbol.for, "Symbol.for"],
  [SyntaxError, "SyntaxError"],
  [TypeError, "TypeError"],
  [Uint16Array, "Uint16Array"],
  [Uint16Array.from, "Uint16Array.from"],
  [Uint16Array.of, "Uint16Array.of"],
  [Uint32Array, "Uint32Array"],
  [Uint32Array.from, "Uint32Array.from"],
  [Uint32Array.of, "Uint32Array.of"],
  [Uint8Array, "Uint8Array"],
  [Uint8Array.from, "Uint8Array.from"],
  [Uint8Array.of, "Uint8Array.of"],
  [Uint8ClampedArray, "Uint8ClampedArray"],
  [Uint8ClampedArray.from, "Uint8ClampedArray.from"],
  [Uint8ClampedArray.of, "Uint8ClampedArray.of"],
  [URIError, "URIError"],
  [WeakMap, "WeakMap"],
  [WeakSet, "WeakSet"]
]);
var KNOWN_OBJECTS = /* @__PURE__ */ new Map([
  [Atomics, "Atomics"],
  [console, "console"],
  [globalThis, "globalThis"],
  [globalThis.crypto, "crypto"],
  [Intl, "Intl"],
  [JSON, "JSON"],
  [Math, "Math"],
  [Reflect, "Reflect"]
]);
function toAccess(accessor) {
  const start = accessor[0];
  return start === '"' || start >= "0" && start <= "9" ? "[" + accessor + "]" : "." + accessor;
}
function patchIteratorNext(proto) {
  const { next } = proto;
  proto.next = function(value) {
    this[kTouchedIterator] = 1;
    return next.call(this, value);
  };
}

// src/translator/util/for-each-identifier.ts
function forEachIdentifier(node, cb) {
  switch (node.type) {
    case "ObjectPattern":
      for (const prop of node.properties) {
        switch (prop.type) {
          case "ObjectProperty":
            if (prop.value.type === "AssignmentPattern") {
              forEachIdentifier(prop.value.left, cb);
            } else {
              forEachIdentifier(prop.value, cb);
            }
            break;
          case "RestElement":
            forEachIdentifier(prop.argument, cb);
            break;
        }
      }
      break;
    case "ArrayPattern":
      for (const el of node.elements) {
        if (el != null) {
          switch (el.type) {
            case "RestElement":
              forEachIdentifier(el.argument, cb);
              break;
            case "AssignmentPattern":
              forEachIdentifier(el.left, cb);
              break;
            default:
              forEachIdentifier(el, cb);
              break;
          }
        }
      }
      break;
    case "Identifier":
      cb(node);
      break;
  }
}
function forEachIdentifierPath(nodePath, cb) {
  if (nodePath.isIdentifier()) {
    cb(nodePath);
  } else if (nodePath.isObjectPattern()) {
    for (const prop of nodePath.get("properties")) {
      if (prop.isObjectProperty()) {
        const value = prop.get("value");
        if (value.isAssignmentPattern()) {
          forEachIdentifierPath(value.get("left"), cb);
        } else {
          forEachIdentifierPath(value, cb);
        }
      } else if (prop.isRestElement()) {
        forEachIdentifierPath(prop.get("argument"), cb);
      }
    }
  } else if (nodePath.isArrayPattern()) {
    for (const el of nodePath.get("elements")) {
      if (el) {
        if (el.isRestElement()) {
          forEachIdentifierPath(el.get("argument"), cb);
        } else if (el.isAssignmentPattern()) {
          forEachIdentifierPath(el.get("left"), cb);
        } else {
          forEachIdentifierPath(el, cb);
        }
      }
    }
  }
}

// src/translator/util/generate-uid.ts
var import_compiler3 = require("@marko/compiler");
var import_babel_utils4 = require("@marko/compiler/babel-utils");

// src/translator/util/get-compile-stage.ts
var import_babel_utils3 = require("@marko/compiler/babel-utils");
function getCompileStage() {
  return (0, import_babel_utils3.getFile)().___compileStage;
}
function isTranslate() {
  return getCompileStage() === "translate" /* translate */;
}

// src/translator/util/traverse.ts
var import_compiler2 = require("@marko/compiler");
var skip = Symbol("skip");
function traverseReplace(container, key, enter3) {
  const node = container[key];
  if (node) {
    if (Array.isArray(node)) {
      for (let i = node.length; i--; ) {
        traverseReplace(node, i, enter3);
      }
    } else {
      const keys = import_compiler2.types.VISITOR_KEYS[node.type];
      for (let i = keys.length; i--; ) {
        traverseReplace(node, keys[i], enter3);
      }
      const replacement = enter3(node, container, key);
      if (replacement) container[key] = replacement;
    }
  }
}
function traverseContains(node, check) {
  if (node) {
    if (Array.isArray(node)) {
      for (const item of node) {
        if (traverseContains(item, check)) {
          return true;
        }
      }
    } else {
      switch (check(node)) {
        case true:
          return true;
        case skip:
          return false;
      }
      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {
        if (traverseContains(node[key], check)) {
          return true;
        }
      }
    }
  }
  return false;
}
function traverse(visit2, node, parent, grandParent) {
  if (node) {
    if (Array.isArray(node)) {
      for (const item of node) {
        traverse(visit2, item, parent, grandParent);
      }
    } else if (visit2(node, parent, grandParent) !== skip) {
      for (const key of import_compiler2.types.VISITOR_KEYS[node.type]) {
        traverse(visit2, node[key], node, parent);
      }
    }
  }
}

// src/translator/util/generate-uid.ts
var countsForFile = /* @__PURE__ */ new WeakMap();
function generateUid(name2 = "") {
  const file = (0, import_babel_utils4.getFile)();
  let counts = countsForFile.get(file);
  if (!counts) {
    const { cache } = file.markoOpts;
    const { filename } = file.opts;
    const cacheKey = `uid-counts:${filename}`;
    counts = cache.get(cacheKey);
    if (counts) {
      if (isTranslate()) {
        counts = new Map(counts);
      }
    } else {
      counts = getInitialCounts(file);
      if (!isTranslate()) {
        cache.set(cacheKey, counts);
      }
    }
    countsForFile.set(file, counts);
  }
  name2 = name2.replace(/^[^a-z$_]|[^a-z$_0-9]/gi, "") || "temp";
  name2 = /^\$?(.*?)\d*$/.exec(name2)?.[1] || name2;
  const i = (counts.get(name2) || 0) + 1;
  const uniqueName = `$${i > 1 ? name2 + i : name2}`;
  counts.set(name2, i);
  return uniqueName;
}
function generateUidIdentifier(name2) {
  return import_compiler3.types.identifier(generateUid(name2));
}
var sharedUIDsForFile = /* @__PURE__ */ new WeakMap();
function getSharedUid(name2) {
  const file = (0, import_babel_utils4.getFile)();
  let sharedUIDs = sharedUIDsForFile.get(file);
  if (!sharedUIDs) {
    const { cache } = file.markoOpts;
    const { filename } = file.opts;
    const cacheKey = `uid-shared:${filename}`;
    sharedUIDs = cache.get(cacheKey);
    if (sharedUIDs) {
      if (isTranslate()) {
        sharedUIDs = new Map(sharedUIDs);
      }
    } else {
      sharedUIDs = /* @__PURE__ */ new Map();
      if (!isTranslate()) {
        cache.set(cacheKey, sharedUIDs);
      }
    }
    sharedUIDsForFile.set(file, sharedUIDs);
  }
  let uniqueName = sharedUIDs.get(name2);
  if (!uniqueName) {
    uniqueName = generateUid(name2);
    sharedUIDs.set(name2, uniqueName);
  }
  return uniqueName;
}
function usedSharedUid(name2) {
  return !!sharedUIDsForFile.get((0, import_babel_utils4.getFile)())?.has(name2);
}
function getInitialCounts(file) {
  const counts = /* @__PURE__ */ new Map();
  const program = file.path;
  const countName = (name2) => {
    const match = /^$(.*?)([1-9]\d*)?$/.exec(name2);
    if (match) {
      const name3 = match[1];
      const count = match[2] ? +match[2] + 1 : 1;
      counts.set(name3, Math.max(counts.get(name3) || 0, count));
    }
  };
  for (const name2 in program.scope.globals) {
    countName(name2);
  }
  traverse((node, parent, grandParent) => {
    if (node.type === "Identifier" && import_compiler3.types.isBinding(node, parent, grandParent)) {
      countName(node.name);
    }
  }, program.node);
  return counts;
}

// src/common/accessor.ts
var AccessorPrefix2 = /* @__PURE__ */ ((AccessorPrefix4) => {
  AccessorPrefix4["ClosureScopes"] = "a";
  AccessorPrefix4["ClosureSignalIndex"] = "b";
  AccessorPrefix4["ConditionalRenderer"] = "c";
  AccessorPrefix4["ConditionalScope"] = "d";
  AccessorPrefix4["ControlledHandler"] = "e";
  AccessorPrefix4["ControlledType"] = "f";
  AccessorPrefix4["ControlledValue"] = "g";
  AccessorPrefix4["DynamicPlaceholderLastChild"] = "h";
  AccessorPrefix4["EventAttributes"] = "i";
  AccessorPrefix4["Getter"] = "j";
  AccessorPrefix4["LifecycleAbortController"] = "k";
  AccessorPrefix4["LoopScopeArray"] = "l";
  AccessorPrefix4["LoopScopeMap"] = "m";
  AccessorPrefix4["Promise"] = "n";
  AccessorPrefix4["TagVariableChange"] = "o";
  return AccessorPrefix4;
})(AccessorPrefix2 || {});
var AccessorProp2 = /* @__PURE__ */ ((AccessorProp4) => {
  AccessorProp4["Owner"] = "_";
  AccessorProp4["BranchAccessor"] = "a";
  AccessorProp4["CatchContent"] = "b";
  AccessorProp4["PlaceholderBranch"] = "c";
  AccessorProp4["PlaceholderContent"] = "d";
  AccessorProp4["TagVariable"] = "e";
  AccessorProp4["TagVariableChange"] = "f";
  AccessorProp4["ClosestBranchId"] = "g";
  return AccessorProp4;
})(AccessorProp2 || {});

// src/translator/util/marko-config.ts
var import_babel_utils5 = require("@marko/compiler/babel-utils");
function isOutputHTML() {
  return getMarkoOpts().output === "html";
}
function isOutputDOM() {
  return !isOutputHTML();
}
function getMarkoOpts() {
  return (0, import_babel_utils5.getFile)().markoOpts;
}
function isOptimize() {
  return getMarkoOpts().optimize;
}

// src/translator/util/get-accessor-char.ts
function getAccessorPrefix() {
  return isOptimize() ? AccessorPrefix2 : AccessorPrefix;
}
function getAccessorProp() {
  return isOptimize() ? AccessorProp2 : AccessorProp;
}

// src/translator/util/get-root.ts
function getMarkoRoot(path5) {
  let curPath = path5;
  do
    curPath = curPath.parentPath;
  while (curPath && !isMarko(curPath));
  return curPath;
}
function getExprRoot(path5) {
  let curPath = path5;
  while (!isMarko(curPath.parentPath)) {
    curPath = curPath.parentPath;
  }
  return curPath;
}
function getFnRoot(path5) {
  let curPath = path5;
  let fnPath;
  while (!isMarko(curPath)) {
    if (isFunction(curPath)) {
      fnPath = curPath;
    } else {
      switch (curPath.type) {
        case "CallExpression":
        case "NewExpression":
          fnPath = void 0;
          break;
      }
    }
    const parentPath = curPath.parentPath;
    if (parentPath) {
      curPath = parentPath;
    } else {
      break;
    }
  }
  return fnPath;
}
function isMarko(path5) {
  switch (path5.type) {
    case "MarkoTag":
    case "MarkoTagBody":
    case "MarkoAttribute":
    case "MarkoSpreadAttribute":
    case "MarkoPlaceholder":
    case "MarkoScriptlet":
      return true;
    default:
      return false;
  }
}
function isFunction(path5) {
  switch (path5.type) {
    case "FunctionDeclaration":
      return !path5.node.declare;
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ObjectMethod":
      return true;
    default:
      return false;
  }
}

// src/translator/util/is-invoked-function.ts
var import_compiler4 = require("@marko/compiler");
function isInvokedFunction(expr) {
  let curPath = expr;
  while (curPath) {
    const { parent, node } = curPath;
    switch (parent.type) {
      case "CallExpression":
        return parent.callee === node;
      case "TSNonNullExpression":
        curPath = curPath.parentPath;
        break;
      default:
        return false;
    }
  }
  return false;
}

// src/translator/util/optional.ts
var Sorted = class {
  constructor(compare) {
    this.compare = compare;
  }
  add(data, item) {
    return data ? Array.isArray(data) ? addSorted(this.compare, data, item) : joinRepeatable(this.compare, data, item) : item;
  }
  union(a, b) {
    if (a) {
      if (Array.isArray(a)) {
        if (b) {
          if (Array.isArray(b)) {
            return unionSortedRepeatable(this.compare, a, b);
          } else {
            return addSorted(this.compare, a, b);
          }
        }
        return a;
      }
      if (b) {
        if (Array.isArray(b)) {
          return addSorted(this.compare, b, a);
        }
        return joinRepeatable(this.compare, b, a);
      }
      return a;
    }
    return b;
  }
  find(data, item) {
    if (data) {
      if (Array.isArray(data)) {
        return findSorted(this.compare, data, item);
      } else if (this.compare(data, item) === 0) {
        return data;
      }
    }
  }
  has(data, item) {
    return this.findIndex(data, item) !== -1;
  }
  findIndex(data, item) {
    if (data) {
      if (Array.isArray(data)) {
        return findIndexSorted(this.compare, data, item);
      } else if (this.compare(data, item) === 0) {
        return 0;
      }
    }
    return -1;
  }
  isSuperset(superset, subset) {
    if (!subset) {
      return true;
    }
    if (!Array.isArray(subset)) {
      return this.findIndex(superset, subset) !== -1;
    }
    if (!Array.isArray(superset)) {
      return false;
    }
    const subLen = subset.length;
    const supLen = superset.length;
    if (subLen > supLen) {
      return false;
    }
    for (let i = subLen; i--; ) {
      const supIndex = this.findIndex(superset, subset[i]);
      if (supIndex === -1 || supLen - supIndex <= i) return false;
    }
    return true;
  }
};
function push(data, item) {
  if (data) {
    if (Array.isArray(data)) {
      data.push(item);
      return data;
    }
    return [data, item];
  }
  return item;
}
function concat(a, b) {
  if (a) {
    if (b) {
      if (Array.isArray(a)) {
        return a.concat(b);
      } else if (Array.isArray(b)) {
        return [a, ...b];
      } else {
        return [a, b];
      }
    }
    return a;
  }
  return b;
}
function filter(data, cb) {
  if (data) {
    if (Array.isArray(data)) {
      const len = data.length;
      let result;
      let i = 0;
      while (i < len) {
        let item = data[i++];
        if (cb(item)) {
          result = item;
          while (i < len) {
            item = data[i++];
            if (cb(item)) {
              result = [result, item];
              while (i < len) {
                item = data[i++];
                if (cb(item)) {
                  result.push(item);
                }
              }
              return result;
            }
          }
          return result;
        }
      }
      return result;
    }
    if (cb(data)) {
      return data;
    }
  }
  return void 0;
}
function forEach(data, cb) {
  if (data) {
    if (Array.isArray(data)) {
      let i = 0;
      for (const item of data) {
        cb(item, i++);
      }
    } else {
      cb(data, 0);
    }
  }
}
function fromIter(data) {
  let one;
  let many;
  for (const item of data) {
    if (many) {
      many.push(item);
    } else if (one) {
      many = [one, item];
    } else {
      one = item;
    }
  }
  return many || one;
}
function find(data, cb) {
  if (data) {
    if (Array.isArray(data)) {
      return data.find(cb);
    }
    if (cb(data, 0)) {
      return data;
    }
  }
}
function toArray(data, cb) {
  return data ? Array.isArray(data) ? data.map(cb) : [cb(data, 0)] : [];
}
function mapToString(data, sep, cb) {
  if (data) {
    if (Array.isArray(data)) {
      let str = "";
      let curSep = "";
      for (let i = 0; i < data.length; i++) {
        str += curSep + cb(data[i], i);
        curSep = sep;
      }
      return str;
    }
    return cb(data, 0);
  }
  return "";
}
function filterMap(data, cb) {
  if (data) {
    if (Array.isArray(data)) {
      const len = data.length;
      let result;
      let i = 0;
      while (i < len) {
        let item = cb(data[i++]);
        if (item) {
          result = item;
          while (i < len) {
            item = cb(data[i++]);
            if (item) {
              result = [result, item];
              while (i < len) {
                item = cb(data[i++]);
                if (item) {
                  result.push(item);
                }
              }
              return result;
            }
          }
          return result;
        }
      }
      return result;
    } else {
      return cb(data);
    }
  }
}
function findSorted(compare, data, item) {
  let max = data.length;
  let pos = 0;
  while (pos < max) {
    const mid = pos + max >>> 1;
    const cur = data[mid];
    const compareResult = compare(cur, item);
    if (compareResult === 0) return cur;
    if (compareResult > 0) max = mid;
    else pos = mid + 1;
  }
}
function findIndexSorted(compare, data, item) {
  let max = data.length;
  let pos = 0;
  while (pos < max) {
    const mid = pos + max >>> 1;
    const compareResult = compare(data[mid], item);
    if (compareResult === 0) return mid;
    if (compareResult > 0) max = mid;
    else pos = mid + 1;
  }
  return -1;
}
function addSorted(compare, data, item) {
  const len = data.length;
  let max = len;
  let pos = 0;
  while (pos < max) {
    const mid = pos + max >>> 1;
    const compareResult = compare(data[mid], item);
    if (compareResult === 0) return data;
    if (compareResult > 0) max = mid;
    else pos = mid + 1;
  }
  const result = new Array(len + 1);
  for (let i = 0; i < pos; i++) {
    result[i] = data[i];
  }
  let cur = item;
  while (pos < len) {
    const next = cur;
    cur = data[pos];
    result[pos++] = next;
  }
  result[len] = cur;
  return result;
}
function unionSortedRepeatable(compare, a, b) {
  const aLen = a.length;
  const bLen = b.length;
  let aIndex = 0;
  let bIndex = 0;
  const result = [];
  while (aIndex < aLen && bIndex < bLen) {
    const aValue = a[aIndex];
    const bValue = b[bIndex];
    const delta = compare(aValue, bValue);
    if (delta === 0) {
      aIndex++;
      bIndex++;
      result.push(aValue);
    } else if (delta < 0) {
      aIndex++;
      result.push(aValue);
    } else {
      bIndex++;
      result.push(bValue);
    }
  }
  if (aLen === bLen && aIndex === aLen) {
    return a;
  }
  while (aIndex < aLen) {
    result.push(a[aIndex++]);
  }
  while (bIndex < bLen) {
    result.push(b[bIndex++]);
  }
  return result;
}
function joinRepeatable(compare, a, b) {
  const compareResult = compare(a, b);
  return compareResult === 0 ? a : compareResult < 0 ? [a, b] : [b, a];
}

// src/translator/util/scope-read.ts
var import_compiler23 = require("@marko/compiler");

// src/translator/visitors/program/index.ts
var import_compiler22 = require("@marko/compiler");
var import_babel_utils16 = require("@marko/compiler/babel-utils");
var import_path2 = __toESM(require("path"));

// src/translator/util/binding-has-downstream-expressions.ts
function bindingHasDownstreamExpressions(binding) {
  if (binding.downstreamExpressions.size) return true;
  for (const alias of binding.aliases) {
    if (bindingHasDownstreamExpressions(alias)) return true;
  }
  for (const alias of binding.propertyAliases.values()) {
    if (bindingHasDownstreamExpressions(alias)) return true;
  }
  return false;
}

// src/translator/util/entry-builder.ts
var import_compiler5 = require("@marko/compiler");
var import_babel_utils6 = require("@marko/compiler/babel-utils");
var kState = Symbol();
var entry_builder_default = {
  build(entryFile) {
    const state = entryFile[kState];
    if (!state) {
      throw entryFile.path.buildCodeFrameError(
        "Unable to build hydrate code, no files were visited before finalizing the build"
      );
    }
    const body = state.imports.map(
      (it) => import_compiler5.types.importDeclaration([], import_compiler5.types.stringLiteral(it))
    );
    if (state.init) {
      body.unshift(
        import_compiler5.types.importDeclaration(
          [import_compiler5.types.importSpecifier(import_compiler5.types.identifier("init"), import_compiler5.types.identifier("init"))],
          import_compiler5.types.stringLiteral(
            `${runtime_info_default.name}/${entryFile.markoOpts.optimize ? "" : "debug/"}dom`
          )
        )
      );
      body.push(
        import_compiler5.types.expressionStatement(import_compiler5.types.callExpression(import_compiler5.types.identifier("init"), []))
      );
    }
    return body;
  },
  visit(file, entryFile, visitChild) {
    const state = entryFile[kState] ||= {
      imports: [],
      init: false
    };
    const { analyzedTags } = file.metadata.marko;
    state.imports.push(
      (0, import_babel_utils6.resolveRelativePath)(entryFile, file.opts.filename)
    );
    state.init ||= file.path.node.extra.hasInteractiveChild || file.path.node.extra.isInteractive || false;
    for (const tag of analyzedTags || []) {
      visitChild(tag);
    }
  }
};

// src/translator/util/get-known-attr-values.ts
function getKnownAttrValues(tag) {
  const attrs2 = {};
  for (const attr2 of tag.attributes) {
    if (attr2.type === "MarkoAttribute") {
      attrs2[attr2.name] = attr2.value;
    }
  }
  return attrs2;
}

// src/translator/util/is-core-tag.ts
var import_babel_utils7 = require("@marko/compiler/babel-utils");

// src/translator/util/get-tag-name.ts
function getTagName(tag) {
  return tag.node.name.value;
}

// src/translator/util/is-core-tag.ts
var { taglibId } = runtime_info_default;
var htmlTaglibId = "marko-html";
var interopTaglibId = "@marko/translator-interop-class-tags";
function isCoreTag(tag) {
  if (tag.isMarkoTag()) {
    const tagDef = (0, import_babel_utils7.getTagDef)(tag);
    if (tagDef) {
      switch (tagDef.taglibId) {
        case taglibId:
          return true;
        case interopTaglibId:
          switch (tagDef.name) {
            // The body tag is registered in the v5 translator, without this it'd be seen as a core tag.
            case "body":
              return false;
          }
          return true;
        case htmlTaglibId:
          switch (tagDef.name) {
            case "script":
            case "style":
              return true;
          }
          break;
      }
    }
  }
  return false;
}
function isCoreTagName(tag, name2) {
  return isCoreTag(tag) && getTagName(tag) === name2;
}
function isConditionTag(tag) {
  if (isCoreTag(tag)) {
    switch (getTagName(tag)) {
      case "if":
      case "else-if":
      case "else":
        return true;
    }
  }
  return false;
}
function isControlFlowTag(tag) {
  if (isCoreTag(tag)) {
    switch (getTagName(tag)) {
      case "if":
      case "else-if":
      case "else":
      case "for":
      case "await":
      case "try":
        return true;
    }
  }
  return false;
}

// src/translator/util/runtime.ts
var import_compiler7 = require("@marko/compiler");
var import_babel_utils8 = require("@marko/compiler/babel-utils");

// src/common/attr-tag.ts
var rest = false ? Symbol("Attribute Tag") : Symbol();

// src/common/helpers.ts
function classValue(classValue2) {
  return toDelimitedString(classValue2, " ", stringifyClassObject);
}
function stringifyClassObject(name2, value) {
  return value ? name2 : "";
}
function styleValue(styleValue2) {
  return toDelimitedString(styleValue2, ";", stringifyStyleObject);
}
function stringifyStyleObject(name2, value) {
  return value || value === 0 ? name2 + ":" + value : "";
}
function toDelimitedString(val, delimiter, stringify) {
  let str = "";
  let sep = "";
  let part;
  if (val) {
    if (typeof val !== "object") {
      str += val;
    } else if (Array.isArray(val)) {
      for (const v of val) {
        part = toDelimitedString(v, delimiter, stringify);
        if (part) {
          str += sep + part;
          sep = delimiter;
        }
      }
    } else {
      for (const name2 in val) {
        part = stringify(name2, val[name2]);
        if (part) {
          str += sep + part;
          sep = delimiter;
        }
      }
    }
  }
  return str;
}
function isEventHandler(name2) {
  return /^on[A-Z-]/.test(name2);
}
function getEventHandlerName(name2) {
  return name2[2] === "-" ? name2.slice(3) : name2.slice(2).toLowerCase();
}
function isVoid(value) {
  return value == null || value === false;
}

// src/html/content.ts
function toString(val) {
  return val ? val + "" : val === 0 ? "0" : "";
}
var unsafeXMLReg = /[<&]/g;
var replaceUnsafeXML = (c) => c === "&" ? "&amp;" : "&lt;";
var escapeXMLStr = (str) => unsafeXMLReg.test(str) ? str.replace(unsafeXMLReg, replaceUnsafeXML) : str;
function escapeXML(val) {
  return val ? escapeXMLStr(val + "") : val === 0 ? "0" : "&zwj;";
}
var unsafeScriptReg = /<\/script/g;
var escapeScriptStr = (str) => unsafeScriptReg.test(str) ? str.replace(unsafeScriptReg, "\\x3C/script") : str;
function escapeScript(val) {
  return val ? escapeScriptStr(val + "") : val === 0 ? "0" : "";
}
var unsafeStyleReg = /<\/style/g;
var escapeStyleStr = (str) => unsafeStyleReg.test(str) ? str.replace(unsafeStyleReg, "\\3C/style") : str;
function escapeStyle(val) {
  return val ? escapeStyleStr(val + "") : val === 0 ? "0" : "";
}

// src/html/writer.ts
var K_SCOPE_ID = Symbol("Scope ID");
var kPendingContexts = Symbol("Pending Contexts");
var branchIdKey = Symbol();
if (false) {
  writeScope = /* @__PURE__ */ ((writeScope2) => (scopeId, partialScope, file, loc, vars) => {
    const scope = writeScope2(scopeId, partialScope);
    if (file && loc !== void 0) {
      setDebugInfo(scope, file, loc, vars);
    }
    return scope;
  })(writeScope);
}
var tick = globalThis.setImmediate || globalThis.setTimeout || globalThis.queueMicrotask || ((cb) => Promise.resolve().then(cb));

// src/html/attrs.ts
function classAttr(value) {
  return stringAttr("class", classValue(value));
}
function styleAttr(value) {
  return stringAttr("style", styleValue(value));
}
var kSelectedValue = Symbol("selectedValue");
function attr(name2, value) {
  return isVoid(value) ? "" : nonVoidAttr(name2, value);
}
function stringAttr(name2, value) {
  return value && " " + name2 + attrAssignment(value);
}
function nonVoidAttr(name2, value) {
  switch (typeof value) {
    case "string":
      return " " + name2 + attrAssignment(value);
    case "boolean":
      return " " + name2;
    case "number":
      return " " + name2 + "=" + value;
    case "object":
      if (value instanceof RegExp) {
        return " " + name2 + attrAssignment(value.source);
      }
      break;
  }
  return " " + name2 + attrAssignment(value + "");
}
var singleQuoteAttrReplacements = /'|&(?=#?\w+;)/g;
var doubleQuoteAttrReplacements = /"|&(?=#?\w+;)/g;
var needsQuotedAttr = /["'>\s]|&#?\w+;|\/$/g;
function attrAssignment(value) {
  return value ? needsQuotedAttr.test(value) ? value[needsQuotedAttr.lastIndex - 1] === (needsQuotedAttr.lastIndex = 0, '"') ? "='" + escapeSingleQuotedAttrValue(value) + "'" : '="' + escapeDoubleQuotedAttrValue(value) + '"' : "=" + value : "";
}
function escapeSingleQuotedAttrValue(value) {
  return singleQuoteAttrReplacements.test(value) ? value.replace(
    singleQuoteAttrReplacements,
    replaceUnsafeSingleQuoteAttrChar
  ) : value;
}
function replaceUnsafeSingleQuoteAttrChar(match) {
  return match === "'" ? "&#39;" : "&amp;";
}
function escapeDoubleQuotedAttrValue(value) {
  return doubleQuoteAttrReplacements.test(value) ? value.replace(
    doubleQuoteAttrReplacements,
    replaceUnsafeDoubleQuoteAttrChar
  ) : value;
}
function replaceUnsafeDoubleQuoteAttrChar(match) {
  return match === '"' ? "&#34;" : "&amp;";
}

// src/common/compat-meta.ts
var prefix = false ? "$compat_" : "$C_";
var RENDERER_REGISTER_ID = prefix + (false ? "renderer" : "r");
var SET_SCOPE_REGISTER_ID = prefix + (false ? "setScope" : "s");
var RENDER_BODY_ID = prefix + (false ? "renderBody" : "b");

// src/html/compat.ts
var K_TAGS_API_STATE = Symbol();

// src/translator/util/to-property-name.ts
var import_compiler6 = require("@marko/compiler");
function isValidPropertyIdentifier(name2) {
  return /^[a-z_$][a-z0-9_$]*$/i.test(name2);
}
function toPropertyName(name2) {
  if (isValidPropertyIdentifier(name2)) {
    return import_compiler6.types.identifier(name2);
  } else if (/^(?:0|[1-9][0-9]*)$/.test(name2)) {
    return import_compiler6.types.numericLiteral(parseInt(name2, 10));
  }
  return import_compiler6.types.stringLiteral(name2);
}
function toObjectProperty(name2, value) {
  return import_compiler6.types.objectProperty(toPropertyName(name2), value);
}
function toMemberExpression(object, key, optional) {
  const prop = toPropertyName(key);
  const computed = prop.type !== "Identifier";
  return optional ? import_compiler6.types.optionalMemberExpression(object, prop, computed, true) : import_compiler6.types.memberExpression(object, prop, computed);
}

// src/translator/util/runtime.ts
var pureDOMFunctions = /* @__PURE__ */ new Set([
  "awaitTag",
  "conditional",
  "conditionalClosure",
  "createTry",
  "dynamicTag",
  "createRenderer",
  "createContent",
  "createTemplate",
  "dynamicClosure",
  "dynamicClosureRead",
  "intersection",
  "loopClosure",
  "loopIn",
  "loopOf",
  "loopTo",
  "state",
  "value"
]);
function importRuntime(name2) {
  const { output } = getMarkoOpts();
  return toMemberExpression(
    (0, import_babel_utils8.importStar)((0, import_babel_utils8.getFile)(), getRuntimePath(output), "$"),
    name2
  );
}
function callRuntime(name2, ...args) {
  const callExpression2 = import_compiler7.types.callExpression(
    importRuntime(name2),
    filterArguments(args)
  );
  if (isOutputDOM() && pureDOMFunctions.has(name2)) {
    callExpression2.leadingComments = [
      {
        type: "CommentBlock",
        value: ` @__PURE__ `
      }
    ];
  }
  return callExpression2;
}
function getHTMLRuntime() {
  return {
    escapeXML,
    toString,
    attr,
    classAttr,
    styleAttr,
    escapeScript,
    escapeStyle
  };
}
function getRuntimePath(output) {
  const { optimize } = getMarkoOpts();
  return `${runtime_info_default.name}/${optimize ? "" : "debug/"}${output === "html" ? "html" : "dom"}`;
}
function filterArguments(args) {
  const filteredArgs = [];
  for (let i = args.length; i--; ) {
    const arg = args[i];
    if (arg || filteredArgs.length) {
      filteredArgs[i] = arg || import_compiler7.types.unaryExpression("void", import_compiler7.types.numericLiteral(0));
    }
  }
  return filteredArgs;
}
function getCompatRuntimeFile() {
  const markoOpts = getMarkoOpts();
  return `marko/src/runtime/helpers/tags-compat/${isOutputHTML() ? "html" : "dom"}${markoOpts.optimize ? "" : "-debug"}.${markoOpts.modules === "esm" ? "mjs" : "js"}`;
}

// src/translator/util/sections.ts
var import_compiler10 = require("@marko/compiler");
var import_babel_utils11 = require("@marko/compiler/babel-utils");

// src/translator/util/serialize-reasons.ts
var import_compiler8 = require("@marko/compiler");
var reasonExprs = /* @__PURE__ */ new WeakMap();
var keyedReasonExprs = /* @__PURE__ */ new WeakMap();
var serializeKeysByBinding = /* @__PURE__ */ new WeakMap();
var serializeKeyBySourceModifier = {};
function forceOwnersSerialize(from, to, prop) {
  let cur = from;
  while (cur !== to && cur.parent) {
    forceSectionSerialize(cur, prop);
    cur = cur.parent;
  }
}
function addOwnersSerializeReason(from, to, reason, prop) {
  if (reason) {
    let cur = from;
    while (cur !== to && cur.parent) {
      addSectionSerializeReason(cur, reason, prop);
      cur = cur.parent;
    }
  }
}
function forceSectionSerialize(section, prop) {
  if (prop) {
    forceSerializeKey(section, getSectionPropSerializeReasonKey(section, prop));
  } else if (section.serializeReason !== true) {
    reasonExprs.delete(section);
    setSectionSerializeReason(section, true);
  }
}
function forceBindingSerialize(section, binding, prefix2) {
  forceSerializeKey(section, getBindingSerializeReasonKey(binding, prefix2));
}
function forceSerializeKey(section, key) {
  if (section.serializeReasons.get(key) !== true) {
    setSectionKeyedSerializeReason(section, key, true);
    keyedReasonExprs.get(section)?.delete(key);
  }
}
function isBindingForceSerialized(section, binding, prefix2) {
  return section.serializeReasons.get(
    getBindingSerializeReasonKey(binding, prefix2)
  ) === true;
}
function addSectionSerializeReasonExpr(section, expr, prop) {
  if (expr) {
    if (prop) {
      addKeyedSerializeReasonExpr(
        section,
        getSectionPropSerializeReasonKey(section, prop),
        expr
      );
    } else if (section.serializeReason !== true) {
      if (expr === true) {
        forceSectionSerialize(section);
      } else {
        const existingExpr = reasonExprs.get(section);
        reasonExprs.set(
          section,
          existingExpr ? concat(existingExpr, expr) : expr
        );
      }
    }
  }
}
function addBindingSerializeReasonExpr(section, binding, expr, prefix2) {
  const key = getBindingSerializeReasonKey(binding, prefix2);
  if (expr && section.serializeReasons.get(key) !== true) {
    addKeyedSerializeReasonExpr(section, key, expr);
  }
}
function addKeyedSerializeReasonExpr(section, key, expr) {
  if (expr === true) {
    forceSerializeKey(section, key);
  } else {
    let existingExpr;
    let keyedExprs = keyedReasonExprs.get(section);
    if (keyedExprs) {
      existingExpr = keyedExprs.get(key);
    } else {
      keyedExprs = /* @__PURE__ */ new Map();
      keyedReasonExprs.set(section, keyedExprs);
    }
    keyedExprs.set(key, existingExpr ? concat(existingExpr, expr) : expr);
  }
}
function addSectionSerializeReasonRef(section, ref, prop) {
  if (ref) {
    if (prop) {
      addKeyedSerializeReasonRef(
        section,
        getSectionPropSerializeReasonKey(section, prop),
        ref
      );
    } else {
      const existingReason = section.serializeReason;
      if (existingReason !== true) {
        if (ref === true) {
          forceSectionSerialize(section);
        } else {
          const reason = getSerializeSourcesForRef(ref);
          if (reason) {
            setSectionSerializeReason(
              section,
              mergeSerializeReasons(existingReason, reason)
            );
          }
        }
      }
    }
  }
}
function addKeyedSerializeReasonRef(section, key, ref) {
  const existingReason = section.serializeReasons.get(key);
  if (existingReason !== true) {
    if (ref === true) {
      forceSerializeKey(section, key);
    } else {
      const reason = getSerializeSourcesForRef(ref);
      if (reason) {
        setSectionKeyedSerializeReason(
          section,
          key,
          mergeSerializeReasons(existingReason, reason)
        );
      }
    }
  }
}
function addSectionSerializeReason(section, reason, prop) {
  if (reason) {
    if (prop) {
      addKeyedSerializeReason(
        section,
        getSectionPropSerializeReasonKey(section, prop),
        reason
      );
    } else {
      const existingReason = section.serializeReason;
      if (existingReason !== true) {
        if (reason === true) {
          forceSectionSerialize(section);
        } else {
          setSectionSerializeReason(
            section,
            mergeSerializeReasons(existingReason, reason)
          );
        }
      }
    }
  }
}
function addBindingSerializeReason(section, binding, reason, prefix2) {
  if (reason) {
    addKeyedSerializeReason(
      section,
      getBindingSerializeReasonKey(binding, prefix2),
      reason
    );
  }
}
function addKeyedSerializeReason(section, key, reason) {
  const existingReason = section.serializeReasons.get(key);
  if (existingReason !== true) {
    if (reason === true) {
      forceSerializeKey(section, key);
    } else {
      setSectionKeyedSerializeReason(
        section,
        key,
        mergeSerializeReasons(existingReason, reason)
      );
    }
  }
}
function getSectionSerializeReason(section, prop) {
  return prop ? section.serializeReasons.get(
    getSectionPropSerializeReasonKey(section, prop)
  ) : section.serializeReason;
}
function getBindingSerializeReason(section, binding, prefix2) {
  return section.serializeReasons.get(
    getBindingSerializeReasonKey(binding, prefix2)
  );
}
function getSectionPropSerializeReasonKey(section, prop) {
  const keys = serializeKeyBySourceModifier[prop] ||= /* @__PURE__ */ new WeakMap();
  let key = keys.get(section);
  if (!key) {
    keys.set(
      section,
      key = Symbol(
        typeof prop === "symbol" ? `Symbol(${prop.description})` : prop
      )
    );
  }
  return key;
}
function getBindingSerializeReasonKey(binding, prefix2) {
  const keys = prefix2 ? serializeKeyBySourceModifier[prefix2] ||= /* @__PURE__ */ new WeakMap() : serializeKeysByBinding;
  let key = keys.get(binding);
  if (!key) {
    keys.set(
      binding,
      key = Symbol(
        (prefix2 ? typeof prefix2 === "symbol" ? `Symbol(${prefix2.description})` : prefix2 : "") + binding.name
      )
    );
  }
  return key;
}
function applySerializeReasonExprs(section) {
  const keyedExprs = keyedReasonExprs.get(section);
  if (keyedExprs) {
    keyedReasonExprs.delete(section);
    for (const [key, exprs] of keyedExprs) {
      const reason2 = getSerializeSourcesForExprs(exprs);
      if (reason2) {
        setSectionKeyedSerializeReason(
          section,
          key,
          mergeSerializeReasons(section.serializeReasons.get(key), reason2)
        );
      }
    }
  }
  const reason = getSerializeSourcesForExprs(reasonExprs.get(section));
  if (reason) {
    setSectionSerializeReason(
      section,
      mergeSerializeReasons(section.serializeReason, reason)
    );
  }
  reasonExprs.delete(section);
}
function finalizeSectionSerializeReasons(section) {
  let reason = section.serializeReason;
  if (reason !== true) {
    for (const [, keyedReason] of section.serializeReasons) {
      if (keyedReason === true) {
        reason = true;
        break;
      }
      reason = mergeSerializeReasons(reason, keyedReason);
    }
    if (reason) {
      setSectionSerializeReason(section, reason);
    }
  }
}
function getSerializeSourcesForExpr(expr) {
  if (isReferencedExtra(expr)) {
    return getSerializeSourcesForRef(expr.referencedBindings);
  }
}
function getSerializeSourcesForExprs(exprs) {
  if (exprs) {
    if (Array.isArray(exprs)) {
      let allSources;
      for (const expr of exprs) {
        allSources = mergeSources(allSources, getSerializeSourcesForExpr(expr));
      }
      return allSources;
    } else {
      return getSerializeSourcesForExpr(exprs);
    }
  }
}
function getSerializeSourcesForRef(ref) {
  if (ref) {
    let allSources;
    if (Array.isArray(ref)) {
      for (const { sources } of ref) {
        allSources = mergeSources(allSources, sources);
      }
      return allSources;
    } else {
      return ref.sources;
    }
  }
}
function mergeSerializeReasons(a, b) {
  if (a === true || b === true) return true;
  return mergeSources(a, b);
}
function setSectionSerializeReason(section, reason) {
  section.serializeReason = reason;
}
function setSectionKeyedSerializeReason(section, key, reason) {
  section.serializeReasons.set(key, reason);
}

// src/translator/util/state.ts
var import_babel_utils9 = require("@marko/compiler/babel-utils");
var createProgramState = (init) => {
  const map = /* @__PURE__ */ new WeakMap();
  return [
    () => {
      let state = map.get((0, import_babel_utils9.getProgram)());
      if (!state) {
        map.set((0, import_babel_utils9.getProgram)(), state = init());
      }
      return state;
    },
    (value) => {
      map.set((0, import_babel_utils9.getProgram)(), value);
    }
  ];
};
function createSectionState(key, init) {
  return [
    (section) => {
      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};
      const sectionData = arrayOfSectionData[section.id] ??= init && init(section);
      return sectionData;
    },
    (section, value) => {
      const arrayOfSectionData = (0, import_babel_utils9.getProgram)().state[key] ??= {};
      arrayOfSectionData[section.id] = value;
    }
  ];
}

// src/translator/util/tag-name-type.ts
var import_compiler9 = require("@marko/compiler");
var import_babel_utils10 = require("@marko/compiler/babel-utils");
var MARKO_FILE_REG = /^<.*>$|\.marko$/;
function analyzeTagNameType(tag) {
  const extra = tag.node.extra ??= {};
  if (extra.tagNameType === void 0) {
    const name2 = tag.get("name");
    if (name2.isStringLiteral()) {
      extra.tagNameType = name2.node.value[0] === "@" ? 3 /* AttributeTag */ : (0, import_babel_utils10.isNativeTag)(tag) ? 0 /* NativeTag */ : 1 /* CustomTag */;
      extra.tagNameNullable = extra.tagNameNullable = false;
    } else if (name2.isIdentifier()) {
      analyzeExpressionTagName(name2, extra);
      if (extra.tagNameType === 0 /* NativeTag */) {
        extra.tagNameType = 2 /* DynamicTag */;
      }
    } else if (name2.isTemplateLiteral() && !name2.node.expressions.length) {
      extra.tagNameType = 0 /* NativeTag */;
    } else {
      extra.tagNameType = 2 /* DynamicTag */;
    }
    if (extra.tagNameType === void 0) {
      extra.tagNameType = 2 /* DynamicTag */;
    }
    if (extra.tagNameType === 1 /* CustomTag */) {
      const childFile = (0, import_babel_utils10.loadFileForTag)(tag);
      if (!childFile) {
        extra.tagNameType = 2 /* DynamicTag */;
      } else if (childFile.ast.program.extra.featureType === "class") {
        extra.tagNameType = 2 /* DynamicTag */;
        extra.featureType = "class";
        ((0, import_babel_utils10.getProgram)().node.extra ??= {}).needsCompat = true;
      }
    }
  }
  return extra.tagNameType;
}
function analyzeExpressionTagName(name2, extra) {
  const pending = [name2];
  let path5;
  let type;
  let nullable = false;
  let tagNameImported;
  while ((path5 = pending.pop()) && type !== 2 /* DynamicTag */) {
    if (path5.isConditionalExpression()) {
      pending.push(path5.get("consequent"));
      if (path5.node.alternate) {
        pending.push(path5.get("alternate"));
      }
    } else if (path5.isLogicalExpression()) {
      if (path5.node.operator === "||") {
        pending.push(path5.get("left"));
      } else {
        nullable = true;
      }
      pending.push(path5.get("right"));
    } else if (path5.isAssignmentExpression()) {
      pending.push(path5.get("right"));
    } else if (path5.isBinaryExpression()) {
      type = path5.node.operator !== "+" || type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;
    } else if (path5.isStringLiteral() || path5.isTemplateLiteral()) {
      type = type !== void 0 ? 2 /* DynamicTag */ : 0 /* NativeTag */;
    } else if (path5.isNullLiteral()) {
      nullable = true;
    } else if (path5.isIdentifier()) {
      if (path5.node.name === "undefined") {
        nullable = true;
        continue;
      }
      const binding = path5.scope.getBinding(path5.node.name);
      if (!binding) {
        type = 2 /* DynamicTag */;
        continue;
      }
      if (binding.kind === "module") {
        const decl = binding.path.parent;
        if (MARKO_FILE_REG.test(decl.source.value) && decl.specifiers.some((it) => import_compiler9.types.isImportDefaultSpecifier(it))) {
          const resolvedImport = (0, import_babel_utils10.resolveTagImport)(name2, decl.source.value) || decl.source.value;
          if (type === 0 /* NativeTag */ || tagNameImported && tagNameImported !== resolvedImport) {
            type = 2 /* DynamicTag */;
            tagNameImported = void 0;
          } else {
            type = 1 /* CustomTag */;
            tagNameImported = resolvedImport;
          }
        } else {
          type = 2 /* DynamicTag */;
        }
        continue;
      }
      const bindingTag = binding.path;
      if (bindingTag.isMarkoTag() && binding.kind === "local") {
        const bindingTagName = bindingTag.get("name").node.value;
        if (bindingTagName === "const") {
          pending.push(
            bindingTag.get("attributes")[0].get("value")
          );
          continue;
        }
        if (bindingTagName === "let") {
          type = 2 /* DynamicTag */;
          continue;
        }
        continue;
      }
      type = 2 /* DynamicTag */;
    } else {
      type = 2 /* DynamicTag */;
    }
  }
  extra.tagNameType = type;
  extra.tagNameNullable = nullable;
  extra.tagNameDynamic = true;
  if (type === 1 /* CustomTag */ && tagNameImported) {
    extra.tagNameImported = tagNameImported;
  }
}

// src/translator/util/sections.ts
var sectionUtil = new Sorted(function compareSections(a, b) {
  return a.id - b.id;
});
function startSection(path5) {
  const extra = path5.node.extra ??= {};
  let section = extra.section;
  if (!section && (path5.type === "Program" || path5.get("body").length)) {
    const parentSection = path5.parentPath ? getOrCreateSection(path5.parentPath) : void 0;
    const sectionNamePath = path5.parentPath?.get(
      "name"
    );
    const sectionName = path5.isProgram() ? "" : generateUid(sectionNamePath.toString() + "_content");
    const programExtra = path5.hub.file.path.node.extra ??= {};
    const sections = programExtra.sections ??= [];
    section = extra.section = {
      id: sections.length,
      name: sectionName,
      loc: sectionNamePath?.node.loc || void 0,
      depth: parentSection ? parentSection.depth + 1 : 0,
      parent: parentSection,
      sectionAccessor: void 0,
      params: void 0,
      referencedLocalClosures: void 0,
      referencedClosures: void 0,
      referencedHoists: void 0,
      bindings: void 0,
      hoisted: void 0,
      isHoistThrough: void 0,
      serializeReason: void 0,
      serializeReasons: /* @__PURE__ */ new Map(),
      content: getContentInfo(path5),
      upstreamExpression: void 0,
      downstreamBinding: void 0,
      hasAbortSignal: false,
      isBranch: false
    };
    sections.push(section);
  }
  return section;
}
function getOrCreateSection(path5) {
  let cur = path5;
  while (true) {
    if (cur.type === "Program" || cur.type === "MarkoTagBody" && !cur.node.attributeTags && !isNativeNode(cur.parentPath)) {
      return (path5.node.extra ??= {}).section = startSection(cur);
    }
    cur = cur.parentPath;
  }
}
function getSectionForBody(body) {
  return body.node.extra?.section;
}
function getSection(path5) {
  let section;
  let currentPath = path5;
  while ((section = currentPath.node.extra?.section) === void 0) {
    currentPath = currentPath.parentPath;
  }
  return section;
}
var [getScopeIdIdentifier] = createSectionState(
  "scopeIdIdentifier",
  (section) => generateUidIdentifier(`scope${section.id}_id`)
);
var [getSectionParentIsOwner, setSectionParentIsOwner] = createSectionState("parentIsOwner", () => false);
var [_getScopeIdentifier] = createSectionState(
  "scopeIdentifier",
  () => import_compiler10.types.identifier("undefined")
);
function forEachSection(fn) {
  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;
  sections?.forEach(fn);
}
function forEachSectionReverse(fn) {
  const { sections } = (0, import_babel_utils11.getProgram)().node.extra;
  for (let i = sections.length; i--; ) {
    fn(sections[i]);
  }
}
function getContentInfo(path5) {
  const body = path5.get("body");
  const contentInfo = {
    startType: null,
    endType: null,
    singleChild: true
  };
  for (let endIndex = body.length; endIndex--; ) {
    const endType = getNodeContentType(body[endIndex], "endType", contentInfo);
    if (endType !== null) {
      contentInfo.endType = endType;
      if (endType === 1 /* Dynamic */) {
        contentInfo.singleChild = false;
      }
      for (let startIndex = 0; startIndex < endIndex; startIndex++) {
        const startType = getNodeContentType(body[startIndex], "startType");
        if (startType !== null) {
          contentInfo.startType = startType;
          contentInfo.singleChild = false;
          return contentInfo;
        }
      }
      contentInfo.startType = getNodeContentType(body[endIndex], "startType");
      return contentInfo;
    }
  }
  return null;
}
function getNodeContentType(path5, extraMember, contentInfo) {
  switch (path5.type) {
    case "MarkoText":
      return 4 /* Text */;
    case "MarkoPlaceholder":
      return 2 /* Placeholder */;
    case "MarkoScriptlet":
    case "MarkoComment":
    case "ImportDeclaration":
    case "ExportAllDeclaration":
    case "ExportNamedDeclaration":
      return null;
    case "MarkoTag": {
      const tag = path5;
      if (isCoreTag(tag)) {
        switch (tag.node.name.value) {
          case "html-comment":
            return 0 /* Comment */;
          case "html-script":
          case "html-style":
            return 3 /* Tag */;
          case "for":
          case "if":
          case "await":
          case "try":
            return 1 /* Dynamic */;
          default:
            return null;
        }
      } else if ((0, import_babel_utils11.isNativeTag)(tag)) {
        return 3 /* Tag */;
      } else if ((0, import_babel_utils11.isAttributeTag)(tag)) {
        return null;
      } else if (import_compiler10.types.isStringLiteral(tag.node.name)) {
        const tagSection = (0, import_babel_utils11.loadFileForTag)(tag)?.ast.program.extra.section;
        if (tagSection) {
          if (tagSection.content) {
            if (contentInfo && !tagSection.content.singleChild) {
              if (extraMember === "endType") {
                contentInfo.startType = tagSection.content.startType;
                contentInfo.singleChild = false;
              }
            }
            return tagSection.content[extraMember];
          } else {
            return null;
          }
        }
      }
    }
  }
  return 1 /* Dynamic */;
}
var isSerializedSection = (section) => {
  if (section.isBranch) return false;
  const { downstreamBinding } = section;
  if (downstreamBinding) {
    return !!getBindingSerializeReason(
      downstreamBinding.section,
      downstreamBinding
    );
  }
  return true;
};
function isImmediateOwner(section, binding) {
  return section.parent?.id === binding.section.id;
}
function isDirectClosure(section, closure) {
  return section.isBranch && isImmediateOwner(section, closure);
}
function isDynamicClosure(section, closure) {
  return !isDirectClosure(section, closure);
}
function getDynamicClosureIndex(closure, closureSection) {
  let index = 0;
  find(closure.closureSections, (section) => {
    if (section === closureSection) return true;
    if (isDynamicClosure(section, closure)) {
      index++;
    }
    return false;
  });
  return index;
}
function getDirectClosures(section) {
  if (section.isBranch) {
    return filter(
      section.referencedClosures,
      (closure) => isImmediateOwner(section, closure)
    );
  }
}
function isSameOrChildSection(section, other) {
  do {
    if (other === section) {
      return true;
    }
  } while (other = other.parent);
  return false;
}
function getCommonSection(section, other) {
  let ancestor = section;
  if (other.depth < section.depth) {
    ancestor = other;
    other = section;
  }
  while (ancestor) {
    if (other === ancestor || !other.parent) {
      return ancestor;
    }
    other = other.parent;
    if (other.depth < ancestor.depth) {
      ancestor = ancestor.parent;
    }
  }
  throw new Error("No common section");
}
function isNativeNode(tag) {
  if (isCoreTag(tag)) {
    switch (tag.node.name.value) {
      case "html-comment":
      case "html-script":
      case "html-style":
        return true;
      default:
        return false;
    }
  }
  return analyzeTagNameType(tag) === 0 /* NativeTag */;
}

// src/translator/visitors/program/dom.ts
var import_compiler21 = require("@marko/compiler");
var import_babel_utils15 = require("@marko/compiler/babel-utils");

// src/translator/util/get-style-file.ts
var import_path = __toESM(require("path"));
function getStyleFile(file) {
  const { filename } = file.opts;
  const fs = file.markoOpts.fileSystem;
  const base = getBase(filename);
  const styleMatch = new RegExp(
    `^(${escapeRegExp(base)}\\.${"index" === base ? "|" : ""})style\\.\\w+$`
  );
  for (const file2 of fs.readdirSync(import_path.default.dirname(filename)).sort()) {
    if (styleMatch.test(file2)) {
      return `./${file2}`;
    }
  }
}
function getBase(filename) {
  const start = filename.lastIndexOf(import_path.default.sep) + 1;
  const leftDot = filename.indexOf(".", start);
  if (leftDot === -1) {
    return filename.slice(start);
  }
  const rightDot = filename.lastIndexOf(".");
  const closeBracket = leftDot - 1;
  if (filename[closeBracket] === "]") {
    const openBracket = filename.lastIndexOf("[", closeBracket);
    if (openBracket > start) {
      return filename.slice(start, openBracket) + filename.slice(leftDot, rightDot);
    }
  }
  return filename.slice(start, rightDot);
}
var regexpCharsReg = /[\\^$.*+?()[\]{}|]/g;
function escapeRegExp(str) {
  return str.replace(regexpCharsReg, "\\$&");
}

// src/translator/util/signals.ts
var import_compiler20 = require("@marko/compiler");
var import_babel_utils14 = require("@marko/compiler/babel-utils");

// src/translator/core/return.ts
var import_compiler17 = require("@marko/compiler");
var import_babel_utils13 = require("@marko/compiler/babel-utils");

// src/translator/util/get-parent-tag.ts
function getParentTag(tag) {
  const parent = tag.parent.type === "MarkoTagBody" ? tag.parentPath.parentPath : tag.parentPath;
  if (parent.type === "MarkoTag") {
    return parent;
  }
}

// src/translator/util/plugin-hooks.ts
var import_compiler11 = require("@marko/compiler");
function enter(modulePlugin, path5) {
  if (!modulePlugin) {
    return false;
  }
  const { node } = path5;
  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;
  if (isFunctionPlugin(plugin)) {
    plugin(path5, import_compiler11.types);
  } else if (plugin.enter) {
    plugin.enter(path5, import_compiler11.types);
  }
  return node !== path5.node;
}
function exit(modulePlugin, path5) {
  if (!modulePlugin) {
    return false;
  }
  const { node } = path5;
  const plugin = isModulePlugin(modulePlugin) ? modulePlugin.default : modulePlugin;
  if (!isFunctionPlugin(plugin) && plugin.exit) {
    plugin.exit(path5, import_compiler11.types);
  }
  return node !== path5.node;
}
function isModulePlugin(plugin) {
  return Boolean(plugin.default);
}
function isFunctionPlugin(plugin) {
  return typeof plugin === "function";
}

// src/translator/util/visitors.ts
function extractVisitors(visitors2) {
  const result = {
    migrate: {},
    transform: {},
    analyze: {},
    translate: {}
  };
  for (const _name in visitors2) {
    const name2 = _name;
    const value = visitors2[name2];
    if (value.migrate) result.migrate[name2] = value.migrate;
    if (value.transform) result.transform[name2] = value.transform;
    if (value.analyze) result.analyze[name2] = value.analyze;
    if (value.translate) result.translate[name2] = value.translate;
  }
  return result;
}
function translateByTarget({
  html,
  dom
}) {
  return {
    enter(path5) {
      enter(isOutputHTML() ? html : dom, path5);
    },
    exit(path5) {
      exit(isOutputHTML() ? html : dom, path5);
    }
  };
}

// src/translator/util/writer.ts
var import_compiler16 = require("@marko/compiler");

// src/translator/visitors/program/html.ts
var import_compiler13 = require("@marko/compiler");
var import_babel_utils12 = require("@marko/compiler/babel-utils");

// src/translator/util/is-static.ts
function isStatic(path5) {
  return path5.isImportDeclaration() || path5.isExportDeclaration() || path5.isMarkoScriptlet({ static: true });
}

// src/translator/util/simplify-fn.ts
var import_compiler12 = require("@marko/compiler");
function simplifyFunction(fn) {
  switch (fn.type) {
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
      return fn;
    default:
      return import_compiler12.types.functionExpression(
        null,
        fn.params,
        fn.body,
        fn.async,
        fn.generator
      );
  }
}

// src/translator/util/with-comment.ts
function withLeadingComment(node, value) {
  const comment = {
    type: "CommentBlock",
    value: ` ${value} `
  };
  node.leadingComments = node.leadingComments ? [...node.leadingComments, comment] : [comment];
  return node;
}

// src/translator/visitors/program/html.ts
function getTemplateContentName() {
  return getSharedUid("content");
}
function getSerializeGuard(reason, optional) {
  return !reason ? import_compiler13.types.numericLiteral(0) : reason === true || reason.state ? optional ? void 0 : reason === true ? import_compiler13.types.numericLiteral(1) : withLeadingComment(
    import_compiler13.types.numericLiteral(1),
    `state: ${mapToString(reason.state, ", ", getDebugName)}`
  ) : getInputSerializeReasonGuard(reason.input);
}
function getSerializeGuardForAny(reasons, optional) {
  if (!reasons || reasons === true) {
    return getSerializeGuard(reasons, optional);
  }
  if (reasons.length === 1) {
    return getSerializeGuard(reasons[0], optional);
  }
  let expr;
  for (const reason of reasons) {
    if (reason.state) {
      return optional ? void 0 : withLeadingComment(
        import_compiler13.types.numericLiteral(1),
        `state: ${mapToString(reason.state, ", ", getDebugName)}`
      );
    }
    const guard = getSerializeGuard(reason, false);
    expr = expr ? import_compiler13.types.logicalExpression("||", expr, guard) : guard;
  }
  return expr;
}
function getExprIfSerialized(reason, expr) {
  return reason ? reason === true || reason.state ? expr : import_compiler13.types.logicalExpression(
    "&&",
    callRuntime(
      "serializeIf",
      import_compiler13.types.identifier(getSharedUid("serialize")),
      withLeadingComment(
        import_compiler13.types.numericLiteral(
          resolveSerializeReasonId(
            (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,
            reason.input
          )
        ),
        mapToString(reason.input, ", ", getInputDebugName)
      )
    ),
    expr
  ) : void 0;
}
function getInputSerializeReasonGuard(reason) {
  return callRuntime(
    "serializeGuard",
    import_compiler13.types.identifier(getSharedUid("serialize")),
    withLeadingComment(
      import_compiler13.types.numericLiteral(
        resolveSerializeReasonId(
          (0, import_babel_utils12.getProgram)().node.extra.inputSerializeReasons,
          reason
        )
      ),
      mapToString(reason, ",", getDebugName)
    )
  );
}
var html_default = {
  translate: {
    exit(program) {
      flushInto(program);
      writeHTMLResumeStatements(program);
      traverseReplace(program.node, "body", replaceNode);
      const renderContent = [];
      for (const child of program.get("body")) {
        if (!isStatic(child)) {
          renderContent.push(child.node);
          child.remove();
        } else if (child.isMarkoScriptlet()) {
          if (child.node.target && child.node.target !== "server") {
            child.remove();
          } else {
            child.replaceWithMultiple(child.node.body);
          }
        }
      }
      const serializeId = usedSharedUid("serialize") && getSharedUid("serialize");
      const contentId = usedSharedUid("content") && getTemplateContentName();
      const contentFn = import_compiler13.types.arrowFunctionExpression(
        serializeId ? [import_compiler13.types.identifier("input"), import_compiler13.types.identifier(serializeId)] : [import_compiler13.types.identifier("input")],
        import_compiler13.types.blockStatement(renderContent)
      );
      const exportDefault = import_compiler13.types.exportDefaultDeclaration(
        callRuntime(
          "createTemplate",
          import_compiler13.types.stringLiteral(program.hub.file.metadata.marko.id),
          contentId ? import_compiler13.types.identifier(contentId) : contentFn
        )
      );
      if (contentId) {
        program.node.body.push(
          import_compiler13.types.variableDeclaration("const", [
            import_compiler13.types.variableDeclarator(import_compiler13.types.identifier(contentId), contentFn)
          ]),
          exportDefault
        );
      } else {
        program.node.body.push(exportDefault);
      }
    }
  }
};
function replaceNode(node, container) {
  return replaceBindingReadNode(node) || replaceRegisteredFunctionNode(node, container);
}
function replaceBindingReadNode(node) {
  switch (node.type) {
    case "Identifier":
    case "MemberExpression": {
      const { extra } = node;
      if (extra && !(extra.read && !extra.read.binding.declared || extra.binding && !extra.binding.declared)) {
        return getReadReplacement(node);
      }
    }
  }
}
function replaceRegisteredFunctionNode(node, container) {
  switch (node.type) {
    case "ClassMethod": {
      const replacement = getRegisteredFnExpression(node);
      return replacement && import_compiler13.types.classProperty(node.key, replacement);
    }
    case "ClassPrivateMethod": {
      const replacement = getRegisteredFnExpression(node);
      return replacement && import_compiler13.types.classPrivateProperty(node.key, replacement);
    }
    case "ObjectMethod": {
      const replacement = getRegisteredFnExpression(node);
      return replacement && import_compiler13.types.objectProperty(node.key, replacement);
    }
    case "FunctionDeclaration": {
      const { extra } = node;
      if (isRegisteredFnExtra(extra)) {
        let registeredFnDeclarations = registeredFnDeclarationsByBody.get(
          container
        );
        if (!registeredFnDeclarations) {
          registeredFnDeclarationsByBody.set(
            container,
            registeredFnDeclarations = []
          );
        }
        registeredFnDeclarations.push({
          id: node.id.name,
          registerId: extra.registerId
        });
      }
      break;
    }
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      return getRegisteredFnExpression(node);
    }
    case "BlockStatement":
    case "MarkoScriptlet":
      addRegisteredDeclarations(node.body);
      break;
  }
}
var registeredFnDeclarationsByBody = /* @__PURE__ */ new WeakMap();
function addRegisteredDeclarations(body) {
  const registeredFnDeclarations = registeredFnDeclarationsByBody.get(body);
  if (registeredFnDeclarations) {
    for (const { id, registerId } of registeredFnDeclarations) {
      body.push(
        import_compiler13.types.expressionStatement(
          callRuntime(
            "register",
            import_compiler13.types.identifier(id),
            import_compiler13.types.stringLiteral(registerId)
          )
        )
      );
    }
  }
}
function getRegisteredFnExpression(node) {
  const { extra } = node;
  if (isRegisteredFnExtra(extra)) {
    return callRuntime(
      "register",
      simplifyFunction(node),
      import_compiler13.types.stringLiteral(extra.registerId),
      (extra.referencedBindingsInFunction || extra.referencesScope) && getScopeIdIdentifier(extra.section)
    );
  }
}

// src/translator/util/normalize-string-expression.ts
var import_compiler14 = require("@marko/compiler");
function normalizeStringExpression(parts) {
  const strs = [];
  const exprs = [];
  let curStr = parts[0];
  for (let i = 1; i < parts.length; i++) {
    let content = parts[i];
    if (typeof content === "object") {
      if (import_compiler14.types.isStringLiteral(content)) {
        content = content.value;
      } else if (import_compiler14.types.isTemplateLiteral(content)) {
        let nextIndex = i + 1;
        const exprLen = content.expressions.length;
        shiftItems(parts, nextIndex, content.quasis.length + exprLen);
        for (let j = 0; j < exprLen; j++) {
          parts[nextIndex++] = content.quasis[j].value.raw;
          parts[nextIndex++] = content.expressions[j];
        }
        parts[nextIndex] = content.quasis[exprLen].value.raw;
        continue;
      } else {
        exprs.push(content);
        strs.push(curStr);
        curStr = "";
        continue;
      }
    }
    curStr += content;
  }
  if (exprs.length) {
    if (exprs.length === 1 && !curStr && !strs[0]) {
      return exprs[0];
    }
    strs.push(curStr);
    return import_compiler14.types.templateLiteral(
      strs.map((raw) => import_compiler14.types.templateElement({ raw })),
      exprs
    );
  } else if (curStr) {
    return import_compiler14.types.stringLiteral(curStr);
  }
}
function appendLiteral(arr, str) {
  arr[arr.length - 1] += str;
}
function shiftItems(list, start, offset) {
  for (let i = list.length - 1; i >= start; i--) {
    list[i + offset] = list[i];
  }
}

// src/translator/util/walks.ts
var import_compiler15 = require("@marko/compiler");
var [getWalks] = createSectionState(
  "walks",
  () => [""]
);
var [getWalkComment] = createSectionState(
  "walkComment",
  () => []
);
var [getSteps] = createSectionState("steps", () => []);
var walkCodeToName = {
  [32 /* Get */]: "get",
  [36 /* Inside */]: "inside",
  [37 /* Replace */]: "replace",
  [38 /* EndChild */]: "endChild",
  [47 /* BeginChild */]: "beginChild",
  [48 /* BeginChildWithVar */]: "beginChildWithVar",
  [49 /* DynamicTagWithVar */]: "dynamicTagWithVar",
  [67 /* Next */]: "next",
  [97 /* Over */]: "over",
  [107 /* Out */]: "out",
  [117 /* Multiplier */]: "multiplier",
  [91 /* NextEnd */]: "nextEnd",
  [106 /* OverEnd */]: "overEnd",
  [116 /* OutEnd */]: "outEnd",
  [126 /* MultiplierEnd */]: "multiplierEnd"
};
function enter2(path5) {
  getSteps(getSection(path5)).push(0 /* Enter */);
}
function exit2(path5) {
  getSteps(getSection(path5)).push(1 /* Exit */);
}
function enterShallow(path5) {
  getSteps(getSection(path5)).push(0 /* Enter */, 1 /* Exit */);
}
function injectWalks(tag, expr) {
  const walks = getWalks(getSection(tag));
  const walkComment = getWalkComment(getSection(tag));
  walkComment.push(
    `${walkCodeToName[tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */]}`,
    expr.name,
    walkCodeToName[38 /* EndChild */]
  );
  appendLiteral(
    walks,
    String.fromCharCode(
      tag.node.var ? 48 /* BeginChildWithVar */ : 47 /* BeginChild */
    )
  );
  walks.push(expr, String.fromCharCode(38 /* EndChild */));
}
function visit(path5, code) {
  if (isOutputHTML()) {
    return;
  }
  const section = getSection(path5);
  const steps = getSteps(section);
  const walks = getWalks(section);
  const walkComment = getWalkComment(section);
  let walkString = "";
  if (steps.length) {
    const walkCodes = [];
    let depth = 0;
    for (const step of steps) {
      if (step === 0 /* Enter */) {
        depth++;
        walkCodes.push(67 /* Next */);
      } else {
        depth--;
        if (depth >= 0) {
          walkCodes.length = walkCodes.lastIndexOf(67 /* Next */);
          walkCodes.push(97 /* Over */);
        } else {
          walkCodes.length = walkCodes.lastIndexOf(107 /* Out */) + 1;
          walkCodes.push(107 /* Out */);
          depth = 0;
        }
      }
    }
    let current = walkCodes[0];
    let count = 0;
    for (const walk of walkCodes) {
      if (walk !== current) {
        walkComment.push(`${walkCodeToName[current]}(${count})`);
        walkString += nCodeString(current, count);
        current = walk;
        count = 1;
      } else {
        count++;
      }
    }
    walkComment.push(`${walkCodeToName[current]}(${count})`);
    walkString += nCodeString(current, count);
    steps.length = 0;
  }
  if (code !== void 0) {
    if (code !== 32 /* Get */) {
      writeTo(path5)`<!>`;
    }
    walkComment.push(`${walkCodeToName[code]}`);
    walkString += String.fromCharCode(code);
  }
  appendLiteral(walks, walkString);
}
function nCodeString(code, number) {
  switch (code) {
    case 67 /* Next */:
      return toCharString(number, code, 20 /* Next */);
    case 97 /* Over */:
      return toCharString(number, code, 10 /* Over */);
    case 107 /* Out */:
      return toCharString(number, code, 10 /* Out */);
    default:
      throw new Error(`Unexpected walk code: ${code}`);
  }
}
function toCharString(number, startCode, rangeSize) {
  let result = "";
  if (number >= rangeSize) {
    const multiplier = Math.floor(number / rangeSize);
    result += toCharString(
      multiplier,
      117 /* Multiplier */,
      10 /* Multiplier */
    );
    number -= multiplier * rangeSize;
  }
  result += String.fromCharCode(startCode + number);
  return result;
}
function getWalkString(section) {
  const prefix2 = section.content?.startType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : "";
  const postfix = section.content?.endType === 1 /* Dynamic */ ? String.fromCharCode(67 /* Next */ + 1) : "";
  const walks = getWalks(section);
  const walkLiteral = normalizeStringExpression([prefix2, ...walks, postfix]);
  if (walkLiteral && walkLiteral.value !== "") {
    withLeadingComment(walkLiteral, getWalkComment(section).join(", "));
  }
  return walkLiteral;
}

// src/translator/util/writer.ts
var [getWrites] = createSectionState(
  "writes",
  () => [""]
);
var [getTrailerWrites] = createSectionState(
  "trailerWrites",
  () => [""]
);
function writeTo(path5, trailer) {
  const section = getSection(path5);
  const get = trailer ? getTrailerWrites : getWrites;
  return (strs, ...exprs) => {
    const exprsLen = exprs.length;
    const writes = get(section);
    appendLiteral(writes, strs[0]);
    for (let i = 0; i < exprsLen; i++) {
      writes.push(exprs[i], strs[i + 1]);
    }
  };
}
function consumeHTML(path5) {
  const section = getSection(path5);
  const writes = getWrites(section);
  const trailers = getTrailerWrites(section);
  const writeResult = normalizeStringExpression(writes);
  const trailerResult = normalizeStringExpression(trailers);
  writes.length = 0;
  writes[0] = "";
  trailers.length = 0;
  trailers[0] = "";
  if (writeResult && trailerResult) {
    return import_compiler16.types.expressionStatement(
      import_compiler16.types.sequenceExpression([
        callRuntime("write", writeResult),
        callRuntime("writeTrailers", trailerResult)
      ])
    );
  } else if (writeResult) {
    return import_compiler16.types.expressionStatement(callRuntime("write", writeResult));
  } else if (trailerResult) {
    return import_compiler16.types.expressionStatement(callRuntime("writeTrailers", trailerResult));
  }
}
function flushBefore(path5) {
  const expr = consumeHTML(path5);
  if (expr) {
    path5.insertBefore(expr)[0].skip();
  }
}
function flushInto(path5) {
  const target = path5.isProgram() ? path5 : path5.get("body");
  const expr = consumeHTML(target);
  if (expr) {
    target.node.body.push(expr);
  }
}
function getSectionMeta(section) {
  const writePrefix = section.content?.startType === 1 /* Dynamic */ ? "<!>" : "";
  const writePostfix = section.content?.endType === 1 /* Dynamic */ ? "<!>" : "";
  const writes = getWrites(section);
  return {
    setup: getSetup(section),
    walks: getWalkString(section),
    writes: normalizeStringExpression([writePrefix, ...writes, writePostfix])
  };
}
function markNode(path5, nodeBinding, reason) {
  if (nodeBinding.type !== 0 /* dom */) {
    throw path5.buildCodeFrameError(
      "Tried to mark a node that was not determined to need a mark during analyze."
    );
  }
  if (isOutputHTML()) {
    if (reason) {
      const section = getSection(path5);
      writeTo(path5)`${callRuntime(
        "markResumeNode",
        getScopeIdIdentifier(section),
        getScopeAccessorLiteral(nodeBinding),
        getSerializeGuard(reason, true)
      )}`;
    }
  }
}

// src/translator/core/return.ts
var tagsWithReturn = /* @__PURE__ */ new WeakSet();
var [getSectionReturnValueIdentifier, setReturnValueIdentifier] = createSectionState("returnValue");
var return_default = {
  analyze(tag) {
    (0, import_babel_utils13.assertNoArgs)(tag);
    (0, import_babel_utils13.assertNoVar)(tag);
    (0, import_babel_utils13.assertNoParams)(tag);
    assertNoBodyContent(tag);
    (0, import_babel_utils13.assertAllowedAttributes)(tag, ["value", "valueChange"]);
    const parentTag = getParentTag(tag);
    if (parentTag) {
      if ((0, import_babel_utils13.isNativeTag)(parentTag)) {
        throw tag.get("name").buildCodeFrameError(
          "The `return` tag can not be used in a native tag."
        );
      } else if (isControlFlowTag(parentTag)) {
        throw tag.get("name").buildCodeFrameError(
          `The \`return\` tag can not be used under an \`${parentTag.get("name").toString()}\` tag.`
        );
      }
    }
    if (tagsWithReturn.has(tag.parentPath)) {
      throw tag.get("name").buildCodeFrameError(
        `Cannot have multiple \`return\` tags ${tag.parent.type === "Program" ? "for the template" : "within a tag's body content"}.`
      );
    } else {
      tagsWithReturn.add(tag.parentPath);
    }
    const attrs2 = getKnownAttrValues(tag.node);
    if (!attrs2.value) {
      throw tag.get("name").buildCodeFrameError("The `return` tag requires a value.");
    }
    if (attrs2.valueChange) {
      forceSectionSerialize(
        getOrCreateSection(tag),
        getAccessorProp().TagVariableChange
      );
    }
  },
  translate: translateByTarget({
    html: {
      exit(tag) {
        const section = getSection(tag);
        const attrs2 = getKnownAttrValues(tag.node);
        flushBefore(tag);
        if (attrs2.valueChange) {
          setSectionSerializedValue(
            section,
            getAccessorProp().TagVariableChange,
            attrs2.valueChange
          );
        }
        if (attrs2.value) {
          const returnId = generateUidIdentifier("return");
          setReturnValueIdentifier(section, returnId);
          tag.replaceWith(
            import_compiler17.types.variableDeclaration("const", [
              import_compiler17.types.variableDeclarator(returnId, attrs2.value)
            ])
          )[0].skip();
        }
      }
    },
    dom: {
      exit(tag) {
        const section = getSection(tag);
        const attrs2 = getKnownAttrValues(tag.node);
        if (attrs2.value) {
          addStatement(
            "render",
            section,
            attrs2.value.extra?.referencedBindings,
            import_compiler17.types.expressionStatement(
              callRuntime("tagVarSignal", scopeIdentifier, attrs2.value)
            )
          );
        }
        if (attrs2.valueChange) {
          addStatement(
            "render",
            section,
            attrs2.valueChange.extra?.referencedBindings,
            import_compiler17.types.expressionStatement(
              callRuntime(
                "setTagVarChange",
                scopeIdentifier,
                attrs2.valueChange
              )
            )
          );
        }
        tag.remove();
      }
    }
  }),
  parseOptions: {
    openTagOnly: true
  },
  autocomplete: [
    {
      displayText: "return=<value>",
      description: "Provides a value for use in a parent template.",
      snippet: "return=${1:value}",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#return"
    }
  ]
};

// src/translator/util/get-defined-binding-expression.ts
var import_compiler18 = require("@marko/compiler");
function getDeclaredBindingExpression(binding) {
  const canonicalBinding = getCanonicalBinding(binding);
  if (canonicalBinding.declared || !canonicalBinding.upstreamAlias || canonicalBinding.excludeProperties !== void 0) {
    return import_compiler18.types.identifier(canonicalBinding.name);
  } else if (canonicalBinding.property !== void 0) {
    return toMemberExpression(
      getDeclaredBindingExpression(canonicalBinding.upstreamAlias),
      canonicalBinding.property,
      canonicalBinding.upstreamAlias.nullable
    );
  } else {
    return getDeclaredBindingExpression(canonicalBinding.upstreamAlias);
  }
}

// src/translator/util/to-first-expression-or-block.ts
var import_compiler19 = require("@marko/compiler");
function toFirstExpressionOrBlock(stmts) {
  if (stmts.length === 1 && import_compiler19.types.isExpressionStatement(stmts[0])) {
    const { expression } = stmts[0];
    switch (expression.type) {
      case "ObjectExpression":
      case "AssignmentExpression":
        return toParenthesizedExpressionIfNeeded(expression);
      default:
        return expression;
    }
  }
  return import_compiler19.types.blockStatement(stmts);
}
function toParenthesizedExpressionIfNeeded(expr) {
  switch (expr.type) {
    case "ObjectExpression":
    case "AssignmentExpression":
      return import_compiler19.types.parenthesizedExpression(expr);
    default:
      return expr;
  }
}

// src/translator/util/signals.ts
var [getSignals] = createSectionState(
  "signals",
  () => /* @__PURE__ */ new Map()
);
var [getClosureSignalBuilder, _setClosureSignalBuilder] = createSectionState("queue");
function setClosureSignalBuilder(tag, builder) {
  _setClosureSignalBuilder(getSectionForBody(tag.get("body")), builder);
}
var [getSerializedAccessors] = createSectionState("serializedScopeProperties", () => /* @__PURE__ */ new Map());
function setSectionSerializedValue(section, prop, expression) {
  const reason = getSectionSerializeReason(section, prop);
  if (reason) {
    getSerializedAccessors(section).set(prop, { expression, reason });
  }
}
function setBindingSerializedValue(section, binding, expression, prefix2) {
  const reason = getBindingSerializeReason(section, binding, prefix2);
  if (reason) {
    getSerializedAccessors(section).set(
      (prefix2 || "") + getScopeAccessor(binding),
      { expression, reason }
    );
  }
}
var nonAnalyzedForceSerializedSection = /* @__PURE__ */ new WeakSet();
function setSerializedValue(section, key, expression) {
  nonAnalyzedForceSerializedSection.add(section);
  getSerializedAccessors(section).set(key, { expression, reason: true });
}
var [getSectionWriteScopeBuilder, setSectionWriteScopeBuilder] = createSectionState(
  "sectionWriteScopeBuilder"
);
function addWriteScopeBuilder(section, builder) {
  const prev = getSectionWriteScopeBuilder(section);
  setSectionWriteScopeBuilder(
    section,
    prev ? (expr) => builder(prev(expr)) : builder
  );
}
var htmlDynamicClosureInstancesIdentifier = /* @__PURE__ */ new WeakMap();
var [getHTMLSectionStatements] = createSectionState(
  "htmlScopeStatements",
  () => []
);
var [getHoistFunctionsIdsMap] = createSectionState("hoistFunctionsIdsMap", () => /* @__PURE__ */ new Map());
function getHoistFunctionIdentifier(hoistedBinding) {
  const idsMap = getHoistFunctionsIdsMap(hoistedBinding.section);
  let identifier = idsMap.get(hoistedBinding);
  if (!identifier) {
    idsMap.set(
      hoistedBinding,
      identifier = generateUidIdentifier(`get${hoistedBinding.name}`)
    );
  }
  return identifier;
}
function getSignal(section, referencedBindings, name2 = generateSignalName(referencedBindings)) {
  const signals = getSignals(section);
  let signal = signals.get(referencedBindings);
  if (!signal) {
    const exportName = referencedBindings ? !Array.isArray(referencedBindings) && referencedBindings.section === section && referencedBindings.export : !section.parent && (0, import_babel_utils14.getProgram)().node.extra.domExports?.setup;
    signals.set(
      referencedBindings,
      signal = {
        identifier: exportName ? import_compiler20.types.identifier(exportName) : generateUidIdentifier(name2 + section.name.replace("_", "$")),
        referencedBindings,
        section,
        values: [],
        intersection: void 0,
        render: [],
        renderReferencedBindings: void 0,
        effect: [],
        effectReferencedBindings: void 0,
        subscribers: [],
        build: void 0,
        export: !!exportName
      }
    );
    if (isOutputHTML()) {
      return signal;
    } else if (!referencedBindings) {
      signal.build = () => getSignalFn(signal);
    } else if (Array.isArray(referencedBindings)) {
      subscribe(referencedBindings, signal);
      signal.build = () => {
        const { id, scopeOffset } = intersectionMeta.get(referencedBindings);
        return callRuntime(
          "intersection",
          import_compiler20.types.numericLiteral(id),
          getSignalFn(signal),
          scopeOffset || referencedBindings.length > 2 ? import_compiler20.types.numericLiteral(referencedBindings.length - 1) : void 0,
          scopeOffset && getScopeAccessorLiteral(scopeOffset)
        );
      };
    } else if (referencedBindings.section !== section && bindingUtil.find(section.referencedClosures, referencedBindings)) {
      signal.build = () => {
        const canonicalClosure = getCanonicalBinding(referencedBindings);
        const render = getSignalFn(signal);
        const closureSignalBuilder = getClosureSignalBuilder(section);
        return !closureSignalBuilder || isDynamicClosure(section, canonicalClosure) ? callRuntime(
          "dynamicClosureRead",
          getScopeAccessorLiteral(canonicalClosure),
          render,
          isImmediateOwner(section, canonicalClosure) ? void 0 : import_compiler20.types.arrowFunctionExpression(
            [scopeIdentifier],
            getScopeExpression(section, canonicalClosure.section)
          )
        ) : getClosureSignalBuilder(section)(canonicalClosure, render);
      };
    }
  }
  return signal;
}
function initValue(binding, runtimeHelper = "value") {
  const section = binding.section;
  const signal = getSignal(section, binding);
  signal.build = () => {
    const fn = getSignalFn(signal);
    const isParamBinding = !binding.upstreamAlias && (binding.type === 3 /* param */ || binding.type === 4 /* local */ || binding.type === 2 /* input */);
    const isNakedAlias = binding.upstreamAlias && binding.property === void 0 && binding.excludeProperties === void 0;
    const needsGuard = !isNakedAlias && (binding.closureSections || binding.downstreamExpressions.size || fn.type === "ArrowFunctionExpression" && fn.body.body.length > 0);
    const needsCache = needsGuard || signal.intersection;
    const needsMarks = isParamBinding || signal.intersection;
    if (needsCache || needsMarks || binding.hoists.size) {
      return callRuntime(
        runtimeHelper,
        getScopeAccessorLiteral(binding, runtimeHelper === "state"),
        fn
      );
    } else {
      return fn;
    }
  };
  signal.valueAccessor = getScopeAccessorLiteral(binding);
  for (const alias of binding.aliases) {
    initValue(alias);
  }
  for (const alias of binding.propertyAliases.values()) {
    initValue(alias);
  }
  return signal;
}
function getSignalFn(signal) {
  const section = signal.section;
  const binding = signal.referencedBindings;
  const params = [scopeIdentifier];
  const isIntersection = Array.isArray(binding);
  const isBinding = binding && !isIntersection;
  const isValue = isBinding && binding.section === section;
  if (isBinding && (signal.renderReferencedBindings || binding.aliases.size || binding.propertyAliases.size)) {
    const valueParam = import_compiler20.types.identifier(binding.name);
    if (binding.loc) {
      valueParam.loc = binding.loc;
      valueParam.start = binding.loc.start.index;
      valueParam.end = binding.loc.end.index;
    }
    params.push(valueParam);
  }
  if (isValue) {
    for (const alias of binding.aliases) {
      const aliasSignal = getSignal(alias.section, alias);
      if (aliasSignal.render.length || aliasSignal.values.length || aliasSignal.effect.length) {
        if (alias.excludeProperties !== void 0) {
          const props = [];
          const aliasId = import_compiler20.types.identifier(alias.name);
          forEach(alias.excludeProperties, (name2) => {
            const propId = toPropertyName(name2);
            const shorthand = propId.type === "Identifier";
            props.push(
              import_compiler20.types.objectProperty(
                propId,
                propId.type === "Identifier" ? propId : import_compiler20.types.objectPattern([]),
                false,
                shorthand
              )
            );
          });
          props.push(import_compiler20.types.restElement(aliasId));
          signal.render.push(
            import_compiler20.types.expressionStatement(
              import_compiler20.types.callExpression(
                import_compiler20.types.arrowFunctionExpression(
                  [import_compiler20.types.objectPattern(props)],
                  import_compiler20.types.callExpression(aliasSignal.identifier, [
                    scopeIdentifier,
                    aliasId,
                    ...getTranslatedExtraArgs(aliasSignal)
                  ])
                ),
                [import_compiler20.types.identifier(binding.name)]
              )
            )
          );
        } else {
          signal.render.push(
            import_compiler20.types.expressionStatement(
              import_compiler20.types.callExpression(aliasSignal.identifier, [
                scopeIdentifier,
                import_compiler20.types.identifier(binding.name),
                ...getTranslatedExtraArgs(aliasSignal)
              ])
            )
          );
        }
      }
    }
    for (const [key, alias] of binding.propertyAliases) {
      const aliasSignal = getSignal(alias.section, alias);
      signal.render.push(
        import_compiler20.types.expressionStatement(
          import_compiler20.types.callExpression(aliasSignal.identifier, [
            scopeIdentifier,
            toMemberExpression(
              import_compiler20.types.identifier(binding.name),
              key,
              binding.nullable
            ),
            ...getTranslatedExtraArgs(aliasSignal)
          ])
        )
      );
    }
  }
  for (const value of signal.values) {
    const valSignal = value.signal;
    if (!valSignal.referencedBindings || Array.isArray(valSignal.referencedBindings) || !valSignal.referencedBindings.upstreamAlias || valSignal.referencedBindings.property !== void 0 || valSignal.referencedBindings.excludeProperties !== void 0 || valSignal.effect.length || valSignal.render.length || valSignal.values.length) {
      signal.render.push(
        import_compiler20.types.expressionStatement(
          import_compiler20.types.callExpression(value.signal.identifier, [
            scopeIdentifier,
            value.value,
            ...getTranslatedExtraArgs(value.signal)
          ])
        )
      );
    } else {
      signal.render.push(import_compiler20.types.expressionStatement(value.value));
    }
  }
  forEach(signal.intersection, (intersection) => {
    signal.render.push(
      import_compiler20.types.expressionStatement(
        import_compiler20.types.callExpression(intersection.identifier, [scopeIdentifier])
      )
    );
  });
  if (isValue && binding.sources && binding.type !== 4 /* local */) {
    let dynamicClosureArgs;
    let dynamicClosureSignalIdentifier;
    if (binding.sources) {
      forEach(binding.closureSections, (closureSection) => {
        if (isDynamicClosure(closureSection, binding)) {
          if (!dynamicClosureArgs) {
            dynamicClosureArgs = [];
            dynamicClosureSignalIdentifier = generateUidIdentifier(
              signal.identifier.name + "_closure"
            );
            signal.render.push(
              import_compiler20.types.expressionStatement(
                import_compiler20.types.callExpression(dynamicClosureSignalIdentifier, [
                  scopeIdentifier
                ])
              )
            );
          }
          dynamicClosureArgs.push(
            getSignal(closureSection, binding).identifier
          );
        } else {
          signal.render.push(
            import_compiler20.types.expressionStatement(
              import_compiler20.types.callExpression(getSignal(closureSection, binding).identifier, [
                scopeIdentifier
              ])
            )
          );
        }
      });
      if (dynamicClosureSignalIdentifier) {
        (signal.prependStatements ||= []).push(
          import_compiler20.types.variableDeclaration("const", [
            import_compiler20.types.variableDeclarator(
              dynamicClosureSignalIdentifier,
              callRuntime("dynamicClosure", ...dynamicClosureArgs)
            )
          ])
        );
      }
    }
  }
  if (signal.effect.length) {
    const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);
    signal.render.push(
      import_compiler20.types.expressionStatement(
        import_compiler20.types.callExpression(effectIdentifier, [scopeIdentifier])
      )
    );
  }
  if (isIntersection && signal.renderReferencedBindings) {
    signal.render.unshift(
      import_compiler20.types.variableDeclaration("const", [
        import_compiler20.types.variableDeclarator(
          createScopeReadPattern(section, signal.renderReferencedBindings),
          scopeIdentifier
        )
      ])
    );
  }
  if (signal.render.length === 1) {
    const render = signal.render[0];
    if (render.type === "ExpressionStatement") {
      const { expression } = render;
      if (expression.type === "CallExpression") {
        const args = expression.arguments;
        if (params.length >= args.length) {
          let i = args.length;
          for (; i--; ) {
            const param = params[i];
            const arg = args[i];
            if (arg.type !== "Identifier" || param.type !== "Identifier" || param.name !== arg.name) {
              break;
            }
          }
          if (i === -1) {
            if (expression.callee.type === "MemberExpression" && expression.callee.property.type === "Identifier" && expression.callee.property.name === "_") {
              return expression.callee.object;
            }
            return expression.callee;
          }
        }
      }
    }
  }
  return import_compiler20.types.arrowFunctionExpression(params, import_compiler20.types.blockStatement(signal.render));
}
var hasTranslatedExtraArgs = /* @__PURE__ */ new WeakSet();
var emptyExtraArgs = [];
function getTranslatedExtraArgs(signal) {
  if (signal.extraArgs) {
    if (!hasTranslatedExtraArgs.has(signal)) {
      hasTranslatedExtraArgs.add(signal);
      traverseReplace(signal, "extraArgs", replaceRenderNode);
    }
    return signal.extraArgs;
  }
  return emptyExtraArgs;
}
function subscribe(references, subscriber) {
  if (references) {
    forEach(references, (binding) => {
      const source = binding.property === void 0 && binding.excludeProperties === void 0 && binding.upstreamAlias || binding;
      const providerSignal = getSignal(subscriber.section, source);
      providerSignal.intersection = push(
        providerSignal.intersection,
        subscriber
      );
    });
  }
}
function generateSignalName(referencedBindings) {
  let name2;
  if (referencedBindings) {
    if (Array.isArray(referencedBindings)) {
      name2 = "expr";
      for (const ref of referencedBindings) {
        name2 += `_${ref.name}`;
      }
    } else {
      name2 = referencedBindings.name;
    }
  } else {
    name2 = "setup";
  }
  return name2;
}
function replaceNullishAndEmptyFunctionsWith0(args) {
  for (let i = args.length; i--; ) {
    const arg = args[i];
    if (!arg) {
      args[i] = import_compiler20.types.numericLiteral(0);
    } else if (import_compiler20.types.isArrowFunctionExpression(arg) && import_compiler20.types.isBlockStatement(arg.body)) {
      const body = arg.body.body;
      if (body.length === 0) {
        args[i] = import_compiler20.types.numericLiteral(0);
      } else if (body.length === 1 && import_compiler20.types.isExpressionStatement(body[0])) {
        arg.body = toParenthesizedExpressionIfNeeded(body[0].expression);
      }
    } else if (import_compiler20.types.isNullLiteral(arg) || import_compiler20.types.isUnaryExpression(arg) && arg.operator === "void") {
      args[i] = import_compiler20.types.numericLiteral(0);
    }
  }
  for (let i = args.length - 1; import_compiler20.types.isNumericLiteral(args[i]) && args[i].value === 0; ) {
    args.length = i--;
  }
  return args;
}
function addStatement(type, targetSection, referencedBindings, statement, usedReferences) {
  const signal = getSignal(targetSection, referencedBindings);
  const statements = signal[type] ??= [];
  const add = type === "effect" ? addEffectReferences : addRenderReferences;
  if (Array.isArray(statement)) {
    statements.push(...statement);
  } else {
    statements.push(statement);
  }
  if (usedReferences !== false) {
    if (usedReferences) {
      for (const ref of usedReferences) {
        add(signal, ref);
      }
    } else {
      add(signal, referencedBindings);
    }
  }
}
function addEffectReferences(signal, referencedBindings) {
  signal.effectReferencedBindings = bindingUtil.union(
    signal.effectReferencedBindings,
    referencedBindings
  );
}
function addRenderReferences(signal, referencedBindings) {
  signal.renderReferencedBindings = bindingUtil.union(
    signal.renderReferencedBindings,
    referencedBindings
  );
}
function addValue(targetSection, referencedBindings, signal, value) {
  const parentSignal = getSignal(targetSection, referencedBindings);
  addRenderReferences(parentSignal, referencedBindings);
  parentSignal.values.push({
    signal,
    value
  });
}
function getResumeRegisterId(section, referencedBindings, type) {
  const {
    markoOpts,
    opts: { filename }
  } = (0, import_babel_utils14.getFile)();
  let name2 = "";
  if (referencedBindings) {
    if (typeof referencedBindings === "string") {
      name2 += `_${referencedBindings}`;
    } else if (Array.isArray(referencedBindings)) {
      for (const ref of referencedBindings) {
        name2 += `_${ref.name}`;
      }
    } else {
      name2 += `_${referencedBindings.name}`;
    }
  }
  return (0, import_babel_utils14.getTemplateId)(
    markoOpts,
    filename,
    `${section.id}${name2}${type ? "/" + type : ""}`
  );
}
var usedRegisterIdsBySection = /* @__PURE__ */ new WeakMap();
function getRegisterUID(section, name2) {
  const {
    markoOpts,
    opts: { filename }
  } = (0, import_babel_utils14.getFile)();
  let used = usedRegisterIdsBySection.get(section);
  if (!used) usedRegisterIdsBySection.set(section, used = /* @__PURE__ */ new Set());
  const baseId = (0, import_babel_utils14.getTemplateId)(
    markoOpts,
    filename,
    `${section.id}/${name2}`
  );
  let count = 0;
  let id = baseId;
  while (used.has(id)) {
    id = baseId + "_" + ++count;
  }
  used.add(id);
  return id;
}
function writeSignals(section) {
  const seen = /* @__PURE__ */ new Set();
  writeHoists(section);
  for (const signal of getSignals(section).values()) {
    writeSignal(signal);
  }
  function writeSignal(signal) {
    if (!signal.build || seen.has(signal)) return;
    seen.add(signal);
    for (const value2 of signal.values) {
      writeSignal(value2.signal);
      traverseReplace(value2, "value", replaceRenderNode);
    }
    forEach(signal.intersection, writeSignal);
    traverseReplace(signal, "render", replaceRenderNode);
    let effectDeclarator;
    if (signal.effect.length) {
      traverseReplace(signal, "effect", replaceEffectNode);
      const effectIdentifier = import_compiler20.types.identifier(`${signal.identifier.name}_effect`);
      const referencedBindings = signal.effectReferencedBindings;
      const referencesScope = traverseContains(
        signal.effect,
        isScopeIdentifier
      );
      effectDeclarator = import_compiler20.types.variableDeclarator(
        effectIdentifier,
        callRuntime(
          "effect",
          import_compiler20.types.stringLiteral(
            getResumeRegisterId(section, signal.referencedBindings)
          ),
          import_compiler20.types.arrowFunctionExpression(
            referencedBindings ? referencesScope ? [
              scopeIdentifier,
              createScopeReadPattern(section, referencedBindings)
            ] : [createScopeReadPattern(section, referencedBindings)] : referencesScope ? [scopeIdentifier] : [],
            toFirstExpressionOrBlock(signal.effect)
          )
        )
      );
    }
    let value = signal.build();
    if (
      // It's possible for aliases to render nothing
      // if they're only consumed in effects/closures.
      // This ignores writing out those signals in that case.
      signal.referencedBindings && !Array.isArray(signal.referencedBindings) && signal.referencedBindings.upstreamAlias && signal.referencedBindings.property === void 0 && signal.referencedBindings.excludeProperties === void 0 && import_compiler20.types.isFunction(value) && import_compiler20.types.isBlockStatement(value.body) && !value.body.body.length
    ) {
      return;
    }
    if (import_compiler20.types.isCallExpression(value)) {
      replaceNullishAndEmptyFunctionsWith0(value.arguments);
    }
    if (signal.register) {
      value = callRuntime(
        "registerBoundSignal",
        import_compiler20.types.stringLiteral(
          getResumeRegisterId(section, signal.referencedBindings, "var")
        ),
        value
      );
    }
    const signalDeclarator = import_compiler20.types.variableDeclarator(signal.identifier, value);
    let signalDeclaration = !section.parent && !signal.referencedBindings && (import_compiler20.types.isFunctionExpression(value) || import_compiler20.types.isArrowFunctionExpression(value)) ? import_compiler20.types.functionDeclaration(
      signal.identifier,
      value.params,
      import_compiler20.types.isExpression(value.body) ? import_compiler20.types.blockStatement([import_compiler20.types.expressionStatement(value.body)]) : value.body
    ) : import_compiler20.types.variableDeclaration("const", [signalDeclarator]);
    if (signal.export) {
      signalDeclaration = import_compiler20.types.exportNamedDeclaration(signalDeclaration);
    }
    const signalStatements = signal.prependStatements || [];
    if (effectDeclarator) {
      signalStatements.push(import_compiler20.types.variableDeclaration("const", [effectDeclarator]));
    }
    signalStatements.push(signalDeclaration);
    (0, import_babel_utils14.getProgram)().node.body.push(...signalStatements);
  }
}
function writeHoists(section) {
  forEach(section.hoisted, (binding) => {
    for (const hoistedBinding of binding.hoists.values()) {
      const accessors = [
        binding.type === 0 /* dom */ ? import_compiler20.types.stringLiteral(
          getAccessorPrefix().Getter + getScopeAccessor(binding)
        ) : getScopeAccessorLiteral(binding)
      ];
      let currentSection = section;
      while (currentSection && currentSection !== hoistedBinding.section) {
        const parentSection = currentSection.parent;
        if (parentSection) {
          accessors.push(getSectionInstancesAccessorLiteral(currentSection));
        }
        currentSection = parentSection;
      }
      const hoistIdentifier = getHoistFunctionIdentifier(hoistedBinding);
      (0, import_babel_utils14.getProgram)().node.body.push(
        import_compiler20.types.variableDeclaration("const", [
          import_compiler20.types.variableDeclarator(
            hoistIdentifier,
            hoistedBinding.downstreamExpressions.size ? callRuntime(
              "register",
              import_compiler20.types.stringLiteral(
                getResumeRegisterId(
                  hoistedBinding.section,
                  hoistedBinding,
                  "hoist"
                )
              ),
              callRuntime("hoist", ...accessors)
            ) : callRuntime("hoist", ...accessors)
          )
        ])
      );
      if (hoistedBinding.downstreamExpressions.size) {
        addValue(
          hoistedBinding.section,
          void 0,
          initValue(hoistedBinding),
          import_compiler20.types.callExpression(hoistIdentifier, [scopeIdentifier])
        );
      }
    }
  });
}
function writeRegisteredFns() {
  const registeredFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);
  const statements = [];
  if (registeredFns) {
    for (const registeredFn of registeredFns) {
      let fn;
      const params = registeredFn.referencedBindings ? registeredFn.referencesScope ? [
        scopeIdentifier,
        import_compiler20.types.assignmentPattern(
          createScopeReadPattern(
            registeredFn.section,
            registeredFn.referencedBindings
          ),
          scopeIdentifier
        )
      ] : [
        createScopeReadPattern(
          registeredFn.section,
          registeredFn.referencedBindings
        )
      ] : registeredFn.referencesScope ? [scopeIdentifier] : void 0;
      if (params) {
        fn = import_compiler20.types.functionDeclaration(
          import_compiler20.types.identifier(registeredFn.id),
          params,
          import_compiler20.types.blockStatement(toReturnedFunction(registeredFn.node))
        );
      } else if (registeredFn.node.type === "FunctionDeclaration" && registeredFn.node.id?.name === registeredFn.id) {
        fn = registeredFn.node;
      } else {
        fn = import_compiler20.types.functionDeclaration(
          import_compiler20.types.identifier(registeredFn.id),
          registeredFn.node.params,
          registeredFn.node.body.type === "BlockStatement" ? registeredFn.node.body : import_compiler20.types.blockStatement([import_compiler20.types.returnStatement(registeredFn.node.body)]),
          registeredFn.node.generator,
          registeredFn.node.async
        );
      }
      statements.push(fn);
    }
    for (const registeredFn of registeredFns) {
      statements.push(
        import_compiler20.types.expressionStatement(
          callRuntime(
            "register",
            import_compiler20.types.stringLiteral(registeredFn.registerId),
            import_compiler20.types.identifier(registeredFn.id)
          )
        )
      );
    }
    (0, import_babel_utils14.getProgram)().node.body.push(...statements);
  }
}
function toReturnedFunction(rawFn) {
  const fn = simplifyFunction(rawFn);
  return fn.type === "FunctionDeclaration" ? [fn, import_compiler20.types.returnStatement(fn.id)] : [import_compiler20.types.returnStatement(fn)];
}
function addHTMLEffectCall(section, referencedBindings) {
  addStatement("effect", section, referencedBindings, void 0, false);
}
function writeHTMLResumeStatements(path5) {
  const section = getSectionForBody(path5);
  if (!section) return;
  const body = path5.node.body;
  const allSignals = Array.from(getSignals(section).values());
  const scopeIdIdentifier = getScopeIdIdentifier(section);
  forEach(section.referencedClosures, (closure) => {
    if (closure.sources) {
      if (isDynamicClosure(section, closure)) {
        const closureSignal = getSignal(closure.section, closure);
        let identifier = htmlDynamicClosureInstancesIdentifier.get(closureSignal);
        if (!identifier) {
          htmlDynamicClosureInstancesIdentifier.set(
            closureSignal,
            identifier = generateUidIdentifier(
              closureSignal.identifier.name + "_closures"
            )
          );
          getHTMLSectionStatements(closure.section).push(
            import_compiler20.types.variableDeclaration("const", [
              import_compiler20.types.variableDeclarator(
                identifier,
                import_compiler20.types.newExpression(import_compiler20.types.identifier("Set"), [])
              )
            ])
          );
          setBindingSerializedValue(
            closure.section,
            closure,
            identifier,
            getAccessorPrefix().ClosureScopes
          );
        }
        setBindingSerializedValue(
          section,
          closure,
          import_compiler20.types.numericLiteral(getDynamicClosureIndex(closure, section)),
          getAccessorPrefix().ClosureSignalIndex
        );
        addWriteScopeBuilder(
          section,
          (expr) => callRuntime("writeSubscribe", identifier, expr)
        );
      }
    }
  });
  const sectionDynamicSubscribers = /* @__PURE__ */ new Set();
  forEach(section.hoisted, (binding) => {
    for (const hoistedBinding of binding.hoists.values()) {
      if (hoistedBinding.downstreamExpressions.size) {
        getHTMLSectionStatements(hoistedBinding.section).push(
          import_compiler20.types.variableDeclaration("const", [
            import_compiler20.types.variableDeclarator(
              import_compiler20.types.identifier(hoistedBinding.name),
              callRuntime(
                "hoist",
                getScopeIdIdentifier(hoistedBinding.section),
                import_compiler20.types.stringLiteral(
                  getResumeRegisterId(
                    hoistedBinding.section,
                    hoistedBinding,
                    "hoist"
                  )
                )
              )
            )
          ])
        );
      }
      let currentSection = section;
      while (currentSection && currentSection !== hoistedBinding.section) {
        const parentSection = currentSection.parent;
        if (!currentSection.sectionAccessor && !sectionDynamicSubscribers.has(currentSection)) {
          const subscribersIdentifier = generateUidIdentifier(
            `${currentSection.name}_subscribers`
          );
          sectionDynamicSubscribers.add(currentSection);
          getHTMLSectionStatements(parentSection).push(
            import_compiler20.types.variableDeclaration("const", [
              import_compiler20.types.variableDeclarator(
                subscribersIdentifier,
                import_compiler20.types.newExpression(import_compiler20.types.identifier("Set"), [])
              )
            ])
          );
          addWriteScopeBuilder(
            currentSection,
            (expr) => callRuntime("writeSubscribe", subscribersIdentifier, expr)
          );
          setSerializedValue(
            parentSection,
            getSectionInstancesAccessor(currentSection),
            subscribersIdentifier
          );
        }
        currentSection = parentSection;
      }
    }
    if (binding.hoists.size && binding.type !== 0 /* dom */) {
      setBindingSerializedValue(
        section,
        binding,
        getDeclaredBindingExpression(binding)
      );
    }
  });
  for (let i = allSignals.length; i--; ) {
    if (allSignals[i].effect.length) {
      const signalRefs = allSignals[i].referencedBindings;
      body.push(
        import_compiler20.types.expressionStatement(
          callRuntime(
            "writeEffect",
            scopeIdIdentifier,
            import_compiler20.types.stringLiteral(getResumeRegisterId(section, signalRefs))
          )
        )
      );
    }
  }
  const debug = !isOptimize();
  const writeScopeBuilder = getSectionWriteScopeBuilder(section);
  const serializedLookup = getSerializedAccessors(section);
  const serializedProperties = [];
  const sectionSerializeReason = nonAnalyzedForceSerializedSection.has(section) ? true : section.serializeReason;
  let debugVars;
  const writeSerializedBinding = (binding) => {
    const reason = getBindingSerializeReason(section, binding);
    if (!reason) return;
    const accessor = getScopeAccessor(binding);
    serializedLookup.delete(accessor);
    serializedProperties.push(
      toObjectProperty(
        accessor,
        sectionSerializeReason && (sectionSerializeReason === reason || sectionSerializeReason !== true && reason !== true && compareSources(sectionSerializeReason, reason) === 0) ? getDeclaredBindingExpression(binding) : getExprIfSerialized(reason, getDeclaredBindingExpression(binding))
      )
    );
    if (debug) {
      const { root, access } = getDebugScopeAccess(binding);
      const locExpr = root.loc && import_compiler20.types.stringLiteral(`${root.loc.start.line}:${root.loc.start.column + 1}`);
      (debugVars ||= []).push(
        toObjectProperty(
          getScopeAccessor(binding),
          root !== binding ? import_compiler20.types.arrayExpression(
            locExpr ? [import_compiler20.types.stringLiteral(root.name + access), locExpr] : [import_compiler20.types.stringLiteral(root.name + access)]
          ) : locExpr || import_compiler20.types.numericLiteral(0)
        )
      );
    }
  };
  forEach(section.bindings, (binding) => {
    if (binding.type !== 0 /* dom */ && binding.type !== 4 /* local */) {
      writeSerializedBinding(binding);
    }
  });
  forEach(section.referencedLocalClosures, writeSerializedBinding);
  if (section.parent) {
    const ownerAccessor = getAccessorProp().Owner;
    const ownerReason = getSectionSerializeReason(section, ownerAccessor);
    if (ownerReason) {
      const getOwnerExpr = callRuntime(
        "ensureScopeWithId",
        getScopeIdIdentifier(section.parent)
      );
      serializedLookup.delete(ownerAccessor);
      serializedProperties.push(
        toObjectProperty(
          ownerAccessor,
          sectionSerializeReason && (sectionSerializeReason === ownerReason || sectionSerializeReason !== true && ownerReason !== true && compareSources(sectionSerializeReason, ownerReason) === 0) ? getOwnerExpr : getExprIfSerialized(ownerReason, getOwnerExpr)
        )
      );
    }
  }
  for (const [key, { expression, reason }] of serializedLookup) {
    serializedProperties.push(
      toObjectProperty(key, getExprIfSerialized(reason, expression))
    );
  }
  if (sectionSerializeReason) {
    for (const prop of serializedProperties) {
      if (prop.key.type === "Identifier" && prop.value.type === "Identifier" && prop.key.name === prop.value.name) {
        prop.shorthand = true;
      }
    }
    const writeScopeArgs = [
      scopeIdIdentifier,
      import_compiler20.types.objectExpression(serializedProperties)
    ];
    if (debug) {
      writeScopeArgs.push(
        import_compiler20.types.stringLiteral(path5.hub.file.opts.filenameRelative),
        section.loc && section.loc.start.line != null ? import_compiler20.types.stringLiteral(
          `${section.loc.start.line}:${section.loc.start.column + 1}`
        ) : import_compiler20.types.numericLiteral(0)
      );
      if (debugVars) {
        writeScopeArgs.push(import_compiler20.types.objectExpression(debugVars));
      }
    }
    let writeScopeCall = writeScopeBuilder ? writeScopeBuilder(callRuntime("writeScope", ...writeScopeArgs)) : callRuntime("writeScope", ...writeScopeArgs);
    if (sectionSerializeReason !== true && !sectionSerializeReason.state) {
      writeScopeCall = import_compiler20.types.logicalExpression(
        "&&",
        getSerializeGuard(sectionSerializeReason, false),
        writeScopeCall
      );
    }
    body.push(import_compiler20.types.expressionStatement(writeScopeCall));
  }
  const resumeClosestBranch2 = !section.isBranch && (section.hasAbortSignal || !!section.referencedClosures || !!find(section.bindings, (binding) => binding.type === 1 /* let */));
  if (resumeClosestBranch2) {
    body.push(
      import_compiler20.types.expressionStatement(
        callRuntime("resumeClosestBranch", scopeIdIdentifier)
      )
    );
  }
  const additionalStatements = getHTMLSectionStatements(section);
  if (body.length || additionalStatements.length) {
    body.unshift(
      import_compiler20.types.variableDeclaration("const", [
        import_compiler20.types.variableDeclarator(scopeIdIdentifier, callRuntime("nextScopeId"))
      ]),
      ...additionalStatements
    );
  }
  const returnIdentifier = getSectionReturnValueIdentifier(section);
  if (returnIdentifier !== void 0) {
    body.push(import_compiler20.types.returnStatement(returnIdentifier));
  }
}
function getSetup(section) {
  return getSignals(section).get(void 0)?.identifier;
}
function replaceRenderNode(node) {
  return replaceAssignedNode(node) || replaceBindingReadNode2(node) || replaceRegisteredFunctionNode2(node);
}
function replaceEffectNode(node) {
  return replaceAssignedNode(node) || replaceBindingReadNode2(node);
}
function replaceBindingReadNode2(node) {
  switch (node.type) {
    case "Identifier":
    case "MemberExpression": {
      return getReadReplacement(node);
    }
  }
}
var updateExpressions = /* @__PURE__ */ new WeakSet();
function replaceAssignedNode(node) {
  switch (node.type) {
    case "ExpressionStatement": {
      if (node.expression.type === "SequenceExpression" && updateExpressions.delete(node.expression)) {
        return node.expression.expressions[0];
      }
      break;
    }
    case "UpdateExpression": {
      const { extra } = node.argument;
      if (isAssignedBindingExtra(extra)) {
        const buildAssignment = getBuildAssignment(extra);
        if (buildAssignment) {
          if (!node.prefix) {
            node.prefix = true;
            const replacement = import_compiler20.types.sequenceExpression([
              buildAssignment(extra.section, node),
              import_compiler20.types.binaryExpression(
                node.operator === "++" ? "-" : "+",
                node.argument,
                import_compiler20.types.numericLiteral(1)
              )
            ]);
            updateExpressions.add(replacement);
            return replacement;
          }
          return buildAssignment(extra.section, node);
        }
      }
      break;
    }
    case "AssignmentExpression":
      switch (node.left.type) {
        case "Identifier": {
          const { extra } = node.left;
          if (isAssignedBindingExtra(extra)) {
            const buildAssignment = getBuildAssignment(extra);
            if (buildAssignment) {
              if (bindingUtil.has(
                extra.fnExtra?.referencedBindingsInFunction,
                extra.assignment
              )) {
                return buildAssignment(extra.section, node);
              } else {
                return buildAssignment(
                  extra.section,
                  node.operator === "=" ? node.right : import_compiler20.types.binaryExpression(
                    node.operator.slice(
                      0,
                      -1
                    ),
                    node.left,
                    node.right
                  )
                );
              }
            }
          }
          break;
        }
        case "ArrayPattern":
        case "ObjectPattern": {
          let params;
          let assignments;
          forEachIdentifier(node.left, (id) => {
            const { extra } = id;
            if (isAssignedBindingExtra(extra)) {
              const buildAssignment = getBuildAssignment(extra);
              if (buildAssignment) {
                if (!bindingUtil.has(
                  extra.fnExtra?.referencedBindingsInFunction,
                  extra.assignment
                )) {
                  id.name = generateUid(id.name);
                  (params ||= []).push(import_compiler20.types.identifier(id.name));
                }
                (assignments ||= []).push(
                  buildAssignment(extra.section, import_compiler20.types.identifier(id.name))
                );
              }
            }
          });
          if (assignments) {
            const resultId = generateUid("result");
            return import_compiler20.types.callExpression(
              import_compiler20.types.arrowFunctionExpression(
                [import_compiler20.types.identifier(resultId), ...params || []],
                import_compiler20.types.sequenceExpression([
                  import_compiler20.types.assignmentExpression(
                    "=",
                    node.left,
                    import_compiler20.types.identifier(resultId)
                  ),
                  ...assignments,
                  import_compiler20.types.identifier(resultId)
                ])
              ),
              [node.right]
            );
          }
          break;
        }
      }
      break;
  }
}
function getBuildAssignment(extra) {
  const { assignmentTo, assignment } = extra;
  if (assignmentTo) {
    return (_section, value) => {
      return import_compiler20.types.callExpression(import_compiler20.types.identifier(assignmentTo.name), [value]);
    };
  }
  return getSignal(assignment.section, assignment).buildAssignment;
}
var registeredFnsForProgram = /* @__PURE__ */ new WeakMap();
function replaceRegisteredFunctionNode2(node) {
  switch (node.type) {
    case "ClassMethod": {
      const replacement = getRegisteredFnExpression2(node);
      return replacement && import_compiler20.types.classProperty(node.key, replacement);
    }
    case "ClassPrivateMethod": {
      const replacement = getRegisteredFnExpression2(node);
      return replacement && import_compiler20.types.classPrivateProperty(node.key, replacement);
    }
    case "ObjectMethod": {
      const replacement = getRegisteredFnExpression2(node);
      return replacement && import_compiler20.types.objectProperty(node.key, replacement);
    }
    case "ArrowFunctionExpression":
    case "FunctionExpression": {
      return getRegisteredFnExpression2(node);
    }
    case "FunctionDeclaration": {
      const replacement = getRegisteredFnExpression2(node);
      if (replacement) {
        return import_compiler20.types.variableDeclaration("const", [
          import_compiler20.types.variableDeclarator(node.id, replacement)
        ]);
      }
      break;
    }
  }
}
function getRegisteredFnExpression2(node) {
  const { extra } = node;
  if (isRegisteredFnExtra(extra)) {
    const id = extra.name;
    const referencesScope = extra.referencesScope;
    const referencedBindings = extra.referencedBindingsInFunction;
    let registedFns = registeredFnsForProgram.get((0, import_babel_utils14.getProgram)().node);
    if (!registedFns) {
      registeredFnsForProgram.set((0, import_babel_utils14.getProgram)().node, registedFns = []);
    }
    registedFns.push({
      id,
      node,
      registerId: extra.registerId,
      section: extra.section,
      referencesScope,
      referencedBindings
    });
    if (referencesScope || referencedBindings) {
      return import_compiler20.types.callExpression(import_compiler20.types.identifier(id), [scopeIdentifier]);
    } else {
      return import_compiler20.types.identifier(id);
    }
  }
}

// src/translator/visitors/program/dom.ts
var dom_default = {
  translate: {
    exit(program) {
      visit(program);
      const section = getSectionForBody(program);
      const { walks, writes, setup } = getSectionMeta(section);
      const domExports = program.node.extra.domExports;
      const templateIdentifier = import_compiler21.types.identifier(domExports.template);
      const walksIdentifier = import_compiler21.types.identifier(domExports.walks);
      const setupIdentifier = import_compiler21.types.identifier(domExports.setup);
      const inputBinding = program.node.params[0].extra?.binding;
      const programInputSignal = inputBinding && bindingHasDownstreamExpressions(inputBinding) ? initValue(inputBinding) : void 0;
      const styleFile = getStyleFile(program.hub.file);
      if (styleFile) {
        (0, import_babel_utils15.importDefault)(program.hub.file, styleFile);
      }
      forEachSectionReverse((childSection) => {
        if (childSection !== section) {
          forEach(childSection.referencedClosures, (closure) => {
            const closureSignal = getSignal(childSection, closure);
            addStatement(
              "render",
              childSection,
              void 0,
              import_compiler21.types.expressionStatement(
                import_compiler21.types.callExpression(
                  isDynamicClosure(childSection, closure) ? closureSignal.identifier : import_compiler21.types.memberExpression(
                    closureSignal.identifier,
                    import_compiler21.types.identifier(getAccessorProp().Owner)
                  ),
                  [scopeIdentifier]
                )
              )
            );
          });
          const tagParamsSignal = childSection.params && initValue(childSection.params);
          const { walks: walks2, writes: writes2, setup: setup2 } = getSectionMeta(childSection);
          const identifier = import_compiler21.types.identifier(childSection.name);
          let renderer = getSectionParentIsOwner(childSection) ? callRuntime(
            "createRenderer",
            ...replaceNullishAndEmptyFunctionsWith0([
              writes2,
              walks2,
              setup2,
              tagParamsSignal?.identifier
            ])
          ) : callRuntime(
            isSerializedSection(childSection) ? "registerContent" : "createContent",
            import_compiler21.types.stringLiteral(getResumeRegisterId(childSection, "renderer")),
            ...replaceNullishAndEmptyFunctionsWith0([
              writes2,
              walks2,
              setup2,
              tagParamsSignal?.identifier,
              childSection.hoisted || childSection.isHoistThrough ? getSectionInstancesAccessorLiteral(childSection) : void 0
            ])
          );
          if (childSection.referencedLocalClosures) {
            renderer = callRuntime(
              "localClosures",
              renderer,
              import_compiler21.types.objectExpression(
                toArray(childSection.referencedLocalClosures, (closure) => {
                  const expr = getSignalFn(getSignal(childSection, closure));
                  const key = toPropertyName(getScopeAccessor(closure));
                  if (import_compiler21.types.isFunction(expr) && import_compiler21.types.isBlockStatement(expr.body)) {
                    return import_compiler21.types.objectMethod(
                      "method",
                      key,
                      expr.params,
                      expr.body
                    );
                  }
                  return import_compiler21.types.objectProperty(key, expr);
                })
              )
            );
          }
          writeSignals(childSection);
          program.node.body.push(
            import_compiler21.types.variableDeclaration("const", [
              import_compiler21.types.variableDeclarator(identifier, renderer)
            ])
          );
        }
      });
      writeSignals(section);
      writeRegisteredFns();
      if (!setup) {
        program.node.body.unshift(
          import_compiler21.types.exportNamedDeclaration(
            import_compiler21.types.variableDeclaration("const", [
              import_compiler21.types.variableDeclarator(
                setupIdentifier,
                import_compiler21.types.arrowFunctionExpression([], import_compiler21.types.blockStatement([]))
              )
            ])
          )
        );
      }
      program.node.body.unshift(
        import_compiler21.types.exportNamedDeclaration(
          import_compiler21.types.variableDeclaration("const", [
            import_compiler21.types.variableDeclarator(
              templateIdentifier,
              writes || import_compiler21.types.stringLiteral("")
            )
          ])
        ),
        import_compiler21.types.exportNamedDeclaration(
          import_compiler21.types.variableDeclaration("const", [
            import_compiler21.types.variableDeclarator(walksIdentifier, walks || import_compiler21.types.stringLiteral(""))
          ])
        )
      );
      program.node.body.push(
        import_compiler21.types.exportDefaultDeclaration(
          callRuntime(
            "createTemplate",
            import_compiler21.types.stringLiteral(program.hub.file.metadata.marko.id),
            templateIdentifier,
            walksIdentifier,
            setupIdentifier,
            programInputSignal?.identifier
          )
        )
      );
    }
  }
};

// src/translator/visitors/program/index.ts
var cleanIdentifier;
var scopeIdentifier;
function isScopeIdentifier(node) {
  return node === scopeIdentifier;
}
var program_default = {
  migrate: {
    enter(program) {
      program.node.params = [import_compiler22.types.identifier("input")];
    },
    exit(program) {
      program.scope.crawl();
    }
  },
  analyze: {
    enter(program) {
      startSection(program);
      trackParamsReferences(program, 2 /* input */);
      const programExtra = program.node.extra ??= {};
      const inputBinding = program.node.params[0].extra?.binding;
      if (inputBinding) {
        inputBinding.nullable = false;
      }
      programExtra.domExports = {
        template: generateUid("template"),
        walks: generateUid("walks"),
        setup: generateUid("setup"),
        input: void 0
        // TODO look into recursive components with fine grained params.
      };
      for (const child of program.get("body")) {
        if (isCoreTagName(child, "return")) {
          const { value } = getKnownAttrValues(child.node);
          if (value) {
            programExtra.returnValueExpr = value.extra ??= {};
          }
          break;
        }
      }
    },
    exit(program) {
      finalizeReferences();
      const programExtra = program.node.extra;
      const inputBinding = program.node.params[0].extra?.binding;
      if (inputBinding && bindingHasDownstreamExpressions(inputBinding)) {
        programExtra.domExports.input = buildTemplateExports(
          inputBinding,
          program
        );
      }
    }
  },
  translate: {
    enter(program) {
      scopeIdentifier = isOutputDOM() ? generateUidIdentifier("scope") : null;
      cleanIdentifier = isOutputDOM() ? generateUidIdentifier("clean") : null;
      if (getMarkoOpts().output === "hydrate") {
        const entryFile = program.hub.file;
        const visitedFiles = /* @__PURE__ */ new Set([
          (0, import_babel_utils16.resolveRelativePath)(entryFile, entryFile.opts.filename)
        ]);
        entry_builder_default.visit(entryFile, entryFile, function visitChild(resolved) {
          if (!visitedFiles.has(resolved)) {
            visitedFiles.add(resolved);
            const file = (0, import_babel_utils16.loadFileForImport)(entryFile, resolved);
            if (file) {
              entry_builder_default.visit(
                file,
                entryFile,
                (id) => visitChild(resolveRelativeToEntry(entryFile, file, id))
              );
            }
          }
        });
        program.node.body = entry_builder_default.build(entryFile);
        program.skip();
        return;
      }
    },
    exit(program) {
      if (isOutputHTML()) {
        html_default.translate.exit(program);
      } else {
        dom_default.translate.exit(program);
      }
      if (program.node.extra?.needsCompat) {
        const compatFile = getCompatRuntimeFile();
        const body = [void 0];
        for (const child of program.node.body) {
          if (child.type === "ImportDeclaration" && child.source.value === compatFile) {
            body[0] = child;
          } else {
            body.push(child);
          }
        }
        body[0] ??= import_compiler22.types.importDeclaration([], import_compiler22.types.stringLiteral(compatFile));
        program.node.body = body;
      }
    }
  }
};
function resolveSerializeReasonId(inputSerializeReasons, reason) {
  const id = findIndexSorted(compareReferences, inputSerializeReasons, reason);
  if (id === -1) {
    throw new Error("Unable to resolve serialize reason against input");
  }
  return id;
}
function resolveRelativeToEntry(entryFile, file, req) {
  return file === entryFile ? (0, import_babel_utils16.resolveRelativePath)(file, req) : (0, import_babel_utils16.resolveRelativePath)(
    entryFile,
    req[0] === "." ? import_path2.default.join(file.opts.filename, "..", req) : req
  );
}
function buildTemplateExports(binding, program) {
  const templateExport = {
    id: binding.export ??= generateUid(binding.name),
    binding,
    props: void 0
  };
  if (!(binding.aliases.size || binding.downstreamExpressions.size)) {
    templateExport.props = {};
    for (const [property, alias] of binding.propertyAliases) {
      templateExport.props[property] = buildTemplateExports(alias, program);
    }
  }
  return templateExport;
}

// src/translator/util/scope-read.ts
function createScopeReadPattern(section, referencedBindings) {
  const rootDepth = section.depth;
  const rootPattern = import_compiler23.types.objectPattern([]);
  let nestedPatterns;
  forEach(referencedBindings, (ref) => {
    const propertyValue = ref.name;
    if (!isValidPropertyIdentifier(propertyValue)) return;
    const propertyKey = getScopeAccessor(ref);
    const isShorthand = propertyKey === propertyValue;
    let pattern = rootPattern;
    if (ref.section !== section && ref.type !== 4 /* local */) {
      if (!nestedPatterns) nestedPatterns = [rootPattern];
      const relativeDepth = rootDepth - ref.section.depth;
      let i = nestedPatterns.length;
      let prev = nestedPatterns[i - 1];
      for (; i <= relativeDepth; i++) {
        const nestedPattern = import_compiler23.types.objectPattern([]);
        prev.properties.push(
          import_compiler23.types.objectProperty(
            import_compiler23.types.identifier(getAccessorProp().Owner),
            nestedPattern
          )
        );
        nestedPatterns.push(nestedPattern);
        prev = nestedPattern;
      }
      pattern = nestedPatterns[relativeDepth];
    }
    pattern.properties.push(
      import_compiler23.types.objectProperty(
        toPropertyName(propertyKey),
        import_compiler23.types.identifier(propertyValue),
        false,
        isShorthand
      )
    );
  });
  return rootPattern;
}
function getScopeExpression(section, targetSection) {
  let scope = scopeIdentifier ?? import_compiler23.types.identifier("undefined");
  const diff = section.depth - targetSection.depth;
  for (let i = 0; i < diff; i++) {
    scope = import_compiler23.types.memberExpression(scope, import_compiler23.types.identifier(getAccessorProp().Owner));
  }
  if (diff < 0) {
    throw new Error("Unable to find scope for reference.");
  }
  return scope;
}
function createScopeReadExpression(section, reference) {
  const propName = toPropertyName(getScopeAccessor(reference));
  return import_compiler23.types.memberExpression(
    getScopeExpression(section, reference.section),
    propName,
    propName.type !== "Identifier"
  );
}

// src/translator/util/with-previous-location.ts
function withPreviousLocation(newNode, originalNode) {
  newNode.start = originalNode.start;
  newNode.loc = originalNode.loc;
  newNode.end = originalNode.end;
  return newNode;
}

// src/translator/util/references.ts
var kIsInvoked = Symbol("hoist is invoked");
var kBranchSerializeReason = Symbol("branch serialize reason");
var [getBindings] = createProgramState(() => /* @__PURE__ */ new Set());
var [getNextBindingId, setNextBindingId] = createProgramState(() => 0);
function createBinding(name2, type, section, upstreamAlias, property, excludeProperties, loc = null, declared = false) {
  const id = getNextBindingId();
  const binding = {
    id,
    name: name2,
    type,
    loc,
    section,
    property,
    declared,
    closureSections: void 0,
    assignmentSections: void 0,
    excludeProperties,
    sources: void 0,
    aliases: /* @__PURE__ */ new Set(),
    hoists: /* @__PURE__ */ new Map(),
    propertyAliases: /* @__PURE__ */ new Map(),
    upstreamAlias,
    downstreamExpressions: /* @__PURE__ */ new Set(),
    scopeOffset: void 0,
    export: void 0,
    nullable: excludeProperties === void 0
  };
  if (property) {
    if (declared) upstreamAlias.nullable = false;
    const propBinding = upstreamAlias.propertyAliases.get(property);
    if (propBinding) {
      binding.property = void 0;
      binding.upstreamAlias = propBinding;
      propBinding.aliases.add(binding);
    } else {
      upstreamAlias.propertyAliases.set(property, binding);
    }
  } else if (upstreamAlias) {
    upstreamAlias.aliases.add(binding);
  }
  setNextBindingId(id + 1);
  getBindings().add(binding);
  return binding;
}
function trackVarReferences(tag, type, upstreamAlias) {
  const tagVar = tag.node.var;
  if (tagVar) {
    let canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);
    if (canonicalUpstreamAlias) {
      const { excludeProperties } = canonicalUpstreamAlias;
      if (excludeProperties !== void 0) {
        canonicalUpstreamAlias = canonicalUpstreamAlias.upstreamAlias;
      }
      createBindingsAndTrackReferences(
        tagVar,
        canonicalUpstreamAlias.type,
        tag.scope,
        canonicalUpstreamAlias.section,
        canonicalUpstreamAlias,
        void 0,
        excludeProperties
      );
      return canonicalUpstreamAlias;
    }
    createBindingsAndTrackReferences(
      tagVar,
      type,
      tag.scope,
      getOrCreateSection(tag),
      void 0,
      void 0,
      void 0
    );
    return tagVar.extra?.binding;
  }
}
function trackParamsReferences(body, type, upstreamAlias) {
  const params = body.node.params;
  if (body.node.body.length && params.length) {
    const canonicalUpstreamAlias = getCanonicalBinding(upstreamAlias);
    let section;
    if (canonicalUpstreamAlias) {
      section = canonicalUpstreamAlias.section;
      type = canonicalUpstreamAlias.type;
    } else {
      section = getOrCreateSection(body);
    }
    const paramsBinding = canonicalUpstreamAlias || ((body.node.extra ??= {}).binding = createBinding(
      generateUid("params"),
      type,
      section,
      void 0,
      void 0
    ));
    section.params = paramsBinding;
    for (let i = 0; i < params.length; i++) {
      const param = params[i];
      if (param.type === "RestElement") {
        createBindingsAndTrackReferences(
          param.argument,
          type,
          body.scope,
          section,
          paramsBinding,
          void 0,
          addNumericPropertiesUntil(void 0, i - 1)
        );
      } else if (import_compiler24.types.isLVal(param)) {
        createBindingsAndTrackReferences(
          param,
          type,
          body.scope,
          section,
          paramsBinding,
          i + "",
          void 0
        );
      }
    }
    return paramsBinding;
  }
}
function trackHoistedReference(referencePath, binding) {
  const section = binding.section;
  const referenceSection = getOrCreateSection(referencePath);
  const hoistSection = getCommonSection(referenceSection, section);
  const extra = referencePath.node.extra ??= {};
  let hoistedBinding = binding.hoists.get(hoistSection);
  if (!hoistedBinding) {
    binding.hoists.set(
      hoistSection,
      hoistedBinding = createBinding(
        generateUid("hoisted_" + referencePath.node.name),
        6 /* hoist */,
        hoistSection,
        void 0,
        void 0,
        void 0,
        binding.loc,
        true
      )
    );
    section.hoisted = bindingUtil.add(section.hoisted, binding);
    let currentSection = section.parent;
    while (currentSection && currentSection !== hoistSection) {
      currentSection.isHoistThrough = true;
      currentSection = currentSection.parent;
    }
  }
  if (isInvokedFunction(referencePath)) {
    extra.read = createRead(hoistedBinding, void 0);
    extra.section = referenceSection;
    extra[kIsInvoked] = true;
  } else {
    trackReference(referencePath, hoistedBinding);
  }
  referenceSection.referencedHoists = bindingUtil.add(
    referenceSection.referencedHoists,
    hoistedBinding
  );
}
function trackReferencesForBinding(babelBinding, binding) {
  const { referencePaths, constantViolations } = babelBinding;
  for (const referencePath of referencePaths) {
    const referenceSection = getOrCreateSection(referencePath);
    if (isSameOrChildSection(binding.section, referenceSection)) {
      if (binding.type === 4 /* local */ && referenceSection === binding.section) {
        continue;
      }
      trackReference(referencePath, binding);
    } else {
      trackHoistedReference(referencePath, binding);
    }
  }
  for (const ref of constantViolations) {
    if (ref.isUpdateExpression()) {
      trackAssignment(ref.get("argument"), binding);
    } else if (ref.isAssignmentExpression()) {
      trackAssignment(ref.get("left"), binding);
      if (ref.node.operator !== "=") {
        const left = ref.get("left");
        if (left.isIdentifier()) {
          trackReference(left, binding);
        }
      }
    }
  }
}
function trackAssignment(assignment, binding) {
  const fnRoot = getFnRoot(assignment);
  const fnExtra = fnRoot && (fnRoot.node.extra ??= {});
  const section = getOrCreateSection(assignment);
  setReferencesScope(assignment);
  forEachIdentifierPath(assignment, (id) => {
    if (id.node.name === binding.name) {
      const extra = id.node.extra ??= {};
      if (binding.upstreamAlias && binding.property !== void 0) {
        const changePropName = binding.property + "Change";
        const changeBinding = binding.upstreamAlias.propertyAliases.get(changePropName) || createBinding(
          generateUid(changePropName),
          5 /* derived */,
          binding.section,
          binding.upstreamAlias,
          changePropName,
          void 0,
          id.node.loc,
          true
        );
        extra.assignmentTo = changeBinding;
        addReadToExpression(id, changeBinding);
      }
      binding.assignmentSections = sectionUtil.add(
        binding.assignmentSections,
        section
      );
      extra.assignment = binding;
      extra.section = section;
      extra.fnExtra = fnExtra;
    }
  });
}
function setReferencesScope(path5) {
  const fnRoot = getFnRoot(path5);
  if (fnRoot) {
    (fnRoot.node.extra ??= {}).referencesScope = true;
  }
}
function createBindingsAndTrackReferences(lVal, type, scope, section, upstreamAlias, property, excludeProperties) {
  switch (lVal.type) {
    case "Identifier":
      trackReferencesForBinding(
        scope.getBinding(lVal.name),
        (lVal.extra ??= {}).binding = createBinding(
          lVal.name,
          type,
          section,
          upstreamAlias,
          property,
          excludeProperties,
          lVal.loc,
          true
        )
      );
      break;
    case "ObjectPattern": {
      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(
        generateUid(property || "pattern"),
        type,
        section,
        upstreamAlias,
        property,
        excludeProperties,
        lVal.loc
      ));
      const hasRest = lVal.properties[lVal.properties.length - 1]?.type === "RestElement";
      for (const prop of lVal.properties) {
        if (prop.type === "RestElement") {
          createBindingsAndTrackReferences(
            prop.argument,
            type,
            scope,
            section,
            patternBinding,
            property,
            excludeProperties
          );
        } else {
          let key;
          if (prop.key.type === "Identifier") {
            key = prop.key.name;
          } else if (prop.key.type === "StringLiteral") {
            key = prop.key.value;
          } else {
            throw new Error("computed keys not supported in object pattern");
          }
          if (hasRest) {
            excludeProperties = propsUtil.add(excludeProperties, key);
          }
          if (import_compiler24.types.isLVal(prop.value)) {
            createBindingsAndTrackReferences(
              prop.value,
              type,
              scope,
              section,
              patternBinding,
              key,
              void 0
            );
          }
        }
      }
      break;
    }
    case "ArrayPattern": {
      const patternBinding = (property ? upstreamAlias.propertyAliases.get(property) : upstreamAlias) || ((lVal.extra ??= {}).binding = createBinding(
        generateUid(property || "pattern"),
        type,
        section,
        upstreamAlias,
        property,
        excludeProperties,
        lVal.loc
      ));
      let i = -1;
      for (const element of lVal.elements) {
        i++;
        if (element) {
          if (element.type === "RestElement") {
            excludeProperties = addNumericPropertiesUntil(
              excludeProperties,
              i - 1
            );
            createBindingsAndTrackReferences(
              element.argument,
              type,
              scope,
              section,
              patternBinding,
              property,
              excludeProperties
            );
          } else if (import_compiler24.types.isLVal(element)) {
            createBindingsAndTrackReferences(
              element,
              type,
              scope,
              section,
              patternBinding,
              `${i}`,
              void 0
            );
          }
        }
      }
      break;
    }
    case "AssignmentPattern":
      createBindingsAndTrackReferences(
        lVal.left,
        type,
        scope,
        section,
        upstreamAlias,
        property,
        void 0
      );
      break;
  }
}
function trackReference(referencePath, binding) {
  let root = referencePath;
  let reference = binding;
  let propPath = binding.name;
  while (true) {
    const { parent } = root;
    if (!import_compiler24.types.isMemberExpression(parent)) break;
    const prop = getMemberExpressionPropString(parent);
    if (prop === void 0) break;
    if (reference.upstreamAlias && reference.excludeProperties !== void 0 && !propsUtil.has(reference.excludeProperties, prop)) {
      reference = reference.upstreamAlias;
    }
    if (reference.propertyAliases.has(prop)) {
      root = root.parentPath;
      reference = reference.propertyAliases.get(prop);
      propPath = reference.name;
      continue;
    }
    if (isInvokedFunction(root.parentPath) && !isEventOrChangeHandler(prop)) {
      break;
    }
    root = root.parentPath;
    reference = createBinding(
      propPath += `_${prop.replace(/[^a-zA-Z0-9_$]/g, "_")}`,
      reference.type,
      reference.section,
      reference,
      prop
    );
  }
  addReadToExpression(root, reference);
}
var [getMergedReferences] = createProgramState(
  () => /* @__PURE__ */ new Map()
);
function mergeReferences(section, target, nodes) {
  const targetExtra = target.extra ??= {};
  targetExtra.section = section;
  getMergedReferences().set(target, nodes);
  return targetExtra;
}
function compareReferences(a, b) {
  return a === b ? 0 : a ? b ? Array.isArray(a) ? Array.isArray(b) ? compareIntersections(a, b) : -1 : Array.isArray(b) ? 1 : bindingUtil.compare(a, b) : 1 : b ? -1 : 0;
}
function compareIntersections(a, b) {
  const len = a.length;
  const lenDelta = len - b.length;
  if (lenDelta !== 0) {
    return lenDelta;
  }
  for (let i = 0; i < len; i++) {
    const compareResult = bindingUtil.compare(a[i], b[i]);
    if (compareResult !== 0) {
      return compareResult;
    }
  }
  return 0;
}
function finalizeReferences() {
  const bindings = getBindings();
  const readsByExpression = getReadsByExpression();
  const readsByFn = getReadsByFunction();
  const mergedReferences = getMergedReferences();
  if (mergedReferences.size) {
    for (const [target, nodes] of mergedReferences) {
      const targetExtra = target.extra;
      let reads = readsByExpression.get(targetExtra);
      let { isEffect } = targetExtra;
      for (const node of nodes) {
        const extra = node?.extra;
        if (isReferencedExtra(extra)) {
          isEffect ||= extra.isEffect;
          const additionalReads = readsByExpression.get(extra);
          if (additionalReads) {
            reads = concat(reads, additionalReads);
            readsByExpression.delete(extra);
          }
        }
      }
      readsByExpression.set(targetExtra, reads);
      targetExtra.isEffect = isEffect;
    }
  }
  const intersectionsBySection = /* @__PURE__ */ new Map();
  for (const [expr, reads] of readsByExpression) {
    if (isReferencedExtra(expr)) {
      expr.referencedBindings = resolveReferencedBindings(
        expr,
        reads,
        intersectionsBySection
      );
      forEach(expr.referencedBindings, (binding) => {
        binding.downstreamExpressions.add(expr);
      });
    }
  }
  for (const [fn, reads] of readsByFn) {
    fn.referencedBindingsInFunction = resolveReferencedBindings(
      fn,
      reads,
      intersectionsBySection
    );
    forEach(
      fn.referencedBindingsInFunction,
      (binding) => forceBindingSerialize(binding.section, binding)
    );
  }
  for (const binding of bindings) {
    if (binding.type !== 0 /* dom */ && !binding.upstreamAlias) {
      pruneBinding(bindings, binding);
    }
  }
  for (const binding of bindings) {
    const { name: name2, section } = binding;
    if (binding.type !== 0 /* dom */) {
      resolveBindingSources(binding);
      if (binding.hoists.size) {
        forceBindingSerialize(binding.section, binding);
      }
      forEach(
        binding.assignmentSections,
        (assignedSection) => forceOwnersSerialize(assignedSection, section, getAccessorProp().Owner)
      );
      if (find(section.bindings, ({ name: name3 }) => name3 === binding.name)) {
        binding.name = generateUid(name2);
      }
    }
    section.bindings = bindingUtil.add(section.bindings, binding);
    for (const {
      referencedBindings,
      isEffect,
      section: section2
    } of binding.downstreamExpressions) {
      if (section2 !== binding.section) {
        const canonicalUpstreamAlias = getCanonicalBinding(binding);
        canonicalUpstreamAlias.closureSections = sectionUtil.add(
          canonicalUpstreamAlias.closureSections,
          section2
        );
        if (binding.type === 4 /* local */) {
          section2.referencedLocalClosures = bindingUtil.add(
            section2.referencedLocalClosures,
            binding
          );
        } else {
          section2.referencedClosures = bindingUtil.add(
            section2.referencedClosures,
            binding
          );
          addOwnersSerializeReason(
            section2,
            canonicalUpstreamAlias.section,
            !!isEffect || canonicalUpstreamAlias.sources,
            getAccessorProp().Owner
          );
        }
      }
      if (isEffect) {
        forEach(
          referencedBindings,
          (binding2) => forceBindingSerialize(binding2.section, binding2)
        );
      }
    }
  }
  forEachSection((section) => {
    if (section.isHoistThrough) {
      forceSectionSerialize(section);
    }
    forEach(section.referencedHoists, (hoistedBinding) => {
      forceOwnersSerialize(
        section,
        hoistedBinding.section,
        getAccessorProp().Owner
      );
    });
    if (section.parent && section.isBranch && section.sectionAccessor && section.upstreamExpression) {
      addSectionSerializeReasonRef(
        section,
        !!(section.isHoistThrough || section.hoisted) || getDirectClosures(section),
        kBranchSerializeReason
      );
      addSectionSerializeReasonExpr(
        section,
        section.upstreamExpression,
        kBranchSerializeReason
      );
      addBindingSerializeReasonExpr(
        section.parent,
        section.sectionAccessor.binding,
        section.upstreamExpression
      );
    }
  });
  forEachSection(applySerializeReasonExprs);
  forEachSection((section) => {
    const intersections = intersectionsBySection.get(section);
    if (intersections) {
      for (const intersection of intersections) {
        const numReferences = intersection.length;
        for (let i = 0; i < numReferences - 1; i++) {
          for (let j = i + 1; j < numReferences; j++) {
            const binding1 = intersection[i];
            const binding2 = intersection[j];
            if (!isBindingForceSerialized(section, binding1) && !isSupersetSources(binding1, binding2)) {
              if (!isSameOrChildSection(section, binding1.section)) {
                addOwnersSerializeReason(
                  section,
                  binding1.section,
                  mergeSerializeReasons(
                    // TODO should check for an actual intersection, not just stateful
                    binding1.sources,
                    binding2.sources
                  ),
                  getAccessorProp().Owner
                );
              }
              addBindingSerializeReason(
                binding1.section,
                binding1,
                binding2.sources
                // TODO should check for an actual intersection, not just binding2.sources stateful
              );
            }
            if (!isBindingForceSerialized(section, binding2) && !isSupersetSources(binding2, binding1)) {
              if (!isSameOrChildSection(section, binding2.section)) {
                addOwnersSerializeReason(
                  section,
                  binding2.section,
                  mergeSerializeReasons(
                    // TODO should check for an actual intersection, not just stateful
                    binding1.sources,
                    binding2.sources
                  ),
                  getAccessorProp().Owner
                );
              }
              addBindingSerializeReason(
                binding2.section,
                binding2,
                binding1.sources
                // TODO should check for an actual intersection, not just binding1.sources stateful
              );
            }
          }
        }
      }
    }
    forEach(section.referencedLocalClosures, (closure) => {
      if (!isBindingForceSerialized(section, closure)) {
        const sourceSection = closure.section;
        let serializeReason;
        let currentSection = section;
        while (currentSection !== sourceSection) {
          const upstreamReason = !currentSection.upstreamExpression || getSerializeSourcesForExpr(currentSection.upstreamExpression);
          if (upstreamReason === true) {
            serializeReason = true;
            break;
          }
          serializeReason = mergeSerializeReasons(
            serializeReason,
            upstreamReason
          );
          currentSection = currentSection.parent;
        }
        addBindingSerializeReason(section, closure, serializeReason);
      }
      if (closure.sources) {
        addSectionSerializeReason(
          section,
          getBindingSerializeReason(section, closure)
        );
      }
    });
    forEach(section.referencedClosures, (closure) => {
      if (!isBindingForceSerialized(closure.section, closure)) {
        const sourceSection = closure.section;
        let serializeReason;
        let currentSection = section;
        while (currentSection !== sourceSection) {
          const upstreamReason = !currentSection.upstreamExpression || getSerializeSourcesForExpr(currentSection.upstreamExpression);
          if (upstreamReason === true) {
            serializeReason = true;
            break;
          }
          serializeReason = mergeSerializeReasons(
            serializeReason,
            upstreamReason
          );
          currentSection = currentSection.parent;
        }
        addBindingSerializeReason(closure.section, closure, serializeReason);
      }
      if (closure.sources) {
        addSectionSerializeReason(
          closure.section,
          getBindingSerializeReason(closure.section, closure)
        );
      }
      if (closure.sources && isDynamicClosure(section, closure)) {
        addBindingSerializeReason(
          closure.section,
          closure,
          closure.sources,
          getAccessorPrefix().ClosureScopes
        );
        addBindingSerializeReason(
          section,
          closure,
          closure.sources,
          getAccessorPrefix().ClosureSignalIndex
        );
      }
    });
  });
  let inputSerializeReasons;
  forEachSection((section) => {
    finalizeSectionSerializeReasons(section);
    if (section.serializeReason && section.serializeReason !== true && section.serializeReason.input) {
      inputSerializeReasons = inputSerializeReasons ? addSorted(
        compareReferences,
        inputSerializeReasons,
        section.serializeReason.input
      ) : [section.serializeReason.input];
    }
    for (const [, reason] of section.serializeReasons) {
      if (reason !== true && reason.input) {
        inputSerializeReasons = inputSerializeReasons ? addSorted(compareReferences, inputSerializeReasons, reason.input) : [reason.input];
      }
    }
  });
  const programExtra = (0, import_babel_utils17.getProgram)().node.extra;
  if (programExtra.returnValueExpr) {
    const returnSources = getSerializeSourcesForExpr(
      programExtra.returnValueExpr
    );
    if (returnSources) {
      programExtra.returnSerializeReason = returnSources.state ? true : returnSources.input;
    }
  }
  programExtra.inputSerializeReasons = inputSerializeReasons;
  forEachSection((section) => {
    let intersectionIndex = 0;
    const intersections = intersectionsBySection.get(section) || [];
    const { id, bindings: bindings2 } = section;
    const isOwnedBinding = ({ section: section2 }) => section2.id === id;
    let lastBindingIndex = 0;
    let intersection;
    forEach(filter(bindings2, isOwnedBinding), (binding, bindingIndex) => {
      binding.id = (lastBindingIndex = bindingIndex) + intersectionIndex;
      while (intersectionIndex < intersections.length && (intersection = intersections[intersectionIndex]).filter(isOwnedBinding).at(-1) === binding) {
        intersectionMeta.set(intersection, {
          id: bindingIndex + ++intersectionIndex,
          scopeOffset: getMaxOwnSourceOffset(intersection, section)
        });
      }
    });
    while (intersectionIndex < intersections.length) {
      intersection = intersections[intersectionIndex];
      intersectionMeta.set(intersection, {
        id: lastBindingIndex + ++intersectionIndex,
        scopeOffset: getMaxOwnSourceOffset(intersection, section)
      });
    }
  });
  mergedReferences.clear();
  readsByExpression.clear();
  readsByFn.clear();
}
function getMaxOwnSourceOffset(intersection, section) {
  let scopeOffset;
  for (const binding of intersection) {
    if (binding.section === section && binding.sources) {
      const trackScopeOffset = (source) => {
        if (source.scopeOffset && (!scopeOffset || scopeOffset.id < source.scopeOffset.id)) {
          scopeOffset = source.scopeOffset;
        }
      };
      forEach(binding.sources.state, trackScopeOffset);
      forEach(binding.sources.input, trackScopeOffset);
    }
  }
  return scopeOffset;
}
var intersectionMeta = /* @__PURE__ */ new WeakMap();
function setBindingValueExpr(binding, valueExpr) {
  bindingValueExprs.set(binding, valueExpr || false);
}
var resolvedSources = /* @__PURE__ */ new WeakSet();
var bindingValueExprs = /* @__PURE__ */ new WeakMap();
function resolveBindingSources(binding) {
  if (resolvedSources.has(binding)) return;
  resolvedSources.add(binding);
  switch (binding.type) {
    case 1 /* let */:
      binding.sources = createSources(binding, void 0);
      return;
    case 2 /* input */:
      binding.sources = createSources(void 0, binding);
      return;
  }
  if (binding.upstreamAlias) {
    let alias;
    let source = binding;
    while (alias = source.upstreamAlias) {
      source = alias;
    }
    if (!resolvedSources.has(source)) {
      resolvedSources.add(source);
      resolveDerivedSources(source);
    }
    binding.sources = source.sources;
  } else {
    resolveDerivedSources(binding);
  }
}
function resolveDerivedSources(binding) {
  const exprs = bindingValueExprs.get(binding);
  bindingValueExprs.delete(binding);
  if (exprs === void 0 || exprs === true) {
    binding.sources = createSources(binding, void 0);
  } else if (exprs) {
    const seen = /* @__PURE__ */ new Set();
    forEach(exprs, (expr) => {
      if (isReferencedExtra(expr)) {
        forEach(expr.referencedBindings, (ref) => {
          if (!seen.has(ref)) {
            seen.add(ref);
            resolveBindingSources(ref);
            binding.sources = mergeSources(binding.sources, ref.sources);
          }
        });
      }
    });
  }
}
function createSources(state, input) {
  if (!(state || input)) {
    throw new Error(
      "Cannot create a serialize reason that does not reference state or input."
    );
  }
  return { state, input };
}
function compareSources(a, b) {
  let delta = 0;
  if (a.input) {
    if (!b.input) return 1;
    if (delta = compareReferences(a.input, b.input)) return delta;
  } else if (b.input) {
    return -1;
  }
  if (a.state) {
    if (!b.state) return 1;
    if (delta = compareReferences(a.state, b.state)) return delta;
  } else if (b.state) {
    return -1;
  }
  return 0;
}
function mergeSources(a, b) {
  if (!a) return b;
  if (!b) return a;
  if (a.state === b.state && a.input === b.input) return a;
  return createSources(
    bindingUtil.union(a.state, b.state),
    bindingUtil.union(a.input, b.input)
  );
}
var bindingUtil = new Sorted(function compareBindings(a, b) {
  return a === b ? 0 : a.section.id - b.section.id || a.type !== b.type && (a.type === 0 /* dom */ || b.type === 0 /* dom */) ? a.type - b.type || a.id - b.id : a.id - b.id;
});
var propsUtil = new Sorted(function compareProps(a, b) {
  return a < b ? -1 : a > b ? 1 : 0;
});
var [getReadsByExpression] = createProgramState(
  () => /* @__PURE__ */ new Map()
);
var [getReadsByFunction] = createProgramState(
  () => /* @__PURE__ */ new Map()
);
function addReadToExpression(root, binding) {
  const { node } = root;
  const fnRoot = getFnRoot(root);
  const exprRoot = getExprRoot(fnRoot || root);
  const exprExtra = exprRoot.node.extra ??= {};
  const readsByExpression = getReadsByExpression();
  const section = exprExtra.section = getOrCreateSection(exprRoot);
  const read = { binding, node };
  readsByExpression.set(
    exprExtra,
    push(readsByExpression.get(exprExtra), read)
  );
  if (fnRoot) {
    const readsByFn = getReadsByFunction();
    const fnExtra = fnRoot.node.extra ??= {};
    exprExtra.fnExtra = fnExtra;
    fnExtra.section = section;
    readsByFn.set(fnExtra, push(readsByFn.get(fnExtra), read));
  }
}
function dropReferences(node) {
  if (Array.isArray(node)) {
    for (const item of node) {
      (item.extra ??= {}).pruned = true;
    }
  } else {
    (node.extra ??= {}).pruned = true;
  }
}
function getCanonicalBinding(binding) {
  const alias = binding?.upstreamAlias;
  if (alias && binding.property === void 0 && binding.excludeProperties === void 0) {
    return alias;
  }
  return binding;
}
function getAllTagReferenceNodes(tag, referenceNodes = []) {
  if (tag.arguments) {
    for (const arg of tag.arguments) {
      referenceNodes.push(arg);
    }
  }
  for (const attr2 of tag.attributes) {
    referenceNodes.push(attr2.value);
  }
  for (const child of tag.body.attributeTags ? tag.body.body : tag.attributeTags) {
    switch (child.type) {
      case "MarkoTag":
        getAllTagReferenceNodes(child, referenceNodes);
        break;
      case "MarkoScriptlet":
        for (const statement of child.body) {
          referenceNodes.push(statement);
        }
        break;
    }
  }
  return referenceNodes;
}
function getScopeAccessorLiteral(binding, includeId) {
  const canonicalBinding = getCanonicalBinding(binding);
  if (isOptimize()) {
    return import_compiler24.types.numericLiteral(canonicalBinding.id);
  }
  return import_compiler24.types.stringLiteral(
    canonicalBinding.name + (includeId || canonicalBinding.type === 0 /* dom */ ? `/${canonicalBinding.id}` : "")
  );
}
function getScopeAccessor(binding, includeId) {
  const canonicalBinding = getCanonicalBinding(binding);
  if (isOptimize()) {
    return canonicalBinding.id + "";
  }
  return canonicalBinding.name + (includeId || canonicalBinding.type === 0 /* dom */ ? `/${canonicalBinding.id}` : "");
}
function getDebugScopeAccess(binding) {
  let root = binding;
  let access = "";
  while (!(root.loc || root.declared) && root.upstreamAlias && root.excludeProperties === void 0) {
    if (root.property !== void 0) {
      access = toAccess(root.property) + access;
    }
    root = root.upstreamAlias;
  }
  return {
    root,
    access
  };
}
function getDebugName(binding) {
  const { root, access } = getDebugScopeAccess(binding);
  return root.name + access;
}
function getInputDebugName(binding) {
  let root = binding;
  let access = "";
  while (root.upstreamAlias !== root.section.params) {
    if (root.property !== void 0) {
      access = toAccess(root.property) + access;
    }
    root = root.upstreamAlias;
  }
  return root.name + access;
}
function getSectionInstancesAccessor(section) {
  return section.sectionAccessor ? section.sectionAccessor.prefix + getScopeAccessor(section.sectionAccessor.binding) : getAccessorPrefix().ClosureScopes + section.id;
}
function getSectionInstancesAccessorLiteral(section) {
  const accessor = getSectionInstancesAccessor(section);
  return accessor ? typeof accessor === "number" ? import_compiler24.types.numericLiteral(accessor) : import_compiler24.types.stringLiteral(accessor) : void 0;
}
function getReadReplacement(node) {
  const { extra } = node;
  if (!extra) return;
  let { binding, read } = extra;
  let replacement;
  if (read) {
    if (read.props === void 0) {
      binding = read.binding;
      read = void 0;
    } else {
      binding = void 0;
    }
  }
  if (binding) {
    if (node.type === "Identifier") {
      if (binding.type === 6 /* hoist */) {
        replacement = node.extra?.[kIsInvoked] ? import_compiler24.types.callExpression(getHoistFunctionIdentifier(binding), [
          getScopeExpression(node.extra.section, binding.section)
        ]) : import_compiler24.types.identifier(getScopeAccessor(binding));
      } else if (binding.name !== node.name) {
        node.name = binding.name;
      }
    } else {
      replacement = import_compiler24.types.identifier(binding.name);
    }
  } else if (read) {
    replacement = toMemberExpression(
      import_compiler24.types.identifier(read.binding.name),
      Array.isArray(read.props) ? read.props[0] : read.props
    );
    if (Array.isArray(read.props)) {
      for (let i = 1; i < read.props.length; i++) {
        replacement = toMemberExpression(replacement, read.props[i]);
      }
    }
  }
  return replacement && withPreviousLocation(replacement, node);
}
function pruneBinding(bindings, binding) {
  let shouldPrune = !binding.downstreamExpressions.size;
  if (binding.hoists.size) {
    shouldPrune = false;
  }
  for (const alias of binding.aliases) {
    if (pruneBinding(bindings, alias)) {
      binding.aliases.delete(alias);
    } else {
      shouldPrune = false;
    }
  }
  for (const [key, alias] of binding.propertyAliases) {
    if (pruneBinding(bindings, alias)) {
      binding.propertyAliases.delete(key);
    } else {
      shouldPrune = false;
    }
  }
  if (shouldPrune) {
    bindings.delete(binding);
  }
  return shouldPrune;
}
function resolveReferencedBindings(expr, reads, intersectionsBySection) {
  let referencedBindings;
  if (Array.isArray(reads)) {
    for (const read of reads) {
      let { binding } = read;
      if (read.node) {
        const exprReference = (read.node.extra ??= {}).read ??= resolveExpressionReference(reads, binding, void 0);
        ({ binding } = (read.node.extra ??= {}).read = exprReference);
      }
      referencedBindings = bindingUtil.add(referencedBindings, binding);
    }
  } else if (reads) {
    if (reads.node) {
      (reads.node.extra ??= {}).read = createRead(reads.binding, void 0);
    }
    referencedBindings = reads.binding;
  }
  if (Array.isArray(referencedBindings)) {
    const intersections = intersectionsBySection.get(expr.section) || [];
    const intersection = findSorted(
      compareIntersections,
      intersections,
      referencedBindings
    );
    if (intersection) {
      referencedBindings = intersection;
    } else {
      intersectionsBySection.set(
        expr.section,
        addSorted(compareIntersections, intersections, referencedBindings)
      );
    }
  }
  return referencedBindings;
}
function resolveExpressionReference(reads, readBinding, readProps) {
  const { upstreamAlias } = readBinding;
  if (upstreamAlias && Array.isArray(reads)) {
    const prop = getCanonicalProperty(readBinding);
    const aliasProps = prop === void 0 ? readProps : push(readProps, prop);
    for (const { binding } of reads) {
      if (binding !== readBinding) {
        let alias = upstreamAlias;
        while (alias) {
          if (binding === alias) {
            return resolveExpressionReference(reads, alias, aliasProps);
          }
          alias = alias.upstreamAlias;
        }
      }
    }
  }
  return createRead(readBinding, readProps);
}
function isSupersetSources(a, b) {
  if (!b.sources) return true;
  if (!a.sources) return false;
  return bindingUtil.isSuperset(a.sources.state, b.sources.state) && bindingUtil.isSuperset(a.sources.input, b.sources.input);
}
function getCanonicalProperty(binding) {
  if (binding.property !== void 0) {
    return binding.property;
  }
  if (binding.upstreamAlias && binding.excludeProperties === void 0) {
    return binding.upstreamAlias.property;
  }
}
function createRead(binding, props) {
  return { binding, props };
}
function getMemberExpressionPropString(expr) {
  switch (expr.property.type) {
    case "StringLiteral":
      return expr.property.value;
    case "NumericLiteral":
      return "" + expr.property.value;
    case "Identifier":
      if (expr.computed) return;
      return expr.property.name;
  }
}
function isEventOrChangeHandler(prop) {
  return /^on[-A-Z][a-zA-Z0-9_$]|[a-zA-Z_$][a-zA-Z0-9_$]*Change$/.test(prop);
}
function isReferencedExtra(extra) {
  return !!(extra && !extra.pruned && extra.section);
}
function isAssignedBindingExtra(extra) {
  return isReferencedExtra(extra) && extra.assignment !== void 0;
}
function isRegisteredFnExtra(extra) {
  return isReferencedExtra(extra) && extra.registerId !== void 0;
}
function addNumericPropertiesUntil(props, len) {
  let result = props;
  for (let i = len; i--; ) {
    result = propsUtil.add(result, i + "");
  }
  return result;
}

// src/translator/core/await.ts
var kDOMBinding = Symbol("await tag dom binding");
var await_default = {
  analyze(tag) {
    (0, import_babel_utils18.assertNoVar)(tag);
    (0, import_babel_utils18.assertNoArgs)(tag);
    assertNoSpreadAttrs(tag);
    (0, import_babel_utils18.assertNoAttributeTags)(tag);
    const { node } = tag;
    const tagBody = tag.get("body");
    const section = getOrCreateSection(tag);
    const [valueAttr] = node.attributes;
    const tagExtra = tag.node.extra ??= {};
    tagExtra[kDOMBinding] = createBinding("#text", 0 /* dom */, section);
    if (!valueAttr) {
      throw tag.get("name").buildCodeFrameError("The `await` tag requires a value.");
    }
    if (node.attributes.length > 1 || !import_compiler25.types.isMarkoAttribute(valueAttr) || valueAttr.name !== "value") {
      throw tag.get("name").buildCodeFrameError(
        "The `await` tag only supports the `value` attribute."
      );
    }
    if (!node.body.body.length) {
      throw tag.get("name").buildCodeFrameError("The `await` tag requires body content.");
    }
    if (node.body.params.length && (node.body.params.length > 1 || import_compiler25.types.isSpreadElement(node.body.params[0]))) {
      throw tag.get("name").buildCodeFrameError(
        "The `await` tag only supports a single parameter."
      );
    }
    const bodySection = startSection(tagBody);
    const valueExtra = evaluate(valueAttr.value);
    getOrCreateSection(tag);
    const paramsBinding = trackParamsReferences(tagBody, 3 /* param */);
    if (paramsBinding) {
      setBindingValueExpr(paramsBinding, valueExtra);
    }
    bodySection.upstreamExpression = valueAttr.value.extra;
  },
  translate: translateByTarget({
    html: {
      enter(tag) {
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (!bodySection) {
          tag.remove();
          return;
        }
        setSectionParentIsOwner(bodySection, true);
        flushBefore(tag);
      },
      exit(tag) {
        const { node } = tag;
        const [valueAttr] = node.attributes;
        const tagExtra = node.extra;
        const nodeRef2 = tagExtra[kDOMBinding];
        const tagBody = tag.get("body");
        const section = getSection(tag);
        const bodySection = getSectionForBody(tagBody);
        flushInto(tag);
        writeHTMLResumeStatements(tagBody);
        tag.replaceWith(
          import_compiler25.types.expressionStatement(
            callRuntime(
              "fork",
              getScopeIdIdentifier(section),
              getScopeAccessorLiteral(nodeRef2),
              valueAttr.value,
              import_compiler25.types.arrowFunctionExpression(
                node.body.params,
                toFirstExpressionOrBlock(node.body.body)
              ),
              getSerializeGuard(
                bodySection && getSectionSerializeReason(bodySection),
                true
              )
            )
          )
        )[0].skip();
      }
    },
    dom: {
      enter(tag) {
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (!bodySection) {
          tag.remove();
          return;
        }
        setSectionParentIsOwner(bodySection, true);
        visit(tag, 37 /* Replace */);
        enterShallow(tag);
      },
      exit(tag) {
        const { node } = tag;
        const tagExtra = node.extra;
        const nodeRef2 = tagExtra[kDOMBinding];
        const section = getSection(tag);
        const bodySection = getSectionForBody(tag.get("body"));
        const signal = getSignal(section, nodeRef2, "await");
        signal.build = () => {
          return callRuntime(
            "awaitTag",
            getScopeAccessorLiteral(nodeRef2),
            import_compiler25.types.identifier(bodySection.name)
          );
        };
        addValue(
          section,
          bodySection.upstreamExpression?.referencedBindings,
          signal,
          tag.node.attributes[0].value
        );
        tag.remove();
      }
    }
  }),
  attributes: {},
  autocomplete: [
    {
      description: "Use to consume asynchronous an data.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#await"
    }
  ],
  types: runtime_info_default.name + "/tag-types/await.d.marko"
};

// src/translator/core/client.ts
var import_compiler26 = require("@marko/compiler");
var import_babel_utils19 = require("@marko/compiler/babel-utils");
var client_default = {
  parse(tag) {
    const {
      node,
      hub: { file }
    } = tag;
    const rawValue = node.rawValue;
    const code = rawValue.replace(/^client\s*/, "").trim();
    const start = node.name.start + (rawValue.length - code.length);
    let body = (0, import_babel_utils19.parseStatements)(file, code, start, start + code.length);
    if (body.length === 1 && import_compiler26.types.isBlockStatement(body[0])) {
      body = body[0].body;
    }
    tag.replaceWith(import_compiler26.types.markoScriptlet(body, true, "client"));
  },
  parseOptions: {
    statement: true,
    rawOpenTag: true
  },
  autocomplete: [
    {
      displayText: "client <statement>",
      description: "A JavaScript statement which is only evaluated once your template is loaded on the client.",
      descriptionMoreURL: "https://markojs.com/docs/syntax/#client-javascript"
    }
  ]
};

// src/translator/core/const.ts
var import_compiler28 = require("@marko/compiler");
var import_babel_utils20 = require("@marko/compiler/babel-utils");

// src/translator/util/translate-var.ts
var import_compiler27 = require("@marko/compiler");
function translateVar(tag, initialValue, kind = "const") {
  const {
    node: { var: tagVar }
  } = tag;
  if (!tagVar) {
    return;
  }
  forEachIdentifierPath(tag.get("var"), (id) => {
    const binding = id.node.extra?.binding;
    if (!binding || !binding.upstreamAlias || !binding.assignmentSections || id.node === tagVar) {
      return;
    }
    const changeName = binding.name + "Change";
    const changeBinding = binding.upstreamAlias.propertyAliases.get(changeName);
    if (changeBinding && changeName !== changeBinding.name) {
      getDestructurePattern(id)?.pushContainer(
        "properties",
        import_compiler27.types.objectProperty(
          import_compiler27.types.identifier(changeName),
          import_compiler27.types.identifier(changeBinding.name)
        )
      );
    }
  });
  tag.insertBefore(
    import_compiler27.types.variableDeclaration(kind, [import_compiler27.types.variableDeclarator(tagVar, initialValue)])
  );
}
function getDestructurePattern(id) {
  let cur = id;
  while (cur) {
    if (cur.node.type === "ObjectPattern") {
      return cur;
    }
    cur = cur.parentPath;
  }
}

// src/translator/core/const.ts
var const_default = {
  analyze(tag) {
    (0, import_babel_utils20.assertNoArgs)(tag);
    (0, import_babel_utils20.assertNoParams)(tag);
    assertNoBodyContent(tag);
    const { node } = tag;
    const [valueAttr] = node.attributes;
    if (!node.var) {
      throw tag.get("name").buildCodeFrameError("The `const` tag requires a tag variable.");
    }
    if (!valueAttr) {
      throw tag.get("name").buildCodeFrameError("The `const` tag requires a value.");
    }
    if (node.attributes.length > 1 || !import_compiler28.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== "value") {
      throw tag.get("name").buildCodeFrameError(
        "The `const` tag only supports the `value` attribute."
      );
    }
    const valueExtra = evaluate(valueAttr.value);
    const upstreamAlias = import_compiler28.types.isIdentifier(valueAttr.value) ? tag.scope.getBinding(valueAttr.value.name)?.identifier.extra?.binding : void 0;
    if (upstreamAlias) {
      valueExtra.pruned = true;
    }
    const binding = trackVarReferences(tag, 5 /* derived */, upstreamAlias);
    if (binding) {
      if (!valueExtra.nullable) binding.nullable = false;
      setBindingValueExpr(binding, valueExtra);
    }
  },
  translate: {
    exit(tag) {
      const { node } = tag;
      const [valueAttr] = node.attributes;
      const { value } = valueAttr;
      if (isOutputDOM()) {
        const section = getSection(tag);
        const varBinding = node.var.extra?.binding;
        if (varBinding && !varBinding.upstreamAlias) {
          const derivation = initValue(varBinding);
          addValue(section, value.extra?.referencedBindings, derivation, value);
        }
      } else {
        translateVar(tag, value);
      }
      tag.remove();
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create an constant binding.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#const"
    }
  ],
  types: runtime_info_default.name + "/tag-types/const.d.marko"
};

// src/translator/core/debug.ts
var import_compiler29 = require("@marko/compiler");
var import_babel_utils21 = require("@marko/compiler/babel-utils");
var debug_default = {
  analyze(tag) {
    const [valueAttr] = tag.node.attributes;
    (0, import_babel_utils21.assertNoVar)(tag);
    (0, import_babel_utils21.assertNoArgs)(tag);
    (0, import_babel_utils21.assertNoParams)(tag);
    assertNoBodyContent(tag);
    if (tag.node.attributes.length > 1 || tag.node.attributes.length === 1 && (!import_compiler29.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== "value")) {
      throw tag.get("name").buildCodeFrameError(
        "The `debug` tag only supports the `value` attribute."
      );
    }
  },
  translate: {
    exit(tag) {
      const section = getSection(tag);
      const [valueAttr] = tag.node.attributes;
      const referencedBindings = valueAttr?.value.extra?.referencedBindings;
      const statement = withPreviousLocation(import_compiler29.types.debuggerStatement(), tag.node);
      if (isOutputHTML()) {
        tag.insertBefore(statement);
      } else {
        addStatement("render", section, referencedBindings, statement);
      }
      tag.remove();
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Debug on value change.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#debug"
    }
  ],
  types: runtime_info_default.name + "/tag-types/debug.d.marko"
};

// src/translator/core/define.ts
var import_compiler35 = require("@marko/compiler");
var import_babel_utils27 = require("@marko/compiler/babel-utils");

// src/translator/util/nested-attribute-tags.ts
var import_compiler30 = require("@marko/compiler");
var import_babel_utils22 = require("@marko/compiler/babel-utils");
var attrTagToIdentifierLookup = /* @__PURE__ */ new WeakMap();
function getAttrTagIdentifier(meta) {
  let name2 = attrTagToIdentifierLookup.get(meta);
  if (!name2) {
    name2 = generateUid(meta.name);
    attrTagToIdentifierLookup.set(meta, name2);
  }
  return import_compiler30.types.identifier(name2);
}
function analyzeAttributeTags(tag) {
  if (tag.node.extra?.attributeTags) return tag.node.extra.attributeTags;
  const attrTags2 = tag.node.body.attributeTags ? tag.get("body").get("body") : tag.get("attributeTags");
  if (!attrTags2.length) return;
  const tagExtra = tag.node.extra ??= {};
  const lookup = tagExtra.attributeTags = {};
  const attrTagNodesByName = {};
  const sampleAttrTagsForControlFlow = /* @__PURE__ */ new Map();
  for (const child of attrTags2) {
    if (child.isMarkoTag()) {
      if ((0, import_babel_utils22.isAttributeTag)(child)) {
        const name2 = getTagName(child);
        lookup[name2] ||= createAttrTagMeta(name2, [name2]);
        (attrTagNodesByName[name2] ||= []).push(child);
        analyzeAttributeTags(child);
      } else {
        const isRepeated = (0, import_babel_utils22.isLoopTag)(child);
        let curGroup;
        for (const name2 of crawlAttrTags(child, attrTagNodesByName)) {
          const oldMeta = lookup[name2];
          if (oldMeta) {
            if (!curGroup) {
              curGroup = oldMeta.group;
            } else if (curGroup !== oldMeta.group) {
              for (const name3 of oldMeta.group) {
                lookup[name3].group = curGroup;
                curGroup.push(name3);
              }
            }
          }
          let attrTagMeta = lookup[name2];
          if (!attrTagMeta) {
            attrTagMeta = lookup[name2] = createAttrTagMeta(name2, []);
            curGroup = attrTagMeta.group;
            curGroup.push(name2);
          }
          attrTagMeta.dynamic = true;
          if (isRepeated) {
            attrTagMeta.repeated = true;
          }
          sampleAttrTagsForControlFlow.set(child, name2);
        }
      }
    }
  }
  for (const [controlFlowTag, sampleAttrName] of sampleAttrTagsForControlFlow) {
    (controlFlowTag.node.extra ??= {}).attributeTagGroup = lookup[sampleAttrName].group;
  }
  for (const name2 in attrTagNodesByName) {
    const attrTagMeta = lookup[name2];
    if (!attrTagMeta.repeated) {
      const attrTagNodes = attrTagNodesByName[name2];
      if (attrTagNodes.length > 1) {
        attrTagMeta.repeated = !attrTagMeta.dynamic || hasRepeatedDynamicAttrTags(attrTagNodes);
      }
    }
  }
  return lookup;
}
function createAttrTagMeta(name2, group) {
  return {
    name: name2.slice(1),
    dynamic: false,
    repeated: false,
    group
  };
}
function crawlAttrTags(tag, attrTagNodesByName, attrTagNames = /* @__PURE__ */ new Set()) {
  const attrTags2 = tag.node.body.attributeTags ? tag.get("body").get("body") : tag.get("attributeTags");
  for (const child of attrTags2) {
    if (child.isMarkoTag()) {
      if ((0, import_babel_utils22.isAttributeTag)(child)) {
        const tagName = getTagName(child);
        attrTagNames.add(tagName);
        (attrTagNodesByName[tagName] ||= []).push(child);
        analyzeAttributeTags(child);
      } else {
        crawlAttrTags(child, attrTagNodesByName, attrTagNames);
      }
    }
  }
  return attrTagNames;
}
function hasRepeatedDynamicAttrTags(attrTags2) {
  let conditionRoot;
  const seenBranches = /* @__PURE__ */ new Set();
  for (const attrTag2 of attrTags2) {
    const parentTag = getParentTag(attrTag2);
    if (seenBranches.has(parentTag) || !isConditionTag(parentTag)) {
      return true;
    }
    const curConditionRoot = getConditionRoot(parentTag);
    if (curConditionRoot && curConditionRoot !== (conditionRoot ||= curConditionRoot)) {
      return true;
    }
    seenBranches.add(parentTag);
  }
  return false;
}
function getConditionRoot(tag) {
  if (getTagName(tag) === "if") return tag;
  let prev = tag.getPrevSibling();
  while (prev.node) {
    if (prev.isMarkoTag() && getTagName(prev) === "if") {
      return prev;
    }
    prev = prev.getPrevSibling();
  }
}

// src/translator/util/translate-attrs.ts
var import_compiler34 = require("@marko/compiler");
var import_babel_utils26 = require("@marko/compiler/babel-utils");

// src/translator/core/for.ts
var import_compiler33 = require("@marko/compiler");
var import_babel_utils25 = require("@marko/compiler/babel-utils");

// src/translator/util/is-only-child-in-parent.ts
var import_compiler32 = require("@marko/compiler");
var import_babel_utils24 = require("@marko/compiler/babel-utils");

// src/translator/visitors/tag/native-tag.ts
var import_compiler31 = require("@marko/compiler");
var import_babel_utils23 = require("@marko/compiler/babel-utils");
var kNativeTagBinding = Symbol("native tag binding");
var kSkipEndTag = Symbol("skip native tag mark");
var kGetterId = Symbol("node getter id");
var kTagContentAttr = Symbol("tag could have dynamic content attribute");
var htmlSelectArgs = /* @__PURE__ */ new WeakMap();
var native_tag_default = {
  transform: {
    enter(tag) {
      const tagName = getTagName(tag);
      if (tagName === "textarea" && tag.node.body.body.length) {
        const parts = [];
        for (const child of tag.node.body.body) {
          if (child.type === "MarkoText" || child.type === "MarkoPlaceholder" && child.escape) {
            parts.push(child.value);
          } else {
            throw tag.hub.file.hub.buildError(
              child,
              "Unexpected content in textarea, only text and placeholders are supported.",
              SyntaxError
            );
          }
        }
        tag.node.attributes.push(
          import_compiler31.types.markoAttribute(
            "value",
            normalizeStringExpression(parts) || buildUndefined()
          )
        );
        tag.node.body.body = [];
      }
    }
  },
  analyze: {
    enter(tag) {
      (0, import_babel_utils23.assertNoArgs)(tag);
      (0, import_babel_utils23.assertNoParams)(tag);
      (0, import_babel_utils23.assertNoAttributeTags)(tag);
      const { node } = tag;
      if (node.var && !import_compiler31.types.isIdentifier(node.var)) {
        throw tag.get("var").buildCodeFrameError(
          "Tag variables on native elements cannot be destructured."
        );
      }
      const tagName = getTagName(tag);
      const seen = {};
      const { attributes } = tag.node;
      let hasDynamicAttributes = false;
      let hasEventHandlers = false;
      let relatedControllable;
      let spreadReferenceNodes;
      let attrExprExtras;
      for (let i = attributes.length; i--; ) {
        const attr2 = attributes[i];
        const valueExtra = attr2.value.extra ??= {};
        if (import_compiler31.types.isMarkoAttribute(attr2)) {
          if (seen[attr2.name]) {
            dropReferences(attr2.value);
            continue;
          }
          seen[attr2.name] = attr2;
          if (isEventHandler(attr2.name) || isChangeHandler(attr2.name)) {
            valueExtra.isEffect = true;
            hasEventHandlers = true;
          } else if (!evaluate(attr2.value).confident) {
            hasDynamicAttributes = true;
          }
        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {
          valueExtra.isEffect = true;
          hasEventHandlers = true;
          hasDynamicAttributes = true;
        }
        if (spreadReferenceNodes) {
          spreadReferenceNodes.push(attr2.value);
        } else if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {
          spreadReferenceNodes = [attr2.value];
          relatedControllable = getRelatedControllable(tagName, seen);
        } else {
          attrExprExtras = push(attrExprExtras, valueExtra);
        }
      }
      assertExclusiveControllableGroups(tag, seen);
      if (node.var || hasEventHandlers || hasDynamicAttributes) {
        const tagExtra = node.extra ??= {};
        const tagSection = getOrCreateSection(tag);
        const nodeBinding = tagExtra[kNativeTagBinding] = createBinding(
          "#" + (node.name.type === "StringLiteral" ? node.name.value : import_compiler31.types.toIdentifier(tag.get("name"))),
          0 /* dom */,
          tagSection
        );
        (0, import_babel_utils23.getProgram)().node.extra.isInteractive ||= hasEventHandlers;
        if (spreadReferenceNodes) {
          if (relatedControllable && !relatedControllable.attrs.every(Boolean)) {
            for (const attr2 of relatedControllable.attrs) {
              if (attr2) {
                spreadReferenceNodes.push(attr2.value);
              }
            }
            relatedControllable = void 0;
          }
          mergeReferences(tagSection, tag.node, spreadReferenceNodes);
        } else {
          relatedControllable = getRelatedControllable(tagName, seen);
        }
        if (relatedControllable) {
          mergeReferences(
            tagSection,
            relatedControllable.attrs.find(Boolean).value,
            relatedControllable.attrs.map((it) => it?.value)
          );
        }
        if (hasEventHandlers || spreadReferenceNodes) {
          forceBindingSerialize(tagSection, nodeBinding);
        }
        if (node.var) {
          forceBindingSerialize(tagSection, nodeBinding);
          for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {
            const refSection = getOrCreateSection(ref);
            setReferencesScope(ref);
            if (isSameOrChildSection(tagSection, refSection)) {
              forceOwnersSerialize(
                refSection,
                tagSection,
                getAccessorProp().Owner
              );
              if (!tagExtra[kGetterId] && !isInvokedFunction(ref)) {
                tagExtra[kGetterId] = getRegisterUID(
                  tagSection,
                  nodeBinding.name
                );
              }
            } else {
              trackHoistedReference(
                ref,
                nodeBinding
              );
            }
          }
        }
        addBindingSerializeReasonExpr(
          tagSection,
          nodeBinding,
          push(attrExprExtras, tagExtra)
        );
      }
    }
  },
  translate: translateByTarget({
    html: {
      enter(tag) {
        const tagName = getTagName(tag);
        const tagExtra = tag.node.extra;
        const nodeBinding = tagExtra[kNativeTagBinding];
        const tagDef = (0, import_babel_utils23.getTagDef)(tag);
        const write2 = writeTo(tag);
        const tagSection = getSection(tag);
        if (tagExtra.tagNameNullable) {
          flushBefore(tag);
        }
        if (tag.node.var) {
          const getterId = tagExtra[kGetterId];
          translateVar(
            tag,
            callRuntime(
              "nodeRef",
              getterId && getScopeIdIdentifier(tagSection),
              getterId && import_compiler31.types.stringLiteral(getterId)
            )
          );
        }
        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);
        write2`<${tag.node.name}`;
        const usedAttrs = getUsedAttrs(tagName, tag.node);
        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;
        let { spreadExpression } = usedAttrs;
        if (staticControllable) {
          const { helper, attrs: attrs2 } = staticControllable;
          if (tagName !== "select" && tagName !== "textarea") {
            const values = attrs2.map((attr2) => attr2?.value);
            write2`${callRuntime(helper, getScopeIdIdentifier(tagSection), visitAccessor, ...values)}`;
          }
          addHTMLEffectCall(tagSection, void 0);
        }
        let writeAtStartOfBody;
        if (tagName === "select") {
          if (staticControllable) {
            htmlSelectArgs.set(tag.node, {
              value: staticControllable.attrs[0]?.value || buildUndefined(),
              valueChange: staticControllable.attrs[1]?.value || buildUndefined()
            });
          } else if (spreadExpression) {
            const spreadIdentifier = generateUidIdentifier("select_input");
            tag.insertBefore(
              import_compiler31.types.variableDeclaration("const", [
                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)
              ])
            );
            htmlSelectArgs.set(tag.node, {
              value: import_compiler31.types.memberExpression(
                spreadIdentifier,
                import_compiler31.types.identifier("value")
              ),
              valueChange: import_compiler31.types.memberExpression(
                spreadIdentifier,
                import_compiler31.types.identifier("valueChange")
              )
            });
            spreadExpression = spreadIdentifier;
          }
        } else if (tagName === "textarea") {
          let value;
          let valueChange;
          if (staticControllable) {
            value = staticControllable.attrs[0]?.value;
            valueChange = staticControllable.attrs[1]?.value;
          } else if (spreadExpression) {
            const spreadIdentifier = generateUidIdentifier("textarea_input");
            tag.insertBefore(
              import_compiler31.types.variableDeclaration("const", [
                import_compiler31.types.variableDeclarator(spreadIdentifier, spreadExpression)
              ])
            );
            value = import_compiler31.types.memberExpression(spreadIdentifier, import_compiler31.types.identifier("value"));
            valueChange = import_compiler31.types.memberExpression(
              spreadIdentifier,
              import_compiler31.types.identifier("valueChange")
            );
            spreadExpression = spreadIdentifier;
          }
          if (value || valueChange) {
            writeAtStartOfBody = callRuntime(
              "controllable_textarea_value",
              getScopeIdIdentifier(getSection(tag)),
              getScopeAccessorLiteral(nodeBinding),
              value,
              valueChange
            );
          }
        }
        for (const attr2 of staticAttrs) {
          const { name: name2, value } = attr2;
          const { confident, computed } = value.extra || {};
          const valueReferences = value.extra?.referencedBindings;
          if (tagName === "option" && name2 === "value") {
            write2`${callRuntime("optionValueAttr", value)}`;
            continue;
          }
          switch (name2) {
            case "class":
            case "style": {
              const helper = `${name2}Attr`;
              if (confident) {
                write2`${getHTMLRuntime()[helper](computed)}`;
              } else {
                write2`${callRuntime(helper, value)}`;
              }
              break;
            }
            default:
              if (confident) {
                write2`${getHTMLRuntime().attr(name2, computed)}`;
              } else if (isEventHandler(name2)) {
                addHTMLEffectCall(tagSection, valueReferences);
              } else {
                write2`${callRuntime("attr", import_compiler31.types.stringLiteral(name2), value)}`;
              }
              break;
          }
        }
        const isOpenOnly = !!(tagDef && tagDef.parseOptions?.openTagOnly);
        const hasChildren = !!tag.node.body.body.length;
        if (spreadExpression) {
          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);
          if (isOpenOnly || hasChildren || usedAttrs.staticContentAttr) {
            if (skipExpression) {
              write2`${callRuntime("partialAttrs", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;
            } else {
              write2`${callRuntime("attrs", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), tag.node.name)}`;
            }
          }
        }
        if (isOpenOnly) {
          switch (tagDef.htmlType) {
            case "svg":
            case "math":
              write2`/>`;
              break;
            default:
              write2`>`;
              break;
          }
        } else {
          if (usedAttrs.staticContentAttr) {
            write2`>`;
            tagExtra[kTagContentAttr] = true;
            tag.node.body.body = [
              import_compiler31.types.expressionStatement(
                callRuntime(
                  "writeContent",
                  visitAccessor,
                  getScopeIdIdentifier(tagSection),
                  usedAttrs.staticContentAttr.value,
                  getSerializeGuard(
                    nodeBinding && getBindingSerializeReason(tagSection, nodeBinding),
                    true
                  )
                )
              )
            ];
          } else if (spreadExpression && !hasChildren) {
            const serializeReason = getSerializeGuard(
              nodeBinding && getBindingSerializeReason(tagSection, nodeBinding),
              true
            );
            tagExtra[kTagContentAttr] = true;
            tag.node.body.body = [
              skipExpression ? import_compiler31.types.expressionStatement(
                callRuntime(
                  "writePartialAttrsAndContent",
                  spreadExpression,
                  skipExpression,
                  visitAccessor,
                  getScopeIdIdentifier(tagSection),
                  tag.node.name,
                  serializeReason
                )
              ) : import_compiler31.types.expressionStatement(
                callRuntime(
                  "writeAttrsAndContent",
                  spreadExpression,
                  visitAccessor,
                  getScopeIdIdentifier(tagSection),
                  tag.node.name,
                  serializeReason
                )
              )
            ];
          } else {
            write2`>`;
          }
        }
        if (tagExtra.tagNameNullable) {
          tag.insertBefore(
            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))
          )[0].skip();
        }
        if (writeAtStartOfBody) {
          write2`${writeAtStartOfBody}`;
        }
      },
      exit(tag) {
        const tagExtra = tag.node.extra;
        const nodeBinding = tagExtra[kNativeTagBinding];
        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;
        const selectArgs = htmlSelectArgs.get(tag.node);
        const tagName = getTagName(tag);
        const tagSection = getSection(tag);
        if (tagExtra[kTagContentAttr]) {
          flushBefore(tag);
        }
        if (tagExtra.tagNameNullable) {
          flushInto(tag);
        }
        if (selectArgs) {
          if (!tagExtra[kSkipEndTag]) {
            writeTo(tag)`</${tag.node.name}>`;
          }
          flushInto(tag);
          tag.insertBefore(
            import_compiler31.types.expressionStatement(
              callRuntime(
                "controllable_select_value",
                getScopeIdIdentifier(getSection(tag)),
                getScopeAccessorLiteral(nodeBinding),
                selectArgs.value,
                selectArgs.valueChange,
                import_compiler31.types.arrowFunctionExpression(
                  [],
                  import_compiler31.types.blockStatement(tag.node.body.body)
                )
              )
            )
          );
        } else {
          tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());
        }
        const markerSerializeReason = !tagExtra[kSkipEndTag] && nodeBinding && getBindingSerializeReason(tagSection, nodeBinding);
        if (!tagExtra[kSkipEndTag] && !openTagOnly && !selectArgs) {
          writeTo(
            tag,
            !markerSerializeReason && (tagName === "html" || tagName === "body")
          )`</${tag.node.name}>`;
        }
        if (tagExtra.tagNameNullable) {
          tag.insertBefore(
            import_compiler31.types.ifStatement(tag.node.name, consumeHTML(tag))
          )[0].skip();
        }
        if (markerSerializeReason) {
          markNode(tag, nodeBinding, markerSerializeReason);
        }
        tag.remove();
      }
    },
    dom: {
      enter(tag) {
        const tagName = getTagName(tag);
        const tagExtra = tag.node.extra;
        const nodeBinding = tagExtra[kNativeTagBinding];
        const tagDef = (0, import_babel_utils23.getTagDef)(tag);
        const write2 = writeTo(tag);
        const tagSection = getSection(tag);
        if (tag.node.var) {
          const varName = tag.node.var.name;
          const varBinding = tag.scope.getBinding(varName);
          const getterId = tagExtra[kGetterId];
          let getterFnIdentifier;
          if (getterId) {
            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);
            (0, import_babel_utils23.getProgram)().node.body.push(
              import_compiler31.types.variableDeclaration("const", [
                import_compiler31.types.variableDeclarator(
                  getterFnIdentifier,
                  callRuntime(
                    "nodeRef",
                    import_compiler31.types.stringLiteral(getterId),
                    import_compiler31.types.stringLiteral(
                      getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value
                    )
                  )
                )
              ])
            );
          }
          for (const reference of varBinding.referencePaths) {
            const referenceSection = getSection(reference);
            if (isSameOrChildSection(tagSection, referenceSection)) {
              if (isInvokedFunction(reference)) {
                reference.parentPath.replaceWith(
                  import_compiler31.types.expressionStatement(
                    createScopeReadExpression(referenceSection, nodeBinding)
                  )
                );
              } else if (getterFnIdentifier) {
                reference.replaceWith(
                  import_compiler31.types.callExpression(getterFnIdentifier, [
                    getScopeExpression(referenceSection, getSection(tag))
                  ])
                );
              } else {
                reference.replaceWith(
                  import_compiler31.types.expressionStatement(
                    import_compiler31.types.memberExpression(
                      getScopeExpression(tagSection, referenceSection),
                      import_compiler31.types.stringLiteral(
                        getAccessorPrefix().Getter + getScopeAccessorLiteral(nodeBinding).value
                      ),
                      true
                    )
                  )
                );
              }
            }
          }
        }
        const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);
        if (visitAccessor) {
          visit(tag, 32 /* Get */);
        }
        write2`<${tag.node.name}`;
        const usedAttrs = getUsedAttrs(tagName, tag.node);
        const { staticAttrs, staticControllable, skipExpression } = usedAttrs;
        const { spreadExpression } = usedAttrs;
        const isOpenOnly = !!(tagDef && tagDef.parseOptions?.openTagOnly);
        const hasChildren = !!tag.node.body.body.length;
        if (staticControllable) {
          const { helper, attrs: attrs2 } = staticControllable;
          const firstAttr = attrs2.find(Boolean);
          const referencedBindings = firstAttr.value.extra?.referencedBindings;
          const values = attrs2.map((attr2) => attr2?.value);
          addStatement(
            "render",
            tagSection,
            referencedBindings,
            import_compiler31.types.expressionStatement(
              callRuntime(helper, scopeIdentifier, visitAccessor, ...values)
            )
          );
          addStatement(
            "effect",
            tagSection,
            void 0,
            import_compiler31.types.expressionStatement(
              callRuntime(`${helper}_effect`, scopeIdentifier, visitAccessor)
            )
          );
        }
        for (const attr2 of staticAttrs) {
          const { name: name2, value } = attr2;
          const { confident, computed } = value.extra || {};
          const valueReferences = value.extra?.referencedBindings;
          switch (name2) {
            case "class":
            case "style": {
              const helper = `${name2}Attr`;
              if (confident) {
                write2`${getHTMLRuntime()[helper](computed)}`;
              } else {
                const nodeExpr = import_compiler31.types.memberExpression(
                  scopeIdentifier,
                  visitAccessor,
                  true
                );
                const meta = {
                  staticItems: void 0,
                  dynamicItems: void 0,
                  dynamicValues: void 0
                };
                let stmt;
                trackDelimitedAttrValue(value, meta);
                if (meta.dynamicItems) {
                  stmt = import_compiler31.types.expressionStatement(
                    callRuntime(helper, nodeExpr, value)
                  );
                } else {
                  if (meta.staticItems) {
                    write2`${getHTMLRuntime()[helper](meta.staticItems)}`;
                  }
                  if (meta.dynamicValues) {
                    const keys = Object.keys(meta.dynamicValues);
                    if (keys.length === 1) {
                      const [key] = keys;
                      const value2 = meta.dynamicValues[key];
                      stmt = import_compiler31.types.expressionStatement(
                        callRuntime(
                          `${name2}Item`,
                          nodeExpr,
                          import_compiler31.types.stringLiteral(key),
                          value2
                        )
                      );
                    } else {
                      const props = [];
                      for (const key of keys) {
                        const value2 = meta.dynamicValues[key];
                        props.push(
                          import_compiler31.types.objectProperty(toPropertyName(key), value2)
                        );
                      }
                      stmt = import_compiler31.types.expressionStatement(
                        callRuntime(
                          `${name2}Items`,
                          nodeExpr,
                          import_compiler31.types.objectExpression(props)
                        )
                      );
                    }
                  }
                }
                if (stmt) {
                  addStatement("render", tagSection, valueReferences, stmt);
                }
              }
              break;
            }
            default:
              if (confident) {
                write2`${getHTMLRuntime().attr(name2, computed)}`;
              } else if (isEventHandler(name2)) {
                addStatement(
                  "effect",
                  tagSection,
                  valueReferences,
                  import_compiler31.types.expressionStatement(
                    callRuntime(
                      "on",
                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),
                      import_compiler31.types.stringLiteral(getEventHandlerName(name2)),
                      value
                    )
                  )
                );
              } else {
                addStatement(
                  "render",
                  tagSection,
                  valueReferences,
                  import_compiler31.types.expressionStatement(
                    callRuntime(
                      "attr",
                      import_compiler31.types.memberExpression(scopeIdentifier, visitAccessor, true),
                      import_compiler31.types.stringLiteral(name2),
                      value
                    )
                  )
                );
              }
              break;
          }
        }
        if (spreadExpression) {
          const canHaveAttrContent = !(isOpenOnly || hasChildren || usedAttrs.staticContentAttr);
          if (skipExpression) {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler31.types.expressionStatement(
                callRuntime(
                  canHaveAttrContent ? "partialAttrsAndContent" : "partialAttrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression,
                  skipExpression
                )
              )
            );
          } else {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler31.types.expressionStatement(
                callRuntime(
                  canHaveAttrContent ? "attrsAndContent" : "attrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression
                )
              )
            );
          }
          addStatement(
            "effect",
            tagSection,
            tagExtra.referencedBindings,
            import_compiler31.types.expressionStatement(
              callRuntime("attrsEvents", scopeIdentifier, visitAccessor)
            ),
            false
          );
        }
        if (usedAttrs.staticContentAttr) {
          const contentAttrValue = usedAttrs.staticContentAttr.value;
          addStatement(
            "render",
            tagSection,
            contentAttrValue.extra?.referencedBindings,
            import_compiler31.types.expressionStatement(
              callRuntime(
                "insertContent",
                scopeIdentifier,
                visitAccessor,
                contentAttrValue
              )
            )
          );
        }
        if (isOpenOnly) {
          switch (tagDef.htmlType) {
            case "svg":
            case "math":
              write2`/>`;
              break;
            default:
              write2`>`;
              break;
          }
        } else {
          write2`>`;
        }
        enter2(tag);
      },
      exit(tag) {
        const openTagOnly = (0, import_babel_utils23.getTagDef)(tag)?.parseOptions?.openTagOnly;
        tag.insertBefore(tag.node.body.body).forEach((child) => child.skip());
        if (!openTagOnly) {
          writeTo(tag)`</${tag.node.name}>`;
        }
        exit2(tag);
        tag.remove();
      }
    }
  })
};
function assertExclusiveControllableGroups(tag, attrs2) {
  const exclusiveGroups = [
    attrs2.open || attrs2.openChange,
    attrs2.checked || attrs2.checkedChange,
    attrs2.checkedValue || attrs2.checkedValueChange,
    attrs2.valueChange
  ].filter(Boolean);
  if (exclusiveGroups.length > 1) {
    throw tag.get("name").buildCodeFrameError(
      `The attributes ${exclusiveGroups.map((attr2) => `"${attr2.name}"`).join(", ")} are mutually exclusive.`
    );
  }
}
function getRelatedControllable(tagName, attrs2) {
  switch (tagName) {
    case "input":
      if (attrs2.checked || attrs2.checkedChange) {
        return {
          special: false,
          helper: "controllable_input_checked",
          attrs: [attrs2.checked, attrs2.checkedChange]
        };
      }
      if (attrs2.checkedValue || attrs2.checkedValueChange) {
        return {
          special: true,
          helper: "controllable_input_checkedValue",
          attrs: [attrs2.checkedValue, attrs2.checkedValueChange, attrs2.value]
        };
      }
      if (attrs2.value || attrs2.valueChange) {
        return {
          special: false,
          helper: "controllable_input_value",
          attrs: [attrs2.value, attrs2.valueChange]
        };
      }
      break;
    case "select":
      if (attrs2.value || attrs2.valueChange) {
        return {
          special: true,
          helper: "controllable_select_value",
          attrs: [attrs2.value, attrs2.valueChange]
        };
      }
      break;
    case "textarea":
      if (attrs2.value || attrs2.valueChange) {
        return {
          special: true,
          helper: "controllable_textarea_value",
          attrs: [attrs2.value, attrs2.valueChange]
        };
      }
      break;
    case "details":
    case "dialog":
      if (attrs2.open || attrs2.openChange) {
        return {
          special: false,
          helper: "controllable_detailsOrDialog_open",
          attrs: [attrs2.open, attrs2.openChange]
        };
      }
      break;
  }
}
function getUsedAttrs(tagName, tag) {
  const seen = {};
  const { attributes } = tag;
  const maybeStaticAttrs = /* @__PURE__ */ new Set();
  let spreadExpression;
  let skipExpression;
  let spreadProps;
  let skipProps;
  let staticControllable;
  let staticContentAttr;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    const { value } = attr2;
    if (import_compiler31.types.isMarkoSpreadAttribute(attr2)) {
      if (!spreadProps) {
        spreadProps = [];
        staticControllable = getRelatedControllable(tagName, seen);
        if (staticControllable && !staticControllable.attrs.every(Boolean)) {
          for (const attr3 of staticControllable.attrs) {
            if (attr3) {
              spreadProps.push(toObjectProperty(attr3.name, attr3.value));
              maybeStaticAttrs.delete(attr3);
            }
          }
          staticControllable = void 0;
        }
      }
      spreadProps.push(import_compiler31.types.spreadElement(value));
    } else if (!seen[attr2.name] || !(attr2.name === "content" && tag.body.body.length)) {
      seen[attr2.name] = attr2;
      if (spreadProps) {
        spreadProps.push(toObjectProperty(attr2.name, attr2.value));
      } else if (attr2.name === "content") {
        staticContentAttr = attr2;
      } else {
        maybeStaticAttrs.add(attr2);
      }
    }
  }
  if (!spreadProps) {
    staticControllable = getRelatedControllable(tagName, seen);
    if (staticControllable?.special === false && !staticControllable.attrs[1]) {
      staticControllable = void 0;
    }
  }
  if (staticControllable) {
    for (const attr2 of staticControllable.attrs) {
      if (attr2) {
        maybeStaticAttrs.delete(attr2);
      }
    }
  }
  const staticAttrs = [...maybeStaticAttrs].reverse();
  if (spreadProps) {
    spreadProps.reverse();
    if (staticControllable) {
      for (const attr2 of staticControllable.attrs) {
        if (attr2) {
          (skipProps ||= []).push(
            toObjectProperty(attr2.name, import_compiler31.types.numericLiteral(1))
          );
        }
      }
    }
    for (const { name: name2 } of staticAttrs) {
      (skipProps ||= []).push(toObjectProperty(name2, import_compiler31.types.numericLiteral(1)));
    }
    spreadExpression = propsToExpression(spreadProps);
  }
  if (skipProps) {
    skipExpression = import_compiler31.types.objectExpression(skipProps);
  }
  return {
    staticAttrs,
    staticContentAttr,
    staticControllable,
    spreadExpression,
    skipExpression
  };
}
function trackDelimitedAttrValue(expr, meta) {
  switch (expr.type) {
    case "ObjectExpression":
      trackDelimitedAttrObjectProperties(expr, meta);
      break;
    case "ArrayExpression":
      trackDelimitedAttrArrayItems(expr, meta);
      break;
    default:
      (meta.dynamicItems ||= []).push(expr);
      break;
  }
}
function trackDelimitedAttrArrayItems(arr, meta) {
  for (const item of arr.elements) {
    if (item) {
      switch (item.type) {
        case "ArrayExpression": {
          trackDelimitedAttrArrayItems(item, meta);
          break;
        }
        case "ObjectExpression": {
          trackDelimitedAttrObjectProperties(item, meta);
          break;
        }
        case "SpreadElement":
          if (item.argument.type === "ArrayExpression") {
            trackDelimitedAttrArrayItems(item.argument, meta);
          } else {
            (meta.dynamicItems ||= []).push(item);
          }
          break;
        default: {
          const evalItem = evaluate(item);
          if (evalItem.confident) {
            (meta.staticItems ||= []).push(evalItem.computed);
          } else {
            (meta.dynamicItems ||= []).push(item);
          }
          break;
        }
      }
    }
  }
}
function trackDelimitedAttrObjectProperties(obj, meta) {
  let staticProps;
  let dynamicProps;
  for (const prop of obj.properties) {
    if (prop.type !== "ObjectProperty" || prop.computed) {
      (dynamicProps ||= []).push(prop);
      continue;
    }
    let key;
    if (prop.key.type === "Identifier") {
      key = prop.key.name;
    } else {
      const keyEval = evaluate(prop.key);
      if (keyEval.confident) {
        key = keyEval.computed + "";
      } else {
        (dynamicProps ||= []).push(prop);
        continue;
      }
    }
    const value = prop.value;
    const propEval = evaluate(value);
    if (propEval.confident) {
      (staticProps ||= {})[key] = propEval.computed;
    } else {
      (meta.dynamicValues ||= {})[key] = value;
    }
  }
  if (staticProps) {
    (meta.staticItems ||= []).push(staticProps);
  }
  if (dynamicProps) {
    (meta.dynamicItems ||= []).push(import_compiler31.types.objectExpression(dynamicProps));
  }
}
function isChangeHandler(propName) {
  return /^(?:value|checked(?:Value)?|open)Change/.test(propName);
}
function buildUndefined() {
  return import_compiler31.types.unaryExpression("void", import_compiler31.types.numericLiteral(0));
}

// src/translator/util/is-only-child-in-parent.ts
var kOnlyChildInParent = Symbol("only child in parent");
var kNodeRef = Symbol("potential only child node ref");
function getOnlyChildParentTagName(tag, branchSize = 1) {
  const extra = tag.node.extra;
  if (extra[kOnlyChildInParent] !== void 0) {
    return extra[kOnlyChildInParent];
  }
  const parentTag = getParentTag(tag);
  return extra[kOnlyChildInParent] = parentTag && (0, import_babel_utils24.getTagDef)(parentTag)?.html && parentTag.node.name.type === "StringLiteral" && tag.parent.body.length === branchSize ? parentTag.node.name.value : false;
}
function getOptimizedOnlyChildNodeBinding(tag, section, branchSize = 1) {
  if (getOnlyChildParentTagName(tag, branchSize)) {
    const parentTag = getParentTag(tag).node;
    const parentTagName = parentTag.name?.value;
    return (parentTag.extra ??= {})[kNativeTagBinding] ??= createBinding(
      "#" + parentTagName,
      0 /* dom */,
      section
    );
  } else {
    return (tag.node.extra ??= {})[kNodeRef] ??= createBinding(
      "#text",
      0 /* dom */,
      section
    );
  }
}

// src/translator/core/for.ts
var for_default = {
  analyze(tag) {
    const tagSection = getOrCreateSection(tag);
    const isAttrTag = tag.node.body.attributeTags;
    const tagBody = tag.get("body");
    const paramsBinding = trackParamsReferences(
      tagBody,
      isAttrTag ? 4 /* local */ : 3 /* param */
    );
    let allowAttrs;
    (0, import_babel_utils25.assertNoVar)(tag);
    (0, import_babel_utils25.assertNoArgs)(tag);
    assertNoSpreadAttrs(tag);
    switch (getForType(tag.node)) {
      case "of":
        allowAttrs = ["of"];
        break;
      case "in":
        allowAttrs = ["in"];
        break;
      case "to":
        allowAttrs = ["to", "from", "step"];
        break;
      default:
        throw tag.buildCodeFrameError(
          "Invalid `for` tag, missing an `of=`, `in=`, `to=` attribute."
        );
    }
    if (!isAttrTag) {
      allowAttrs.push("by");
    }
    (0, import_babel_utils25.assertAllowedAttributes)(tag, allowAttrs);
    if (isAttrTag) return;
    const bodySection = startSection(tagBody);
    if (!bodySection) {
      dropReferences(getAllTagReferenceNodes(tag.node));
      return;
    }
    const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);
    const tagExtra = mergeReferences(
      tagSection,
      tag.node,
      getAllTagReferenceNodes(tag.node)
    );
    if (paramsBinding) {
      setBindingValueExpr(paramsBinding, tagExtra);
    }
    bodySection.sectionAccessor = {
      binding: nodeBinding,
      prefix: getAccessorPrefix().LoopScopeMap
    };
    bodySection.upstreamExpression = tagExtra;
    bodySection.isBranch = true;
  },
  translate: translateByTarget({
    html: {
      enter(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (!bodySection) {
          tag.remove();
          return;
        }
        setSectionParentIsOwner(bodySection, true);
        if (!getOnlyChildParentTagName(tag)) {
          visit(tag, 37 /* Replace */);
          enterShallow(tag);
        }
        flushBefore(tag);
      },
      exit(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const tagSection = getSection(tag);
        const bodySection = getSectionForBody(tagBody);
        const { node } = tag;
        const onlyChildParentTagName = getOnlyChildParentTagName(tag);
        const nodeBinding = getOptimizedOnlyChildNodeBinding(tag, tagSection);
        const forAttrs = getKnownAttrValues(node);
        const forType = getForType(node);
        const params = node.body.params;
        const statements = [];
        const bodyStatements = node.body.body;
        const singleNodeOptimization = bodySection.content === null || bodySection.content.singleChild && bodySection.content.startType !== 4 /* Text */;
        const branchSerializeReason = getSectionSerializeReason(
          bodySection,
          kBranchSerializeReason
        );
        const markerSerializeReason = getBindingSerializeReason(
          tagSection,
          nodeBinding
        );
        flushInto(tag);
        writeHTMLResumeStatements(tagBody);
        const forTagArgs = getBaseArgsInForTag(forType, forAttrs);
        const forTagHTMLRuntime = branchSerializeReason ? forTypeToHTMLResumeRuntime(forType) : forTypeToRuntime(forType);
        forTagArgs.push(
          import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(bodyStatements))
        );
        if (branchSerializeReason) {
          const skipParentEnd = onlyChildParentTagName && markerSerializeReason;
          const markerSerializeArg = getSerializeGuard(
            markerSerializeReason,
            !(skipParentEnd || singleNodeOptimization)
          );
          forTagArgs.push(
            forAttrs.by || import_compiler33.types.numericLiteral(0),
            getScopeIdIdentifier(tagSection),
            getScopeAccessorLiteral(nodeBinding),
            getSerializeGuard(branchSerializeReason, !markerSerializeArg),
            markerSerializeArg
          );
          if (skipParentEnd) {
            getParentTag(tag).node.extra[kSkipEndTag] = true;
            forTagArgs.push(import_compiler33.types.stringLiteral(`</${onlyChildParentTagName}>`));
          }
          if (singleNodeOptimization) {
            if (!skipParentEnd) {
              forTagArgs.push(import_compiler33.types.numericLiteral(0));
            }
            forTagArgs.push(import_compiler33.types.numericLiteral(1));
          }
        }
        statements.push(
          import_compiler33.types.expressionStatement(callRuntime(forTagHTMLRuntime, ...forTagArgs))
        );
        for (const replacement of tag.replaceWithMultiple(statements)) {
          replacement.skip();
        }
      }
    },
    dom: {
      enter(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (!bodySection) {
          tag.remove();
          return;
        }
        setSectionParentIsOwner(bodySection, true);
        if (!getOnlyChildParentTagName(tag)) {
          visit(tag, 37 /* Replace */);
          enterShallow(tag);
        }
      },
      exit(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const tagSection = getSection(tag);
        const bodySection = getSectionForBody(tagBody);
        const { node } = tag;
        const tagExtra = node.extra;
        const { referencedBindings } = tagExtra;
        const nodeRef2 = getOptimizedOnlyChildNodeBinding(tag, tagSection);
        setClosureSignalBuilder(tag, (closure, render) => {
          return callRuntime(
            "loopClosure",
            getScopeAccessorLiteral(closure),
            getScopeAccessorLiteral(nodeRef2),
            render
          );
        });
        const forType = getForType(node);
        const signal = getSignal(tagSection, nodeRef2, "for");
        signal.build = () => {
          return callRuntime(
            forTypeToDOMRuntime(forType),
            getScopeAccessorLiteral(nodeRef2),
            import_compiler33.types.identifier(bodySection.name)
          );
        };
        const forAttrs = getKnownAttrValues(node);
        const loopArgs = getBaseArgsInForTag(forType, forAttrs);
        if (forAttrs.by) {
          loopArgs.push(forAttrs.by);
        }
        addValue(
          tagSection,
          referencedBindings,
          signal,
          import_compiler33.types.arrayExpression(loopArgs)
        );
        tag.remove();
      }
    }
  }),
  parseOptions: { controlFlow: true },
  attributes: {
    of: {
      type: "expression",
      autocomplete: [
        {
          description: "Iterates over a list of items."
        }
      ]
    },
    in: {
      type: "expression",
      autocomplete: [
        {
          description: "Iterates over the keys and values of an object."
        }
      ]
    },
    to: {
      type: "number",
      autocomplete: [
        {
          description: "Iterates up to the provided number (inclusive)"
        }
      ]
    },
    from: {
      type: "number",
      autocomplete: [
        {
          description: "Iterates starting from the provided number (inclusive)"
        }
      ]
    },
    step: {
      type: "number",
      autocomplete: [
        {
          description: "The amount to increment during each interation (with from/to)"
        }
      ]
    }
  },
  autocomplete: [
    {
      snippet: "for|${1:value, index}| of=${3:array}",
      description: "Use to iterate over lists, object properties, or between ranges.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#iterating-over-a-list"
    },
    {
      snippet: "for|${1:name, value}| in=${3:object}",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#iterating-over-an-objects-properties"
    },
    {
      snippet: "for|${1:index}| to=${2:number}",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#iterating-between-a-range-of-numbers"
    }
  ]
};
function buildForRuntimeCall(type, attrs2, params, statements) {
  return import_compiler33.types.expressionStatement(
    callRuntime(
      forTypeToRuntime(type),
      ...getBaseArgsInForTag(type, attrs2),
      import_compiler33.types.arrowFunctionExpression(params, import_compiler33.types.blockStatement(statements))
    )
  );
}
function getForType(tag) {
  for (const attr2 of tag.attributes) {
    if (attr2.type === "MarkoAttribute") {
      switch (attr2.name) {
        case "of":
        case "in":
        case "to":
          return attr2.name;
      }
    }
  }
}
function forTypeToRuntime(type) {
  switch (type) {
    case "of":
      return "forOf";
    case "in":
      return "forIn";
    case "to":
      return "forTo";
  }
}
function forTypeToHTMLResumeRuntime(type) {
  switch (type) {
    case "of":
      return "resumeForOf";
    case "in":
      return "resumeForIn";
    case "to":
      return "resumeForTo";
  }
}
function forTypeToDOMRuntime(type) {
  switch (type) {
    case "of":
      return "loopOf";
    case "in":
      return "loopIn";
    case "to":
      return "loopTo";
  }
}
function getBaseArgsInForTag(type, attrs2) {
  switch (type) {
    case "in":
      return [attrs2.in];
    case "of":
      return [attrs2.of];
    case "to":
      return [
        attrs2.to,
        attrs2.from || import_compiler33.types.numericLiteral(0),
        attrs2.step || import_compiler33.types.numericLiteral(1)
      ];
  }
}

// src/translator/util/translate-attrs.ts
var contentProps = /* @__PURE__ */ new WeakSet();
function translateAttrs(tag, templateExports, statements = [], contentKey = "content") {
  const seen = /* @__PURE__ */ new Set();
  const properties = [];
  const attrTagLookup = tag.node.extra?.attributeTags;
  if (attrTagLookup) {
    for (const name2 in attrTagLookup) {
      const attrTagMeta = attrTagLookup[name2];
      if (usesExport(templateExports, attrTagMeta.name)) {
        seen.add(attrTagMeta.name);
        if (attrTagMeta.dynamic) {
          statements.push(
            import_compiler34.types.variableDeclaration("let", [
              import_compiler34.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta))
            ])
          );
          properties.push(
            toObjectProperty(
              attrTagMeta.name,
              getAttrTagIdentifier(attrTagMeta)
            )
          );
        }
      }
    }
    const attrTags2 = tag.node.body.attributeTags ? tag.get("body").get("body") : tag.get("attributeTags");
    for (let i = 0; i < attrTags2.length; i++) {
      const child = attrTags2[i];
      if (child.isMarkoTag()) {
        if ((0, import_babel_utils26.isAttributeTag)(child)) {
          const attrTagMeta = attrTagLookup[getTagName(child)];
          if (attrTagMeta.dynamic) {
            i = addDynamicAttrTagStatements(
              attrTags2,
              i,
              attrTagLookup,
              statements,
              templateExports,
              contentKey
            );
          } else {
            const translatedAttrTag = translateAttrs(
              child,
              templateExports?.[attrTagMeta.name]?.props,
              statements,
              contentKey
            );
            if (attrTagMeta.repeated) {
              const prevProp = findObjectProperty(attrTagMeta.name, properties);
              if (prevProp) {
                prevProp.value = callRuntime(
                  "attrTags",
                  prevProp.value,
                  propsToExpression(translatedAttrTag.properties)
                );
              } else {
                properties.push(
                  toObjectProperty(
                    attrTagMeta.name,
                    callRuntime(
                      "attrTag",
                      propsToExpression(translatedAttrTag.properties)
                    )
                  )
                );
              }
            } else {
              properties.push(
                toObjectProperty(
                  attrTagMeta.name,
                  callRuntime(
                    "attrTag",
                    propsToExpression(translatedAttrTag.properties)
                  )
                )
              );
            }
          }
        } else {
          i = addDynamicAttrTagStatements(
            attrTags2,
            i,
            attrTagLookup,
            statements,
            templateExports,
            contentKey
          );
        }
      }
    }
  }
  if (!seen.has(contentKey) && usesExport(templateExports, contentKey)) {
    seen.add(contentKey);
    const contentExpression = buildContent(tag.get("body"));
    if (contentExpression) {
      const contentProp = import_compiler34.types.objectProperty(
        import_compiler34.types.identifier(contentKey),
        contentExpression
      );
      contentProps.add(contentProp);
      properties.push(contentProp);
    }
  }
  const { attributes } = tag.node;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    const { value } = attr2;
    if (import_compiler34.types.isMarkoSpreadAttribute(attr2)) {
      properties.push(import_compiler34.types.spreadElement(value));
    } else if (!seen.has(attr2.name) && usesExport(templateExports, attr2.name)) {
      seen.add(attr2.name);
      properties.push(toObjectProperty(attr2.name, value));
    }
  }
  properties.reverse();
  return { properties, statements };
}
function getTranslatedBodyContentProperty(props) {
  for (const prop of props) {
    if (contentProps.has(prop)) {
      return prop;
    }
  }
}
function addDynamicAttrTagStatements(attrTags2, index, attrTagLookup, statements, templateExports, contentKey = "content") {
  const tag = attrTags2[index];
  if (tag.isMarkoTag()) {
    if ((0, import_babel_utils26.isAttributeTag)(tag)) {
      const attrTagMeta = attrTagLookup[getTagName(tag)];
      if (usesExport(templateExports, attrTagMeta.name) && attrTagMeta.dynamic) {
        const translatedAttrTag = translateAttrs(
          tag,
          templateExports?.[attrTagMeta.name]?.props,
          statements,
          contentKey
        );
        if (attrTagMeta.repeated) {
          statements.push(
            import_compiler34.types.expressionStatement(
              import_compiler34.types.assignmentExpression(
                "=",
                getAttrTagIdentifier(attrTagMeta),
                callRuntime(
                  "attrTags",
                  getAttrTagIdentifier(attrTagMeta),
                  propsToExpression(translatedAttrTag.properties)
                )
              )
            )
          );
        } else {
          statements.push(
            import_compiler34.types.expressionStatement(
              import_compiler34.types.assignmentExpression(
                "=",
                getAttrTagIdentifier(attrTagMeta),
                callRuntime(
                  "attrTag",
                  propsToExpression(translatedAttrTag.properties)
                )
              )
            )
          );
        }
      }
    } else {
      switch (getTagName(tag)) {
        case "if":
          return translateIfAttrTag(
            attrTags2,
            index,
            attrTagLookup,
            statements,
            templateExports,
            contentKey
          );
        case "for": {
          return translateForAttrTag(
            attrTags2,
            index,
            attrTagLookup,
            statements,
            templateExports,
            contentKey
          );
        }
      }
    }
  }
  return index;
}
function propsToExpression(props) {
  return props.length === 1 && import_compiler34.types.isSpreadElement(props[0]) ? props[0].argument : import_compiler34.types.objectExpression(props);
}
function translateForAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {
  const forTag = attrTags2[index];
  const bodyStatements = [];
  addAllAttrTagsAsDynamic(
    forTag,
    attrTagLookup,
    bodyStatements,
    templateExports,
    contentKey
  );
  statements.push(
    buildForRuntimeCall(
      getForType(forTag.node),
      getKnownAttrValues(forTag.node),
      forTag.node.body.params,
      bodyStatements
    )
  );
  return index;
}
function translateIfAttrTag(attrTags2, index, attrTagLookup, statements, templateExports, contentKey) {
  const ifTag = attrTags2[index];
  const consequentStatements = [];
  let ifStatement = import_compiler34.types.ifStatement(
    getConditionTestValue(ifTag),
    import_compiler34.types.blockStatement(consequentStatements)
  );
  statements.push(ifStatement);
  addAllAttrTagsAsDynamic(
    ifTag,
    attrTagLookup,
    consequentStatements,
    templateExports,
    contentKey
  );
  let nextIndex = index + 1;
  while (nextIndex < attrTags2.length) {
    const nextTag = attrTags2[nextIndex];
    if (nextTag.isMarkoTag()) {
      switch (getTagName(nextTag)) {
        case "else-if":
        case "else": {
          const testValue = getConditionTestValue(nextTag);
          const alternateStatements = [];
          addAllAttrTagsAsDynamic(
            nextTag,
            attrTagLookup,
            alternateStatements,
            templateExports,
            contentKey
          );
          if (testValue) {
            ifStatement.alternate = ifStatement = import_compiler34.types.ifStatement(
              testValue,
              import_compiler34.types.blockStatement(alternateStatements)
            );
            nextIndex++;
            continue;
          } else {
            ifStatement.alternate = import_compiler34.types.blockStatement(alternateStatements);
            break;
          }
        }
      }
    }
    break;
  }
  return nextIndex - 1;
}
function addAllAttrTagsAsDynamic(tag, attrTagLookup, statements, templateExports, contentKey) {
  const attrTags2 = tag.node.body.attributeTags ? tag.get("body").get("body") : tag.get("attributeTags");
  for (let i = 0; i < attrTags2.length; i++) {
    i = addDynamicAttrTagStatements(
      attrTags2,
      i,
      attrTagLookup,
      statements,
      templateExports,
      contentKey
    );
  }
}
function usesExport(templateExports, name2) {
  return !templateExports || !!templateExports[name2];
}
function findObjectProperty(name2, props) {
  for (const prop of props) {
    if (prop.type === "ObjectProperty") {
      switch (prop.key.type) {
        case "StringLiteral":
          if (prop.key.value === name2) {
            return prop;
          }
          break;
        case "Identifier":
          if (prop.key.name === name2) {
            return prop;
          }
          break;
      }
    }
  }
  return false;
}
function getConditionTestValue({
  node: { attributes }
}) {
  return attributes.length === 1 ? attributes[0].value : void 0;
}
function buildContent(body) {
  const bodySection = body.node.extra?.section;
  if (bodySection) {
    if (isOutputHTML()) {
      const serialized = isSerializedSection(bodySection);
      return callRuntime(
        serialized ? "registerContent" : "createContent",
        import_compiler34.types.stringLiteral(getResumeRegisterId(bodySection, "renderer")),
        import_compiler34.types.arrowFunctionExpression(
          body.node.params,
          import_compiler34.types.blockStatement(body.node.body)
        ),
        serialized ? getScopeIdIdentifier(
          getSection(
            getNonAttributeTagParent(
              body.parentPath
            )
          )
        ) : void 0
      );
    } else {
      return import_compiler34.types.callExpression(
        import_compiler34.types.identifier(bodySection.name),
        bodySection.referencedLocalClosures ? [
          scopeIdentifier,
          import_compiler34.types.objectExpression(
            toArray(bodySection.referencedLocalClosures, (ref) => {
              const accessor = getScopeAccessor(ref);
              const isShorthand = accessor === ref.name;
              return import_compiler34.types.objectProperty(
                toPropertyName(accessor),
                import_compiler34.types.identifier(ref.name),
                false,
                isShorthand
              );
            })
          )
        ] : [scopeIdentifier]
      );
    }
  }
}
function getNonAttributeTagParent(tag) {
  let cur = tag;
  while ((0, import_babel_utils26.isAttributeTag)(cur) || (0, import_babel_utils26.isTransparentTag)(cur)) {
    cur = getParentTag(cur);
  }
  return cur;
}

// src/translator/core/define.ts
var define_default = {
  analyze(tag) {
    (0, import_babel_utils27.assertNoArgs)(tag);
    if (!tag.node.var) {
      throw tag.get("name").buildCodeFrameError("The `define` tag requires a tag variable.");
    }
    const tagBody = tag.get("body");
    const bodySection = startSection(tagBody);
    const varBinding = trackVarReferences(tag, 5 /* derived */);
    if (bodySection) {
      if (varBinding) {
        bodySection.downstreamBinding = varBinding.propertyAliases.get("content") || varBinding;
      }
    }
    trackParamsReferences(tagBody, 3 /* param */);
    analyzeAttributeTags(tag);
    const tagExtra = mergeReferences(
      getOrCreateSection(tag),
      tag.node,
      getAllTagReferenceNodes(tag.node)
    );
    if (varBinding) {
      setBindingValueExpr(varBinding, tagExtra);
    }
  },
  translate: {
    enter(tag) {
      if (isOutputHTML()) {
        flushBefore(tag);
      }
    },
    exit(tag) {
      const { node } = tag;
      const translatedAttrs = translateAttrs(tag);
      if (isOutputHTML()) {
        flushInto(tag);
        writeHTMLResumeStatements(tag.get("body"));
        tag.insertBefore(translatedAttrs.statements);
        translateVar(tag, propsToExpression(translatedAttrs.properties));
      } else {
        const section = getSection(tag);
        const referencedBindings = node.extra?.referencedBindings;
        const derivation = initValue(tag.get("var").node.extra.binding);
        if (translatedAttrs.statements.length) {
          addStatement(
            "render",
            section,
            referencedBindings,
            translatedAttrs.statements
          );
        }
        addValue(
          section,
          referencedBindings,
          derivation,
          propsToExpression(translatedAttrs.properties)
        );
      }
      tag.remove();
    }
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create a constant object binding that can be rendered.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#define"
    }
  ],
  types: runtime_info_default.name + "/tag-types/define.d.marko"
};

// src/translator/core/effect.ts
var import_compiler36 = require("@marko/compiler");
var import_babel_utils28 = require("@marko/compiler/babel-utils");
var effect_default = {
  migrate: [
    (tag) => {
      (0, import_babel_utils28.assertNoArgs)(tag);
      (0, import_babel_utils28.assertNoParams)(tag);
      assertNoBodyContent(tag);
      (0, import_babel_utils28.assertNoAttributeTags)(tag);
      assertNoSpreadAttrs(tag);
      (0, import_babel_utils28.assertAllowedAttributes)(tag, ["value"]);
      (0, import_babel_utils28.diagnosticDeprecate)(tag, {
        label: "The 'effect' tag has been replaced by the 'script' tag.",
        fix() {
          const { node } = tag;
          tag.replaceWith(
            import_compiler36.types.markoTag(
              withPreviousLocation(import_compiler36.types.stringLiteral("script"), node.name),
              node.attributes,
              node.body,
              node.arguments,
              node.var,
              node.attributeTags
            )
          );
        }
      });
    }
  ],
  attributes: {},
  types: runtime_info_default.name + "/tag-types/effect.d.marko"
};

// src/translator/core/export.ts
var import_babel_utils29 = require("@marko/compiler/babel-utils");
var export_default = {
  parse(tag) {
    const { node } = tag;
    tag.replaceWith(
      (0, import_babel_utils29.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]
    );
  },
  parseOptions: {
    statement: true,
    rawOpenTag: true
  },
  autocomplete: [
    {
      displayText: "export <value>"
    }
  ]
};

// src/translator/core/html-comment.ts
var import_compiler37 = require("@marko/compiler");
var import_babel_utils30 = require("@marko/compiler/babel-utils");
var kNodeBinding = Symbol("comment tag binding");
var kGetterId2 = Symbol("node getter id");
var html_comment_default = {
  analyze(tag) {
    (0, import_babel_utils30.assertNoArgs)(tag);
    (0, import_babel_utils30.assertNoParams)(tag);
    (0, import_babel_utils30.assertNoAttributes)(tag);
    const tagVar = tag.node.var;
    let needsBinding = false;
    let needsGetter = false;
    if (tagVar) {
      if (!import_compiler37.types.isIdentifier(tagVar)) {
        throw tag.get("var").buildCodeFrameError(
          "The `html-comment` tag variable cannot be destructured."
        );
      }
      needsBinding = true;
      for (const ref of tag.scope.getBinding(tagVar.name).referencePaths) {
        if (!isInvokedFunction(ref)) {
          needsGetter = true;
          break;
        }
      }
    }
    const referenceNodes = [];
    for (const child of tag.get("body").get("body")) {
      if (child.isMarkoPlaceholder()) {
        referenceNodes.push(child.node.value);
        needsBinding = true;
      } else if (!child.isMarkoText()) {
        throw child.buildCodeFrameError(
          "Invalid child. Only text is allowed inside an html comment."
        );
      }
    }
    if (needsBinding) {
      const tagSection = getOrCreateSection(tag);
      const tagExtra = mergeReferences(tagSection, tag.node, referenceNodes);
      const nodeBinding = tagExtra[kNodeBinding] = createBinding(
        "#comment",
        0 /* dom */,
        tagSection
      );
      if (needsGetter) {
        tagExtra[kGetterId2] = getRegisterUID(tagSection, "comment");
      }
      if (tagVar) {
        forceBindingSerialize(tagSection, nodeBinding);
      } else {
        addBindingSerializeReasonExpr(tagSection, nodeBinding, tagExtra);
      }
    }
    tag.skip();
  },
  translate: {
    enter(tag) {
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding];
      const hasVar = !!tag.node.var;
      if (hasVar) {
        const getterId = tagExtra[kGetterId2];
        if (isOutputHTML()) {
          translateVar(
            tag,
            callRuntime(
              "nodeRef",
              getterId && getScopeIdIdentifier(getSection(tag)),
              getterId && import_compiler37.types.stringLiteral(getterId)
            )
          );
        } else {
          const varName = tag.node.var.name;
          const references = tag.scope.getBinding(varName).referencePaths;
          let getterFnIdentifier;
          if (getterId) {
            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);
            (0, import_babel_utils30.getProgram)().node.body.push(
              import_compiler37.types.variableDeclaration("const", [
                import_compiler37.types.variableDeclarator(
                  getterFnIdentifier,
                  callRuntime(
                    "nodeRef",
                    import_compiler37.types.stringLiteral(getterId),
                    getScopeAccessorLiteral(nodeBinding)
                  )
                )
              ])
            );
          }
          for (const reference of references) {
            const referenceSection = getSection(reference);
            if (isInvokedFunction(reference)) {
              reference.parentPath.replaceWith(
                import_compiler37.types.expressionStatement(
                  createScopeReadExpression(referenceSection, nodeBinding)
                )
              );
            } else if (getterFnIdentifier) {
              reference.replaceWith(
                import_compiler37.types.callExpression(getterFnIdentifier, [
                  getScopeExpression(referenceSection, getSection(tag))
                ])
              );
            }
          }
        }
      }
      if (nodeBinding) {
        visit(tag, 32 /* Get */);
      }
      enter2(tag);
      writeTo(tag)`<!--`;
    },
    exit(tag) {
      const tagSection = getSection(tag);
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding];
      const write2 = writeTo(tag);
      if (isOutputHTML()) {
        for (const child of tag.node.body.body) {
          if (import_compiler37.types.isMarkoText(child)) {
            write2`${child.value}`;
          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {
            write2`${callRuntime("escapeXML", child.value)}`;
          }
        }
      } else {
        const templateQuasis = [];
        const templateExpressions = [];
        let currentQuasi = "";
        for (const child of tag.node.body.body) {
          if (import_compiler37.types.isMarkoText(child)) {
            currentQuasi += child.value;
          } else if (import_compiler37.types.isMarkoPlaceholder(child)) {
            templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));
            templateExpressions.push(child.value);
            currentQuasi = "";
          }
        }
        if (templateExpressions.length === 0) {
          write2`${currentQuasi}`;
        } else {
          templateQuasis.push(import_compiler37.types.templateElement({ raw: currentQuasi }));
          addStatement(
            "render",
            getSection(tag),
            tagExtra.referencedBindings,
            import_compiler37.types.expressionStatement(
              callRuntime(
                "data",
                import_compiler37.types.memberExpression(
                  scopeIdentifier,
                  getScopeAccessorLiteral(nodeBinding),
                  true
                ),
                import_compiler37.types.templateLiteral(templateQuasis, templateExpressions)
              )
            )
          );
        }
      }
      exit2(tag);
      write2`-->`;
      if (nodeBinding) {
        markNode(
          tag,
          nodeBinding,
          getBindingSerializeReason(tagSection, nodeBinding)
        );
      }
      tag.remove();
    }
  },
  parseOptions: {
    text: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create an html comment that is not stripped from the output.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#html-comment"
    }
  ]
};

// src/translator/core/html-script.ts
var import_compiler38 = require("@marko/compiler");
var import_babel_utils31 = require("@marko/compiler/babel-utils");
var kNodeBinding2 = Symbol("script tag node binding");
var kGetterId3 = Symbol("node getter id");
var html_script_default = {
  analyze(tag) {
    (0, import_babel_utils31.assertNoArgs)(tag);
    (0, import_babel_utils31.assertNoParams)(tag);
    const { node } = tag;
    if (node.var && !import_compiler38.types.isIdentifier(node.var)) {
      throw tag.get("var").buildCodeFrameError(
        "Tag variables on native elements cannot be destructured."
      );
    }
    const seen = {};
    const { attributes } = tag.node;
    let spreadReferenceNodes;
    let exprExtras;
    let hasEventHandlers = false;
    let hasDynamicAttributes = false;
    for (let i = attributes.length; i--; ) {
      const attr2 = attributes[i];
      const valueExtra = attr2.value.extra ??= {};
      if (import_compiler38.types.isMarkoAttribute(attr2)) {
        if (seen[attr2.name]) {
          dropReferences(attr2.value);
          continue;
        }
        seen[attr2.name] = attr2;
        if (isEventHandler(attr2.name)) {
          valueExtra.isEffect = true;
          hasEventHandlers = true;
        } else if (!evaluate(attr2.value).confident) {
          hasDynamicAttributes = true;
        }
      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {
        valueExtra.isEffect = true;
        hasEventHandlers = true;
        hasDynamicAttributes = true;
      }
      if (spreadReferenceNodes) {
        spreadReferenceNodes.push(attr2.value);
      } else if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {
        spreadReferenceNodes = [attr2.value];
      } else {
        exprExtras = push(exprExtras, valueExtra);
      }
    }
    const bodyPlaceholderNodes = [];
    let hasBodyPlaceholders = false;
    for (const child of tag.node.body.body) {
      if (import_compiler38.types.isMarkoPlaceholder(child)) {
        bodyPlaceholderNodes.push(child.value);
        hasBodyPlaceholders = true;
      } else if (!import_compiler38.types.isMarkoText(child)) {
        throw tag.hub.buildError(
          child,
          "Invalid child. Only text is allowed inside an html-script."
        );
      }
    }
    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {
      const tagExtra = node.extra ??= {};
      const tagSection = getOrCreateSection(tag);
      const nodeBinding = tagExtra[kNodeBinding2] = createBinding(
        "#script",
        0 /* dom */,
        tagSection
      );
      (0, import_babel_utils31.getProgram)().node.extra.isInteractive ||= hasEventHandlers;
      if (spreadReferenceNodes) {
        mergeReferences(tagSection, tag.node, spreadReferenceNodes);
      }
      if (hasBodyPlaceholders) {
        exprExtras = push(
          exprExtras,
          bodyPlaceholderNodes.length === 1 ? bodyPlaceholderNodes[0].extra ??= {} : mergeReferences(
            tagSection,
            bodyPlaceholderNodes[0],
            bodyPlaceholderNodes.slice(1)
          )
        );
      }
      if (hasEventHandlers || spreadReferenceNodes) {
        forceBindingSerialize(tagSection, nodeBinding);
      }
      if (node.var) {
        forceBindingSerialize(tagSection, nodeBinding);
        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {
          const refSection = getOrCreateSection(ref);
          setReferencesScope(ref);
          if (isSameOrChildSection(tagSection, refSection)) {
            forceOwnersSerialize(
              refSection,
              tagSection,
              getAccessorProp().Owner
            );
            if (!tagExtra[kGetterId3] && !isInvokedFunction(ref)) {
              tagExtra[kGetterId3] = getRegisterUID(tagSection, "#script");
            }
          } else {
            trackHoistedReference(ref, nodeBinding);
          }
        }
      }
      addBindingSerializeReasonExpr(
        tagSection,
        nodeBinding,
        push(exprExtras, tagExtra)
      );
    }
  },
  translate: {
    enter(tag) {
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding2];
      const isHTML = isOutputHTML();
      const write2 = writeTo(tag);
      const tagSection = getSection(tag);
      const hasVar = !!tag.node.var;
      if (hasVar) {
        const getterId = tagExtra[kGetterId3];
        if (isHTML) {
          translateVar(
            tag,
            callRuntime(
              "nodeRef",
              getterId && getScopeIdIdentifier(tagSection),
              getterId && import_compiler38.types.stringLiteral(getterId)
            )
          );
        } else {
          const varName = tag.node.var.name;
          const references = tag.scope.getBinding(varName).referencePaths;
          let getterFnIdentifier;
          if (getterId) {
            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);
            (0, import_babel_utils31.getProgram)().node.body.push(
              import_compiler38.types.variableDeclaration("const", [
                import_compiler38.types.variableDeclarator(
                  getterFnIdentifier,
                  callRuntime(
                    "nodeRef",
                    import_compiler38.types.stringLiteral(getterId),
                    getScopeAccessorLiteral(nodeBinding)
                  )
                )
              ])
            );
          }
          for (const reference of references) {
            const referenceSection = getSection(reference);
            if (isInvokedFunction(reference)) {
              reference.parentPath.replaceWith(
                import_compiler38.types.expressionStatement(
                  createScopeReadExpression(referenceSection, nodeBinding)
                )
              );
            } else if (getterFnIdentifier) {
              reference.replaceWith(
                import_compiler38.types.callExpression(getterFnIdentifier, [
                  getScopeExpression(referenceSection, getSection(tag))
                ])
              );
            }
          }
        }
      }
      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);
      if (visitAccessor) {
        visit(tag, 32 /* Get */);
      }
      write2`<script`;
      const usedAttrs = getUsedAttrs2(tag.node);
      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;
      for (const attr2 of staticAttrs) {
        const { name: name2, value } = attr2;
        const { confident, computed } = value.extra || {};
        const valueReferences = value.extra?.referencedBindings;
        switch (name2) {
          case "class":
          case "style": {
            const helper = `${name2}Attr`;
            if (confident) {
              write2`${getHTMLRuntime()[helper](computed)}`;
            } else if (isHTML) {
              write2`${callRuntime(helper, value)}`;
            } else {
              addStatement(
                "render",
                tagSection,
                valueReferences,
                import_compiler38.types.expressionStatement(
                  callRuntime(
                    helper,
                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    value
                  )
                )
              );
            }
            break;
          }
          default:
            if (confident) {
              write2`${getHTMLRuntime().attr(name2, computed)}`;
            } else if (isHTML) {
              if (isEventHandler(name2)) {
                addHTMLEffectCall(tagSection, valueReferences);
              } else {
                write2`${callRuntime("attr", import_compiler38.types.stringLiteral(name2), value)}`;
              }
            } else if (isEventHandler(name2)) {
              addStatement(
                "effect",
                tagSection,
                valueReferences,
                import_compiler38.types.expressionStatement(
                  callRuntime(
                    "on",
                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    import_compiler38.types.stringLiteral(getEventHandlerName(name2)),
                    value
                  )
                )
              );
            } else {
              addStatement(
                "render",
                tagSection,
                valueReferences,
                import_compiler38.types.expressionStatement(
                  callRuntime(
                    "attr",
                    import_compiler38.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    import_compiler38.types.stringLiteral(name2),
                    value
                  )
                )
              );
            }
            break;
        }
      }
      if (spreadExpression) {
        if (isHTML) {
          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);
          if (skipExpression) {
            write2`${callRuntime("partialAttrs", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral("script"))}`;
          } else {
            write2`${callRuntime("attrs", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler38.types.stringLiteral("script"))}`;
          }
        } else {
          if (skipExpression) {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler38.types.expressionStatement(
                callRuntime(
                  "partialAttrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression,
                  skipExpression
                )
              )
            );
          } else {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler38.types.expressionStatement(
                callRuntime(
                  "attrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression
                )
              )
            );
          }
          addStatement(
            "effect",
            tagSection,
            tagExtra.referencedBindings,
            import_compiler38.types.expressionStatement(
              callRuntime("attrsEvents", scopeIdentifier, visitAccessor)
            ),
            false
          );
        }
      }
      write2`>`;
      enter2(tag);
    },
    exit(tag) {
      const tagSection = getSection(tag);
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding2];
      const write2 = writeTo(tag);
      if (isOutputHTML()) {
        for (const child of tag.node.body.body) {
          if (import_compiler38.types.isMarkoText(child)) {
            write2`${child.value}`;
          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {
            write2`${callRuntime("escapeScript", child.value)}`;
          }
        }
      } else {
        const templateQuasis = [];
        const templateExpressions = [];
        let currentQuasi = "";
        let referencePlaceholder;
        for (const child of tag.node.body.body) {
          if (import_compiler38.types.isMarkoText(child)) {
            currentQuasi += child.value;
          } else if (import_compiler38.types.isMarkoPlaceholder(child)) {
            referencePlaceholder ||= child;
            templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));
            templateExpressions.push(child.value);
            currentQuasi = "";
          }
        }
        if (!referencePlaceholder) {
          write2`${currentQuasi}`;
        } else {
          templateQuasis.push(import_compiler38.types.templateElement({ raw: currentQuasi }));
          addStatement(
            "render",
            getSection(tag),
            referencePlaceholder.value.extra?.referencedBindings,
            import_compiler38.types.expressionStatement(
              callRuntime(
                "textContent",
                import_compiler38.types.memberExpression(
                  scopeIdentifier,
                  getScopeAccessorLiteral(nodeBinding),
                  true
                ),
                import_compiler38.types.templateLiteral(templateQuasis, templateExpressions)
              )
            )
          );
        }
      }
      write2`</script>`;
      if (nodeBinding) {
        markNode(
          tag,
          nodeBinding,
          getBindingSerializeReason(tagSection, nodeBinding)
        );
      }
      exit2(tag);
      tag.remove();
    }
  },
  "@async": "#html-async",
  "@crossorigin": "#html-crossorigin",
  "@defer": "#html-defer",
  "@integrity": "#html-integrity",
  "@nomodule": "#html-nomodule",
  "@nonce": "#html-nonce",
  "@referrerpolicy": "#html-referrerpolicy",
  "@src": "#html-src",
  "@type": "#html-type",
  "attribute-groups": ["html-attributes"],
  parseOptions: {
    text: true,
    preserveWhitespace: true
  }
};
function getUsedAttrs2(tag) {
  const seen = {};
  const { attributes } = tag;
  const maybeStaticAttrs = /* @__PURE__ */ new Set();
  let spreadExpression;
  let skipExpression;
  let spreadProps;
  let skipProps;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    const { value } = attr2;
    if (import_compiler38.types.isMarkoSpreadAttribute(attr2)) {
      if (!spreadProps) {
        spreadProps = [];
      }
      spreadProps.push(import_compiler38.types.spreadElement(value));
    } else if (!seen[attr2.name]) {
      seen[attr2.name] = attr2;
      if (spreadProps) {
        spreadProps.push(toObjectProperty(attr2.name, attr2.value));
      } else {
        maybeStaticAttrs.add(attr2);
      }
    }
  }
  const staticAttrs = [...maybeStaticAttrs].reverse();
  if (spreadProps) {
    spreadProps.reverse();
    for (const { name: name2 } of staticAttrs) {
      (skipProps ||= []).push(toObjectProperty(name2, import_compiler38.types.numericLiteral(1)));
    }
    if (skipProps) {
      skipExpression = import_compiler38.types.objectExpression(skipProps);
    }
    spreadExpression = propsToExpression(spreadProps);
  }
  return {
    staticAttrs,
    spreadExpression,
    skipExpression
  };
}

// src/translator/core/html-style.ts
var import_compiler39 = require("@marko/compiler");
var import_babel_utils32 = require("@marko/compiler/babel-utils");
var kNodeBinding3 = Symbol("style tag node binding");
var kGetterId4 = Symbol("node getter id");
var html_style_default = {
  analyze(tag) {
    (0, import_babel_utils32.assertNoArgs)(tag);
    (0, import_babel_utils32.assertNoParams)(tag);
    const { node } = tag;
    if (node.var && !import_compiler39.types.isIdentifier(node.var)) {
      throw tag.get("var").buildCodeFrameError(
        "Tag variables on native elements cannot be destructured."
      );
    }
    const seen = {};
    const { attributes } = tag.node;
    let spreadReferenceNodes;
    let exprExtras;
    let hasEventHandlers = false;
    let hasDynamicAttributes = false;
    for (let i = attributes.length; i--; ) {
      const attr2 = attributes[i];
      const valueExtra = attr2.value.extra ??= {};
      if (import_compiler39.types.isMarkoAttribute(attr2)) {
        if (seen[attr2.name]) {
          dropReferences(attr2.value);
          continue;
        }
        seen[attr2.name] = attr2;
        if (isEventHandler(attr2.name)) {
          valueExtra.isEffect = true;
          hasEventHandlers = true;
        } else if (!evaluate(attr2.value).confident) {
          hasDynamicAttributes = true;
        }
      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {
        valueExtra.isEffect = true;
        hasEventHandlers = true;
        hasDynamicAttributes = true;
      }
      if (spreadReferenceNodes) {
        spreadReferenceNodes.push(attr2.value);
      } else if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {
        spreadReferenceNodes = [attr2.value];
      } else {
        exprExtras = push(exprExtras, valueExtra);
      }
    }
    const bodyPlaceholderNodes = [];
    let hasBodyPlaceholders = false;
    for (const child of tag.node.body.body) {
      if (import_compiler39.types.isMarkoPlaceholder(child)) {
        bodyPlaceholderNodes.push(child.value);
        hasBodyPlaceholders = true;
      } else if (!import_compiler39.types.isMarkoText(child)) {
        throw tag.hub.buildError(
          child,
          "Invalid child. Only text is allowed inside an html-style."
        );
      }
    }
    if (node.var || hasEventHandlers || hasDynamicAttributes || hasBodyPlaceholders) {
      const tagExtra = node.extra ??= {};
      const tagSection = getOrCreateSection(tag);
      const nodeBinding = tagExtra[kNodeBinding3] = createBinding(
        "#style",
        0 /* dom */,
        tagSection
      );
      (0, import_babel_utils32.getProgram)().node.extra.isInteractive ||= hasEventHandlers;
      if (spreadReferenceNodes) {
        mergeReferences(tagSection, tag.node, spreadReferenceNodes);
      }
      if (hasBodyPlaceholders) {
        exprExtras = push(
          exprExtras,
          bodyPlaceholderNodes.length === 1 ? bodyPlaceholderNodes[0].extra ??= {} : mergeReferences(
            tagSection,
            bodyPlaceholderNodes[0],
            bodyPlaceholderNodes.slice(1)
          )
        );
      }
      if (hasEventHandlers || spreadReferenceNodes) {
        forceBindingSerialize(tagSection, nodeBinding);
      }
      if (node.var) {
        forceBindingSerialize(tagSection, nodeBinding);
        for (const ref of tag.scope.getBinding(node.var.name).referencePaths) {
          const refSection = getOrCreateSection(ref);
          setReferencesScope(ref);
          if (isSameOrChildSection(tagSection, refSection)) {
            forceOwnersSerialize(
              refSection,
              tagSection,
              getAccessorProp().Owner
            );
            if (!tagExtra[kGetterId4] && !isInvokedFunction(ref)) {
              tagExtra[kGetterId4] = getRegisterUID(tagSection, "#style");
            }
          } else {
            trackHoistedReference(ref, nodeBinding);
          }
        }
      }
      addBindingSerializeReasonExpr(
        tagSection,
        nodeBinding,
        push(exprExtras, tagExtra)
      );
    }
  },
  translate: {
    enter(tag) {
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding3];
      const isHTML = isOutputHTML();
      const write2 = writeTo(tag);
      const tagSection = getSection(tag);
      const hasVar = !!tag.node.var;
      if (hasVar) {
        const getterId = tagExtra[kGetterId4];
        if (isHTML) {
          translateVar(
            tag,
            callRuntime(
              "nodeRef",
              getterId && getScopeIdIdentifier(tagSection),
              getterId && import_compiler39.types.stringLiteral(getterId)
            )
          );
        } else {
          const varName = tag.node.var.name;
          const references = tag.scope.getBinding(varName).referencePaths;
          let getterFnIdentifier;
          if (getterId) {
            getterFnIdentifier = generateUidIdentifier(`get_${varName}`);
            (0, import_babel_utils32.getProgram)().node.body.push(
              import_compiler39.types.variableDeclaration("const", [
                import_compiler39.types.variableDeclarator(
                  getterFnIdentifier,
                  callRuntime(
                    "nodeRef",
                    import_compiler39.types.stringLiteral(getterId),
                    getScopeAccessorLiteral(nodeBinding)
                  )
                )
              ])
            );
          }
          for (const reference of references) {
            const referenceSection = getSection(reference);
            if (isInvokedFunction(reference)) {
              reference.parentPath.replaceWith(
                import_compiler39.types.expressionStatement(
                  createScopeReadExpression(referenceSection, nodeBinding)
                )
              );
            } else if (getterFnIdentifier) {
              reference.replaceWith(
                import_compiler39.types.callExpression(getterFnIdentifier, [
                  getScopeExpression(referenceSection, getSection(tag))
                ])
              );
            }
          }
        }
      }
      const visitAccessor = nodeBinding && getScopeAccessorLiteral(nodeBinding);
      if (visitAccessor) {
        visit(tag, 32 /* Get */);
      }
      write2`<style`;
      const usedAttrs = getUsedAttrs3(tag.node);
      const { staticAttrs, skipExpression, spreadExpression } = usedAttrs;
      for (const attr2 of staticAttrs) {
        const { name: name2, value } = attr2;
        const { confident, computed } = value.extra || {};
        const valueReferences = value.extra?.referencedBindings;
        switch (name2) {
          case "class":
          case "style": {
            const helper = `${name2}Attr`;
            if (confident) {
              write2`${getHTMLRuntime()[helper](computed)}`;
            } else if (isHTML) {
              write2`${callRuntime(helper, value)}`;
            } else {
              addStatement(
                "render",
                tagSection,
                valueReferences,
                import_compiler39.types.expressionStatement(
                  callRuntime(
                    helper,
                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    value
                  )
                )
              );
            }
            break;
          }
          default:
            if (confident) {
              write2`${getHTMLRuntime().attr(name2, computed)}`;
            } else if (isHTML) {
              if (isEventHandler(name2)) {
                addHTMLEffectCall(tagSection, valueReferences);
              } else {
                write2`${callRuntime("attr", import_compiler39.types.stringLiteral(name2), value)}`;
              }
            } else if (isEventHandler(name2)) {
              addStatement(
                "effect",
                tagSection,
                valueReferences,
                import_compiler39.types.expressionStatement(
                  callRuntime(
                    "on",
                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    import_compiler39.types.stringLiteral(getEventHandlerName(name2)),
                    value
                  )
                )
              );
            } else {
              addStatement(
                "render",
                tagSection,
                valueReferences,
                import_compiler39.types.expressionStatement(
                  callRuntime(
                    "attr",
                    import_compiler39.types.memberExpression(scopeIdentifier, visitAccessor, true),
                    import_compiler39.types.stringLiteral(name2),
                    value
                  )
                )
              );
            }
            break;
        }
      }
      if (spreadExpression) {
        if (isHTML) {
          addHTMLEffectCall(tagSection, tagExtra.referencedBindings);
          if (skipExpression) {
            write2`${callRuntime("partialAttrs", spreadExpression, skipExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral("style"))}`;
          } else {
            write2`${callRuntime("attrs", spreadExpression, visitAccessor, getScopeIdIdentifier(tagSection), import_compiler39.types.stringLiteral("style"))}`;
          }
        } else {
          if (skipExpression) {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler39.types.expressionStatement(
                callRuntime(
                  "partialAttrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression,
                  skipExpression
                )
              )
            );
          } else {
            addStatement(
              "render",
              tagSection,
              tagExtra.referencedBindings,
              import_compiler39.types.expressionStatement(
                callRuntime(
                  "attrs",
                  scopeIdentifier,
                  visitAccessor,
                  spreadExpression
                )
              )
            );
          }
          addStatement(
            "effect",
            tagSection,
            tagExtra.referencedBindings,
            import_compiler39.types.expressionStatement(
              callRuntime("attrsEvents", scopeIdentifier, visitAccessor)
            ),
            false
          );
        }
      }
      write2`>`;
      enter2(tag);
    },
    exit(tag) {
      const tagSection = getSection(tag);
      const tagExtra = tag.node.extra;
      const nodeBinding = tagExtra[kNodeBinding3];
      const write2 = writeTo(tag);
      if (isOutputHTML()) {
        for (const child of tag.node.body.body) {
          if (import_compiler39.types.isMarkoText(child)) {
            write2`${child.value}`;
          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {
            write2`${callRuntime("escapeStyle", child.value)}`;
          }
        }
      } else {
        const templateQuasis = [];
        const templateExpressions = [];
        let currentQuasi = "";
        let referencePlaceholder;
        for (const child of tag.node.body.body) {
          if (import_compiler39.types.isMarkoText(child)) {
            currentQuasi += child.value;
          } else if (import_compiler39.types.isMarkoPlaceholder(child)) {
            referencePlaceholder ||= child;
            templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));
            templateExpressions.push(child.value);
            currentQuasi = "";
          }
        }
        if (!referencePlaceholder) {
          write2`${currentQuasi}`;
        } else {
          templateQuasis.push(import_compiler39.types.templateElement({ raw: currentQuasi }));
          addStatement(
            "render",
            getSection(tag),
            referencePlaceholder.value.extra?.referencedBindings,
            import_compiler39.types.expressionStatement(
              callRuntime(
                "textContent",
                import_compiler39.types.memberExpression(
                  scopeIdentifier,
                  getScopeAccessorLiteral(nodeBinding),
                  true
                ),
                import_compiler39.types.templateLiteral(templateQuasis, templateExpressions)
              )
            )
          );
        }
      }
      write2`</style>`;
      if (nodeBinding) {
        markNode(
          tag,
          nodeBinding,
          getBindingSerializeReason(tagSection, nodeBinding)
        );
      }
      exit2(tag);
      tag.remove();
    }
  },
  "@disabled": "#html-disabled",
  "@media": "#html-media",
  "@nonce": "#html-nonce",
  "@type": "#html-type",
  "attribute-groups": ["html-attributes"],
  parseOptions: {
    text: true,
    preserveWhitespace: true
  }
};
function getUsedAttrs3(tag) {
  const seen = {};
  const { attributes } = tag;
  const maybeStaticAttrs = /* @__PURE__ */ new Set();
  let spreadExpression;
  let skipExpression;
  let spreadProps;
  let skipProps;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    const { value } = attr2;
    if (import_compiler39.types.isMarkoSpreadAttribute(attr2)) {
      if (!spreadProps) {
        spreadProps = [];
      }
      spreadProps.push(import_compiler39.types.spreadElement(value));
    } else if (!seen[attr2.name]) {
      seen[attr2.name] = attr2;
      if (spreadProps) {
        spreadProps.push(toObjectProperty(attr2.name, attr2.value));
      } else {
        maybeStaticAttrs.add(attr2);
      }
    }
  }
  const staticAttrs = [...maybeStaticAttrs].reverse();
  if (spreadProps) {
    spreadProps.reverse();
    for (const { name: name2 } of staticAttrs) {
      (skipProps ||= []).push(toObjectProperty(name2, import_compiler39.types.numericLiteral(1)));
    }
    if (skipProps) {
      skipExpression = import_compiler39.types.objectExpression(skipProps);
    }
    spreadExpression = propsToExpression(spreadProps);
  }
  return {
    staticAttrs,
    spreadExpression,
    skipExpression
  };
}

// src/translator/core/id.ts
var import_compiler40 = require("@marko/compiler");
var import_babel_utils33 = require("@marko/compiler/babel-utils");
var id_default = {
  analyze(tag) {
    (0, import_babel_utils33.assertNoArgs)(tag);
    (0, import_babel_utils33.assertNoParams)(tag);
    (0, import_babel_utils33.assertNoAttributes)(tag);
    assertNoBodyContent(tag);
    (0, import_babel_utils33.assertNoAttributeTags)(tag);
    const { node } = tag;
    if (!node.var) {
      throw tag.get("name").buildCodeFrameError("The `id` tag requires a tag variable.");
    }
    if (!import_compiler40.types.isIdentifier(node.var)) {
      throw tag.get("var").buildCodeFrameError("The `id` tag cannot be destructured");
    }
    const binding = trackVarReferences(tag, 5 /* derived */);
    if (binding) {
      setBindingValueExpr(binding, false);
    }
  },
  translate: {
    exit(tag) {
      const { node } = tag;
      const id = isOutputHTML() ? callRuntime("nextTagId") : callRuntime("nextTagId", scopeIdentifier);
      if (isOutputHTML()) {
        tag.replaceWith(
          import_compiler40.types.variableDeclaration("const", [import_compiler40.types.variableDeclarator(node.var, id)])
        );
      } else {
        const source = initValue(node.var.extra.binding);
        addValue(getSection(tag), void 0, source, id);
        tag.remove();
      }
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      displayText: "id/<name>",
      description: "Use to create a unique identifier.",
      snippet: "id/${1:name}",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#id"
    }
  ],
  types: runtime_info_default.name + "/tag-types/id.d.marko"
};

// src/translator/core/if.ts
var import_compiler42 = require("@marko/compiler");
var import_babel_utils34 = require("@marko/compiler/babel-utils");

// src/translator/util/to-first-statement-or-block.ts
var import_compiler41 = require("@marko/compiler");
function toFirstStatementOrBlock(body) {
  if (Array.isArray(body)) {
    if (body.length === 1) {
      return body[0];
    }
    return import_compiler41.types.blockStatement(body);
  }
  return body;
}

// src/translator/core/if.ts
var BRANCHES_LOOKUP = /* @__PURE__ */ new WeakMap();
var IfTag = {
  analyze(tag) {
    assertValidCondition(tag);
    if (tag.node.body.attributeTags) return;
    if (isLastBranch(tag)) {
      const branches = getBranches(tag);
      const [ifTag] = branches[0];
      const ifTagSection = getOrCreateSection(ifTag);
      const ifTagExtra = ifTag.node.extra ??= {};
      const mergeReferenceNodes = [];
      const nodeBinding = getOptimizedOnlyChildNodeBinding(
        ifTag,
        ifTagSection,
        branches.length
      );
      const sectionAccessor = {
        binding: nodeBinding,
        prefix: getAccessorPrefix().ConditionalScope
      };
      let singleNodeOptimization = true;
      for (const [branchTag, branchBodySection] of branches) {
        if (branchBodySection) {
          singleNodeOptimization &&= branchBodySection.content === null || branchBodySection.content?.singleChild && branchBodySection.content.startType !== 4 /* Text */;
          branchBodySection.isBranch = true;
          branchBodySection.upstreamExpression = ifTagExtra;
          branchBodySection.sectionAccessor = sectionAccessor;
        }
        if (branchTag.node.attributes.length) {
          mergeReferenceNodes.push(branchTag.node.attributes[0].value);
        }
      }
      mergeReferences(ifTagSection, ifTag.node, mergeReferenceNodes);
      ifTagExtra.singleNodeOptimization = singleNodeOptimization;
    }
  },
  translate: translateByTarget({
    html: {
      enter(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (isRoot(tag) && !getOnlyChildParentTagName(tag)) {
          visit(tag, 37 /* Replace */);
          enterShallow(tag);
        }
        flushBefore(tag);
        if (bodySection) {
          setSectionParentIsOwner(bodySection, true);
        }
      },
      exit(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (bodySection) {
          flushInto(tag);
          writeHTMLResumeStatements(tagBody);
        }
        if (isLastBranch(tag)) {
          const branches = getBranches(tag);
          const [ifTag] = branches[0];
          const ifTagSection = getSection(ifTag);
          const ifTagExtra = ifTag.node.extra;
          const singleNodeOptimization = ifTagExtra.singleNodeOptimization;
          const nodeBinding = getOptimizedOnlyChildNodeBinding(
            ifTag,
            ifTagSection
          );
          const onlyChildParentTagName = getOnlyChildParentTagName(ifTag);
          const markerSerializeReason = getBindingSerializeReason(
            ifTagSection,
            nodeBinding
          );
          const nextTag = tag.getNextSibling();
          let branchSerializeReasons;
          let statement;
          for (let i = branches.length; i--; ) {
            const [branchTag, branchBody] = branches[i];
            const bodyStatements = branchTag.node.body.body;
            if (branchBody) {
              const branchSerializeReason = getSectionSerializeReason(
                branchBody,
                kBranchSerializeReason
              );
              if (branchSerializeReason) {
                if (branchSerializeReasons !== true) {
                  if (branchSerializeReason === true || branchSerializeReason.state) {
                    branchSerializeReasons = true;
                  } else if (branchSerializeReasons) {
                    branchSerializeReasons = addSorted(
                      compareSources,
                      branchSerializeReasons,
                      branchSerializeReason
                    );
                  } else {
                    branchSerializeReasons = [branchSerializeReason];
                  }
                }
                bodyStatements.push(
                  import_compiler42.types.returnStatement(import_compiler42.types.numericLiteral(i))
                );
              }
            }
            const [testAttr] = branchTag.node.attributes;
            const curStatement = toFirstStatementOrBlock(bodyStatements);
            if (testAttr) {
              statement = import_compiler42.types.ifStatement(
                testAttr.value,
                curStatement,
                statement
              );
            } else {
              statement = curStatement;
            }
            branchTag.remove();
          }
          if (branchSerializeReasons) {
            const skipParentEnd = onlyChildParentTagName && markerSerializeReason;
            if (skipParentEnd) {
              getParentTag(ifTag).node.extra[kSkipEndTag] = true;
            }
            const markerSerializeArg = getSerializeGuard(
              markerSerializeReason,
              !(skipParentEnd || singleNodeOptimization)
            );
            const cbNode = import_compiler42.types.arrowFunctionExpression(
              [],
              import_compiler42.types.blockStatement([statement])
            );
            statement = import_compiler42.types.expressionStatement(
              callRuntime(
                "resumeConditional",
                cbNode,
                getScopeIdIdentifier(ifTagSection),
                getScopeAccessorLiteral(nodeBinding),
                getSerializeGuardForAny(
                  branchSerializeReasons,
                  !markerSerializeArg
                ),
                markerSerializeArg,
                skipParentEnd ? import_compiler42.types.stringLiteral(`</${onlyChildParentTagName}>`) : singleNodeOptimization ? import_compiler42.types.numericLiteral(0) : void 0,
                singleNodeOptimization ? import_compiler42.types.numericLiteral(1) : void 0
              )
            );
          }
          nextTag.insertBefore(statement);
        }
      }
    },
    dom: {
      enter(tag) {
        if (tag.node.body.attributeTags) return;
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        if (bodySection) {
          setSectionParentIsOwner(bodySection, true);
        }
        if (isRoot(tag) && !getOnlyChildParentTagName(tag)) {
          visit(tag, 37 /* Replace */);
          enterShallow(tag);
        }
      },
      exit(tag) {
        if (tag.node.body.attributeTags) return;
        if (isLastBranch(tag)) {
          const branches = getBranches(tag);
          const [ifTag] = branches[0];
          const ifTagSection = getSection(ifTag);
          const ifTagExtra = branches[0][0].node.extra;
          const nodeRef2 = getOptimizedOnlyChildNodeBinding(ifTag, ifTagSection);
          const rendererIdentifiers = [];
          let expr = import_compiler42.types.numericLiteral(branches.length);
          for (let i = branches.length; i--; ) {
            const [branchTag, branchBodySection] = branches[i];
            const [testAttr] = branchTag.node.attributes;
            const consequent = import_compiler42.types.numericLiteral(branchBodySection ? i : -1);
            if (branchBodySection) {
              rendererIdentifiers.push(import_compiler42.types.identifier(branchBodySection.name));
              setClosureSignalBuilder(branchTag, (closure, render) => {
                return callRuntime(
                  "conditionalClosure",
                  getScopeAccessorLiteral(closure),
                  getScopeAccessorLiteral(nodeRef2),
                  import_compiler42.types.numericLiteral(i),
                  render
                );
              });
            }
            branchTag.remove();
            expr = testAttr ? import_compiler42.types.conditionalExpression(testAttr.value, consequent, expr) : consequent;
          }
          const signal = getSignal(ifTagSection, nodeRef2, "if");
          signal.build = () => {
            return callRuntime(
              "conditional",
              getScopeAccessorLiteral(nodeRef2),
              ...rendererIdentifiers.reverse()
            );
          };
          addValue(ifTagSection, ifTagExtra.referencedBindings, signal, expr);
        }
      }
    }
  }),
  parseOptions: { controlFlow: true },
  autocomplete: [
    {
      snippet: "if=${1:condition}",
      description: "Use to display content only if the condition is met.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#if-else-if-else"
    }
  ]
};
var ElseIfTag = {
  ...IfTag,
  autocomplete: [
    {
      snippet: "else-if=${1:condition}",
      description: "Use after an <if> or <else-if> tag to display content if those conditions do not match and this one does.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#if-else-if-else"
    }
  ]
};
var ElseTag = {
  ...IfTag,
  autocomplete: [
    {
      description: "Use after an <if> or <else-if> tag to display content if those conditions do not match.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#if-else-if-else"
    }
  ]
};
function assertValidCondition(tag) {
  (0, import_babel_utils34.assertNoVar)(tag);
  (0, import_babel_utils34.assertNoArgs)(tag);
  (0, import_babel_utils34.assertNoParams)(tag);
  assertHasBody(tag);
  assertNoSpreadAttrs(tag);
  switch (getTagName(tag)) {
    case "if":
      assertHasValueAttribute(tag);
      break;
    case "else-if":
      assertHasValueAttribute(tag);
      assertHasPrecedingCondition(tag);
      break;
    case "else":
      assertOptionalIfAttribute(tag);
      assertHasPrecedingCondition(tag);
      break;
  }
}
function assertHasPrecedingCondition(tag) {
  let prev = tag.getPrevSibling();
  while (prev.node && prev.isMarkoComment()) prev = prev.getPrevSibling();
  if (!isConditionTag(prev) || getTagName(prev) !== "else" && !prev.node.attributes.length) {
    throw tag.buildCodeFrameError(
      `The \`<${getTagName(tag)}>\` must have a preceding \`<if=cond>\`, \`<else-if=cond>\`, or \`<else if=cond>\`.`
    );
  }
}
function assertHasBody(tag) {
  if (!(tag.node.body.body.length || tag.node.attributeTags.length)) {
    throw tag.get("name").buildCodeFrameError(
      `The \`${getTagName(tag)}\` tag requires body content.`
    );
  }
}
function assertHasValueAttribute(tag) {
  const { node } = tag;
  const [valueAttr] = node.attributes;
  if (!import_compiler42.types.isMarkoAttribute(valueAttr) || !valueAttr.default) {
    throw tag.get("name").buildCodeFrameError(`The \`${getTagName(tag)}\` tag requires a value.`);
  }
  if (node.attributes.length > 1) {
    const start = node.attributes[1].loc?.start;
    const end = node.attributes[node.attributes.length - 1].loc?.end;
    const msg = `The \`${getTagName(tag)}\` tag only supports the \`value\` attribute.`;
    if (start == null || end == null) {
      throw tag.get("name").buildCodeFrameError(msg);
    } else {
      throw tag.hub.buildError(
        { loc: { start, end } },
        msg,
        Error
      );
    }
  }
}
function assertOptionalIfAttribute(tag) {
  const { node } = tag;
  const [ifAttr] = node.attributes;
  if (node.attributes.length > 1 || ifAttr && ifAttr.name !== "if") {
    const start = node.attributes[1].loc?.start;
    const end = node.attributes[node.attributes.length - 1].loc?.end;
    const msg = `The \`${getTagName(tag)}\` tag only supports an \`if=\` attribute.`;
    if (start == null || end == null) {
      throw tag.get("name").buildCodeFrameError(msg);
    } else {
      throw tag.hub.buildError(
        { loc: { start, end } },
        msg,
        Error
      );
    }
  }
}
function getBranches(tag) {
  let branches = BRANCHES_LOOKUP.get(tag);
  if (!branches) {
    let curTag = tag;
    branches = [];
    do {
      BRANCHES_LOOKUP.set(curTag, branches);
      branches.push([
        curTag,
        startSection(curTag.get("body"))
      ]);
      while ((curTag = curTag.getNextSibling()).isMarkoComment()) ;
    } while (isCoreTagName(curTag, "else") || isCoreTagName(curTag, "else-if"));
  }
  return branches;
}
function isLastBranch(tag) {
  const branches = getBranches(tag);
  return branches[branches.length - 1][0] === tag;
}
function isRoot(tag) {
  return isCoreTagName(tag, "if");
}

// src/translator/core/import.ts
var import_babel_utils35 = require("@marko/compiler/babel-utils");
var import_default = {
  parse(tag) {
    const { node } = tag;
    tag.replaceWith(
      (0, import_babel_utils35.parseStatements)(tag.hub.file, node.rawValue, node.start, node.end)[0]
    );
  },
  parseOptions: {
    statement: true,
    rawOpenTag: true
  },
  autocomplete: [
    {
      displayText: 'import <scope> from "<path>"',
      description: "Use to import external modules, follows the same syntax as JavaScript imports.",
      snippet: 'import ${2} from "${1:path}"',
      descriptionMoreURL: "https://markojs.com/docs/syntax/#importing-external-files"
    }
  ]
};

// src/translator/core/let.ts
var import_compiler43 = require("@marko/compiler");
var import_babel_utils36 = require("@marko/compiler/babel-utils");
var let_default = {
  analyze(tag) {
    const { node } = tag;
    const tagVar = node.var;
    let valueAttr;
    let valueChangeAttr;
    for (const attr2 of node.attributes) {
      if (import_compiler43.types.isMarkoAttribute(attr2)) {
        if (attr2.name === "value") {
          valueAttr = attr2;
        } else if (attr2.name === "valueChange") {
          valueChangeAttr = attr2;
        } else {
          const start = attr2.loc?.start;
          const end = attr2.loc?.end;
          const msg = "The `let` tag only supports the `value` attribute and its change handler.";
          if (start == null || end == null) {
            throw tag.get("name").buildCodeFrameError(msg);
          } else {
            throw tag.hub.buildError(
              { loc: { start, end } },
              msg,
              Error
            );
          }
        }
      }
    }
    (0, import_babel_utils36.assertNoArgs)(tag);
    (0, import_babel_utils36.assertNoParams)(tag);
    assertNoBodyContent(tag);
    assertNoSpreadAttrs(tag);
    if (!tagVar) {
      throw tag.get("name").buildCodeFrameError("The `let` tag requires a tag variable.");
    }
    if (!import_compiler43.types.isIdentifier(tagVar)) {
      throw tag.get("var").buildCodeFrameError("The `let` tag variable cannot be destructured.");
    }
    if (valueChangeAttr && (0, import_babel_utils36.computeNode)(valueChangeAttr.value)) {
      throw tag.get("attributes").find((attr2) => attr2.node === valueChangeAttr).get("value").buildCodeFrameError(
        "The `let` tag `valueChange` attribute must be a function."
      );
    }
    const tagSection = getOrCreateSection(tag);
    const binding = trackVarReferences(tag, 1 /* let */);
    setBindingValueExpr(
      binding,
      mergeReferences(tagSection, tag.node, [
        valueAttr?.value,
        valueChangeAttr?.value
      ])
    );
    if (valueChangeAttr) {
      forceBindingSerialize(
        tagSection,
        binding,
        getAccessorPrefix().TagVariableChange
      );
    }
  },
  translate: {
    exit(tag) {
      const { node } = tag;
      const tagVar = node.var;
      const valueAttr = node.attributes.find(
        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && (attr2.default || attr2.name === "value")
      ) ?? import_compiler43.types.markoAttribute("value", import_compiler43.types.identifier("undefined"));
      const valueChangeAttr = node.attributes.find(
        (attr2) => import_compiler43.types.isMarkoAttribute(attr2) && attr2.name === "valueChange"
      );
      const section = getSection(tag);
      const binding = tagVar.extra.binding;
      if (isOutputDOM()) {
        const signal = initValue(binding, "state");
        const referencedBindings = tag.node.extra.referencedBindings;
        addValue(section, referencedBindings, signal, valueAttr.value);
        if (valueChangeAttr) {
          signal.extraArgs = [valueChangeAttr.value];
        }
        signal.buildAssignment = (valueSection, value) => {
          const scope = getScopeExpression(valueSection, signal.section);
          return import_compiler43.types.callExpression(signal.identifier, [scope, value]);
        };
      } else {
        translateVar(tag, valueAttr.value, "let");
        if (valueChangeAttr) {
          setBindingSerializedValue(
            section,
            binding,
            valueChangeAttr.value,
            getAccessorPrefix().TagVariableChange
          );
        }
      }
      tag.remove();
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create a mutable binding.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#let"
    }
  ],
  types: runtime_info_default.name + "/tag-types/let.d.marko"
};

// src/translator/core/lifecycle.ts
var import_compiler44 = require("@marko/compiler");
var import_babel_utils37 = require("@marko/compiler/babel-utils");
var kRef = Symbol("lifecycle attrs reference");
var lifecycle_default = {
  analyze(tag) {
    (0, import_babel_utils37.assertNoArgs)(tag);
    (0, import_babel_utils37.assertNoVar)(tag);
    (0, import_babel_utils37.assertNoParams)(tag);
    assertNoBodyContent(tag);
    const { node } = tag;
    const section = getOrCreateSection(tag);
    const tagExtra = mergeReferences(
      section,
      tag.node,
      getAllTagReferenceNodes(tag.node)
    );
    const binding = tagExtra[kRef] = createBinding(
      generateUid("lifecycle"),
      5 /* derived */,
      section
    );
    binding.downstreamExpressions.add(tagExtra);
    if (node.attributes.length === 0) {
      throw tag.get("name").buildCodeFrameError(
        "The `lifecycle` tag requires at least one attribute."
      );
    }
    for (const attr2 of node.attributes) {
      if (import_compiler44.types.isMarkoSpreadAttribute(attr2)) {
        throw tag.get("name").buildCodeFrameError(
          "The `lifecycle` tag does not support `...spread` attributes."
        );
      }
      (attr2.value.extra ??= {}).isEffect = true;
    }
    ((0, import_babel_utils37.getProgram)().node.extra ??= {}).isInteractive = true;
  },
  translate: {
    exit(tag) {
      const { node } = tag;
      const section = getSection(tag);
      const tagExtra = node.extra;
      const { referencedBindings } = tagExtra;
      const lifecycleAttrsRef = tagExtra[kRef];
      if (isOutputDOM()) {
        const translatedAttrs = translateAttrs(tag);
        translatedAttrs.statements.push(
          import_compiler44.types.expressionStatement(
            callRuntime(
              "lifecycle",
              scopeIdentifier,
              getScopeAccessorLiteral(lifecycleAttrsRef),
              propsToExpression(translatedAttrs.properties)
            )
          )
        );
        addStatement(
          "effect",
          section,
          referencedBindings,
          translatedAttrs.statements
        );
      } else {
        addHTMLEffectCall(section, referencedBindings);
      }
      tag.remove();
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create a side effects.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#effect"
    }
  ],
  types: runtime_info_default.name + "/tag-types/lifecycle.d.marko"
};

// src/translator/core/log.ts
var import_compiler45 = require("@marko/compiler");
var import_babel_utils38 = require("@marko/compiler/babel-utils");
var log_default = {
  analyze(tag) {
    const [valueAttr] = tag.node.attributes;
    (0, import_babel_utils38.assertNoArgs)(tag);
    (0, import_babel_utils38.assertNoVar)(tag);
    (0, import_babel_utils38.assertNoParams)(tag);
    assertNoBodyContent(tag);
    if (!valueAttr) {
      throw tag.get("name").buildCodeFrameError("The `log` tag requires a value.");
    }
    if (tag.node.attributes.length > 1 || !import_compiler45.types.isMarkoAttribute(valueAttr) || !valueAttr.default && valueAttr.name !== "value") {
      throw tag.get("name").buildCodeFrameError(
        "The `log` tag only supports the `value` attribute."
      );
    }
  },
  translate: {
    exit(tag) {
      const section = getSection(tag);
      const [valueAttr] = tag.node.attributes;
      const { value } = valueAttr;
      const referencedBindings = value.extra?.referencedBindings;
      const statement = import_compiler45.types.expressionStatement(
        import_compiler45.types.callExpression(
          import_compiler45.types.memberExpression(import_compiler45.types.identifier("console"), import_compiler45.types.identifier("log")),
          [value]
        )
      );
      if (isOutputHTML()) {
        tag.insertBefore(statement);
      } else {
        addStatement("render", section, referencedBindings, statement);
      }
      tag.remove();
    }
  },
  parseOptions: {
    openTagOnly: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to log a value to the console.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#log"
    }
  ],
  types: runtime_info_default.name + "/tag-types/log.d.marko"
};

// src/translator/core/script.ts
var import_compiler46 = require("@marko/compiler");
var import_babel_utils39 = require("@marko/compiler/babel-utils");
var htmlScriptTagAlternateMsg = " For a native html `script` tag use the `html-script` core tag instead.";
var script_default = {
  parse(tag) {
    const { node } = tag;
    const { body } = node.body;
    if (body.length) {
      let code = "";
      for (const child of body) {
        if (child.type !== "MarkoText") {
          throw tag.hub.file.hub.buildError(
            child,
            "Unexpected content in `script` tag. Only javascript and typescript is supported." + htmlScriptTagAlternateMsg,
            SyntaxError
          );
        }
        code += child.value;
      }
      const start = body[0]?.start;
      const end = body[body.length - 1]?.end;
      const bodyStatements = (0, import_babel_utils39.parseStatements)(tag.hub.file, code, start, end);
      const valueFn = import_compiler46.types.arrowFunctionExpression(
        [],
        import_compiler46.types.blockStatement(bodyStatements),
        traverseContains(bodyStatements, isAwaitExpression)
      );
      node.attributes.push(import_compiler46.types.markoAttribute("value", valueFn));
      node.body.body = [];
    }
  },
  analyze(tag) {
    const { node } = tag;
    (0, import_babel_utils39.assertNoArgs)(tag);
    (0, import_babel_utils39.assertNoParams)(tag);
    assertNoBodyContent(tag);
    (0, import_babel_utils39.assertNoAttributeTags)(tag);
    if (node.var) {
      throw tag.hub.buildError(
        node.var,
        "The `script` tag does not support a tag variable reference." + htmlScriptTagAlternateMsg
      );
    }
    let seenValueAttr = false;
    for (const attr2 of node.attributes) {
      if (attr2.type === "MarkoAttribute" && attr2.name === "value") {
        if (seenValueAttr) {
          throw tag.hub.buildError(attr2, "Invalid duplicate value attribute.");
        }
        seenValueAttr = true;
        (attr2.value.extra ??= {}).isEffect = true;
        ((0, import_babel_utils39.getProgram)().node.extra ??= {}).isInteractive = true;
      } else {
        throw tag.hub.buildError(
          attr2,
          "The `script` tag does not support html attributes." + htmlScriptTagAlternateMsg
        );
      }
    }
    if (!seenValueAttr) {
      dropReferences(getAllTagReferenceNodes(node));
    }
  },
  translate: {
    exit(tag) {
      const { node } = tag;
      const [valueAttr] = node.attributes;
      if (!valueAttr) {
        tag.remove();
        return;
      }
      const section = getSection(tag);
      const { value } = valueAttr;
      const referencedBindings = value.extra?.referencedBindings;
      if (isOutputDOM()) {
        const { value: value2 } = valueAttr;
        const isFunction2 = import_compiler46.types.isFunctionExpression(value2) || import_compiler46.types.isArrowFunctionExpression(value2);
        let inlineBody = null;
        if (isFunction2 && !(value2.async || value2.generator)) {
          if (import_compiler46.types.isBlockStatement(value2.body)) {
            let hasDeclaration = false;
            for (const child of value2.body.body) {
              if (import_compiler46.types.isDeclaration(child)) {
                hasDeclaration = true;
                break;
              }
            }
            inlineBody = hasDeclaration ? value2.body : value2.body.body;
          } else {
            inlineBody = import_compiler46.types.expressionStatement(value2.body);
          }
        }
        addStatement(
          "effect",
          section,
          referencedBindings,
          inlineBody || import_compiler46.types.expressionStatement(
            import_compiler46.types.callExpression(value2, isFunction2 ? [] : [scopeIdentifier])
          )
        );
      } else {
        addHTMLEffectCall(section, referencedBindings);
      }
      tag.remove();
    }
  },
  parseOptions: {
    text: true,
    preserveWhitespace: true
  },
  attributes: {},
  autocomplete: [
    {
      description: "Use to create a side effects.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#script"
    }
  ],
  types: runtime_info_default.name + "/tag-types/script.d.marko"
};
function isAwaitExpression(node) {
  switch (node.type) {
    case "ForOfStatement":
      return node.await;
    case "FunctionDeclaration":
    case "FunctionExpression":
    case "ArrowFunctionExpression":
    case "ClassMethod":
    case "ObjectMethod":
    case "ClassPrivateMethod":
      return skip;
    case "AwaitExpression":
      return true;
    default:
      return false;
  }
}

// src/translator/core/server.ts
var import_compiler47 = require("@marko/compiler");
var import_babel_utils40 = require("@marko/compiler/babel-utils");
var server_default = {
  parse(tag) {
    const {
      node,
      hub: { file }
    } = tag;
    const rawValue = node.rawValue;
    const code = rawValue.replace(/^server\s*/, "").trim();
    const start = node.name.start + (rawValue.length - code.length);
    let body = (0, import_babel_utils40.parseStatements)(file, code, start, start + code.length);
    if (body.length === 1 && import_compiler47.types.isBlockStatement(body[0])) {
      body = body[0].body;
    }
    tag.replaceWith(import_compiler47.types.markoScriptlet(body, true, "server"));
  },
  parseOptions: {
    statement: true,
    rawOpenTag: true
  },
  autocomplete: [
    {
      displayText: "server <statement>",
      description: "A JavaScript statement which is only evaluated once your template is loaded on the server.",
      descriptionMoreURL: "https://markojs.com/docs/syntax/#server-javascript"
    }
  ]
};

// src/translator/core/static.ts
var import_compiler48 = require("@marko/compiler");
var import_babel_utils41 = require("@marko/compiler/babel-utils");
var static_default = {
  parse(tag) {
    const {
      node,
      hub: { file }
    } = tag;
    const rawValue = node.rawValue;
    const code = rawValue.replace(/^static\s*/, "").trim();
    const start = node.name.start + (rawValue.length - code.length);
    let body = (0, import_babel_utils41.parseStatements)(file, code, start, start + code.length);
    if (body.length === 1 && import_compiler48.types.isBlockStatement(body[0])) {
      body = body[0].body;
    }
    tag.replaceWith(import_compiler48.types.markoScriptlet(body, true));
  },
  parseOptions: {
    statement: true,
    rawOpenTag: true
  },
  autocomplete: [
    {
      displayText: "static <statement>",
      description: "A JavaScript statement which is only evaluated once your template is loaded.",
      descriptionMoreURL: "https://markojs.com/docs/syntax/#static-javascript"
    }
  ]
};

// src/translator/core/style.ts
var import_compiler49 = require("@marko/compiler");
var import_babel_utils42 = require("@marko/compiler/babel-utils");
var import_magic_string = __toESM(require("magic-string"));
var import_path3 = __toESM(require("path"));
var STYLE_EXT_REG = /^style((?:\.[a-zA-Z0-9$_-]+)+)?/;
var htmlStyleTagAlternateMsg = " For a native html `style` tag use the `html-style` core tag instead.";
var style_default = {
  analyze(tag) {
    (0, import_babel_utils42.assertNoArgs)(tag);
    (0, import_babel_utils42.assertNoParams)(tag);
    (0, import_babel_utils42.assertNoAttributeTags)(tag);
    const { node } = tag;
    const ext = STYLE_EXT_REG.exec(node.rawValue || "")?.[1]?.slice(1);
    for (const attr2 of node.attributes) {
      if (attr2.start == null && attr2.type === "MarkoAttribute" && attr2.name === "class" && attr2.value.type === "StringLiteral" && attr2.value.value === ext) {
        continue;
      }
      throw tag.hub.buildError(
        attr2.value,
        "The `style` does not support html attributes." + htmlStyleTagAlternateMsg
      );
    }
    for (const child of node.body.body) {
      if (child.type !== "MarkoText") {
        throw tag.hub.buildError(
          child,
          "The `style` tag currently only supports static content." + htmlStyleTagAlternateMsg
        );
      }
    }
    if (node.body.body.length > 1) {
      throw tag.hub.buildError(
        node.name,
        "The `style` tag currently only supports static content." + htmlStyleTagAlternateMsg
      );
    }
  },
  translate(tag) {
    const {
      node,
      hub: { file }
    } = tag;
    const { filename, sourceMaps } = file.opts;
    let ext = STYLE_EXT_REG.exec(node.rawValue || "")?.[1] || ".css";
    if (node.var && !/\.module\./.test(ext)) {
      ext = ".module" + ext;
    }
    const markoText = node.body.body[0];
    const { resolveVirtualDependency } = getMarkoOpts();
    const start = (0, import_babel_utils42.getStart)(file, markoText);
    const end = (0, import_babel_utils42.getEnd)(file, markoText);
    let code = markoText.value;
    let map;
    if (resolveVirtualDependency && sourceMaps && start !== null && end !== null) {
      const magicString = new import_magic_string.default(file.code, { filename });
      magicString.remove(0, start);
      magicString.remove(end, file.code.length);
      map = magicString.generateMap({
        source: filename,
        includeContent: true
      });
      if (sourceMaps === "inline" || sourceMaps === "both") {
        code += `
/*# sourceMappingURL=${map.toUrl()}*/`;
        if (sourceMaps === "inline") {
          map = void 0;
        }
      }
    }
    const importPath = resolveVirtualDependency?.(filename, {
      virtualPath: `./${import_path3.default.basename(filename) + ext}`,
      code,
      map
    });
    if (importPath) {
      if (!node.var) {
        (0, import_babel_utils42.getProgram)().node.body.push(
          import_compiler49.types.importDeclaration([], import_compiler49.types.stringLiteral(importPath))
        );
      } else if (import_compiler49.types.isIdentifier(node.var)) {
        (0, import_babel_utils42.getProgram)().node.body.push(
          import_compiler49.types.importDeclaration(
            [import_compiler49.types.importNamespaceSpecifier(node.var)],
            import_compiler49.types.stringLiteral(importPath)
          )
        );
      } else {
        (0, import_babel_utils42.getProgram)().node.body.push(
          import_compiler49.types.variableDeclaration("const", [
            import_compiler49.types.variableDeclarator(
              node.var,
              (0, import_babel_utils42.importStar)(file, importPath, "style")
            )
          ])
        );
      }
    }
    tag.remove();
  },
  parseOptions: {
    html: false,
    text: true,
    rawOpenTag: true,
    preserveWhitespace: true
  },
  attributes: {}
};

// src/translator/core/try.ts
var import_compiler50 = require("@marko/compiler");
var import_babel_utils43 = require("@marko/compiler/babel-utils");
var kDOMBinding2 = Symbol("try tag dom binding");
var try_default = {
  analyze(tag) {
    (0, import_babel_utils43.assertNoVar)(tag);
    (0, import_babel_utils43.assertNoArgs)(tag);
    (0, import_babel_utils43.assertNoParams)(tag);
    (0, import_babel_utils43.assertNoAttributes)(tag);
    assertNoSpreadAttrs(tag);
    analyzeAttributeTags(tag);
    const section = getOrCreateSection(tag);
    const tagExtra = mergeReferences(
      section,
      tag.node,
      getAllTagReferenceNodes(tag.node)
    );
    tagExtra[kDOMBinding2] = createBinding("#text", 0 /* dom */, section);
    if (!tag.node.body.body.length) {
      throw tag.get("name").buildCodeFrameError("The `try` tag requires body content.");
    }
    startSection(tag.get("body"));
  },
  translate: translateByTarget({
    html: {
      enter(tag) {
        if (!getSectionForBody(tag.get("body"))) {
          tag.remove();
          return;
        }
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        setSectionParentIsOwner(bodySection, true);
        flushBefore(tag);
      },
      exit(tag) {
        const { node } = tag;
        const section = getSection(tag);
        const tagExtra = node.extra;
        const tagBody = tag.get("body");
        const translatedAttrs = translateAttrs(tag);
        const nodeRef2 = tagExtra[kDOMBinding2];
        const contentProp = getTranslatedBodyContentProperty(
          translatedAttrs.properties
        );
        if (contentProp) {
          translatedAttrs.properties.splice(
            translatedAttrs.properties.indexOf(contentProp),
            1
          );
        }
        flushInto(tag);
        writeHTMLResumeStatements(tagBody);
        tag.insertBefore(translatedAttrs.statements);
        tag.replaceWith(
          import_compiler50.types.expressionStatement(
            callRuntime(
              "tryContent",
              getScopeIdIdentifier(section),
              getScopeAccessorLiteral(nodeRef2),
              contentProp?.value,
              propsToExpression(translatedAttrs.properties)
            )
          )
        )[0].skip();
      }
    },
    dom: {
      enter(tag) {
        const tagBody = tag.get("body");
        const bodySection = getSectionForBody(tagBody);
        setSectionParentIsOwner(bodySection, true);
        visit(tag, 37 /* Replace */);
        enterShallow(tag);
      },
      exit(tag) {
        const { node } = tag;
        const tagExtra = node.extra;
        const nodeRef2 = tagExtra[kDOMBinding2];
        const referencedBindings = tagExtra.referencedBindings;
        const translatedAttrs = translateAttrs(tag);
        const contentProp = getTranslatedBodyContentProperty(
          translatedAttrs.properties
        );
        if (contentProp) {
          translatedAttrs.properties.splice(
            translatedAttrs.properties.indexOf(contentProp),
            1
          );
        }
        const section = getSection(tag);
        const bodySection = getSectionForBody(tag.get("body"));
        const signal = getSignal(section, nodeRef2, "try");
        signal.build = () => {
          return callRuntime(
            "createTry",
            getScopeAccessorLiteral(nodeRef2),
            import_compiler50.types.identifier(bodySection.name)
          );
        };
        if (translatedAttrs.statements.length) {
          addStatement(
            "render",
            section,
            referencedBindings,
            translatedAttrs.statements
          );
        }
        (0, import_babel_utils43.getProgram)().node.body.push(
          import_compiler50.types.expressionStatement(callRuntime("enableCatch"))
        );
        addValue(
          section,
          referencedBindings,
          signal,
          propsToExpression(translatedAttrs.properties)
        );
        tag.remove();
      }
    }
  }),
  attributes: {},
  autocomplete: [
    {
      description: "Used to capture errors and display placeholders for nested content.",
      descriptionMoreURL: "https://markojs.com/docs/core-tags/#try"
    }
  ],
  types: runtime_info_default.name + "/tag-types/try.d.marko"
};

// src/translator/core/index.ts
var core_default = {
  taglibId: runtime_info_default.taglibId,
  "<attrs>": attrs_default,
  "<await>": await_default,
  "<client>": client_default,
  "<const>": const_default,
  "<debug>": debug_default,
  "<define>": define_default,
  "<effect>": effect_default,
  "<else-if>": ElseIfTag,
  "<else>": ElseTag,
  "<export>": export_default,
  "<for>": for_default,
  "<html-comment>": html_comment_default,
  "<html-script>": html_script_default,
  "<html-style>": html_style_default,
  "<id>": id_default,
  "<if>": IfTag,
  "<import>": import_default,
  "<let>": let_default,
  "<lifecycle>": lifecycle_default,
  "<log>": log_default,
  "<return>": return_default,
  "<script>": script_default,
  "<server>": server_default,
  "<static>": static_default,
  "<style>": style_default,
  "<try>": try_default
};

// src/translator/visitors/cdata.ts
var cdata_default = {
  translate: {
    enter(cdata) {
      throw cdata.buildCodeFrameError(
        "CDATA sections are not supported in Marko."
      );
    }
  }
};

// src/translator/visitors/comment.ts
var comment_default = {
  translate: {
    exit(comment) {
      comment.remove();
    }
  }
};

// src/translator/visitors/declaration.ts
var declaration_default = {
  translate: {
    enter(decl) {
      throw decl.buildCodeFrameError(
        "XML declarations sections are not supported in Marko."
      );
    }
  }
};

// src/translator/visitors/document-type.ts
var document_type_default = {
  translate: {
    exit(documentType) {
      if (isOutputHTML()) {
        writeTo(documentType)`<!${documentType.node.value}>`;
      }
      documentType.remove();
    }
  }
};

// src/translator/visitors/function.ts
var import_compiler51 = require("@marko/compiler");
var import_babel_utils44 = require("@marko/compiler/babel-utils");
var function_default = {
  analyze(fn) {
    if (fn !== getFnRoot(fn)) {
      return;
    }
    const markoRoot = getMarkoRoot(fn);
    if (markoRoot && (markoRoot.isMarkoPlaceholder() || markoRoot.isMarkoScriptlet() && markoRoot.node.target === "server")) {
      return;
    }
    if (isMarkoAttribute(markoRoot) && ((0, import_babel_utils44.isNativeTag)(markoRoot.parentPath) && /^on[A-Z-]/.test(markoRoot.node.name) || isCoreTagName(markoRoot.parentPath, "script") || isCoreTagName(markoRoot.parentPath, "lifecycle") || isCoreTagName(markoRoot.parentPath, "for"))) {
      return;
    }
    const { node } = fn;
    const section = getSection(fn);
    const extra = node.extra ??= {};
    const {
      markoOpts,
      opts: { filename }
    } = (0, import_babel_utils44.getFile)();
    const name2 = extra.name = generateUid(
      fn.node.id?.name || (isMarkoAttribute(markoRoot) ? markoRoot.node.default ? import_compiler51.types.toIdentifier(
        markoRoot.parentPath.has("var") ? markoRoot.parentPath.get("var") : markoRoot.parentPath.get("name")
      ) : markoRoot.node.name : import_compiler51.types.isVariableDeclarator(fn.parent) && import_compiler51.types.isIdentifier(fn.parent.id) ? fn.parent.id.name : import_compiler51.types.isObjectMethod(node) && import_compiler51.types.isIdentifier(node.key) ? node.key.name : "anonymous")
    );
    extra.section = section;
    extra.registerId = (0, import_babel_utils44.getTemplateId)(
      markoOpts,
      filename,
      `${section.id}/${name2.slice(1)}`
    );
  }
};
function isMarkoAttribute(path5) {
  return path5 ? path5.isMarkoAttribute() : false;
}

// src/translator/visitors/import-declaration.ts
var import_babel_utils45 = require("@marko/compiler/babel-utils");
var import_declaration_default = {
  analyze(importDecl) {
    const { node } = importDecl;
    const { source } = node;
    const { value } = source;
    const tagImport = (0, import_babel_utils45.resolveTagImport)(importDecl, value);
    if (tagImport) {
      node.extra ??= {};
      node.extra.tagImport = tagImport;
      const tags = importDecl.hub.file.metadata.marko.tags;
      if (!tags.includes(tagImport)) {
        tags.push(tagImport);
      }
    }
  },
  translate: {
    exit(importDecl) {
      const { node } = importDecl;
      const { extra } = node;
      const tagImport = extra?.tagImport;
      if (tagImport) {
        node.source.value = tagImport;
      }
    }
  }
};

// src/translator/visitors/placeholder.ts
var import_compiler53 = require("@marko/compiler");

// src/translator/util/is-non-html-text.ts
var import_compiler52 = require("@marko/compiler");
function isNonHTMLText(placeholder) {
  const parentTag = placeholder.parentPath.isMarkoTagBody() && placeholder.parentPath.parentPath;
  if (parentTag && isCoreTag(parentTag)) {
    switch (parentTag.node.name.value) {
      case "html-comment":
      case "html-script":
      case "html-style":
        return true;
    }
  }
  return false;
}

// src/translator/visitors/placeholder.ts
var kNodeBinding4 = Symbol("placeholder node binding");
var kSiblingText = Symbol("placeholder has sibling text");
var kSharedText = Symbol(
  "placeholder will merge its visitor with a another node"
);
var placeholder_default = {
  analyze(placeholder) {
    if (isNonHTMLText(placeholder)) return;
    const { node } = placeholder;
    const valueExtra = evaluate(node.value);
    const { confident, computed } = valueExtra;
    if (confident && isVoid2(computed)) return;
    if (isStaticText(node)) {
      if (isStaticText(getPrev(placeholder))) {
        (node.extra ??= {})[kSharedText] = true;
      }
    } else {
      const section = getOrCreateSection(placeholder);
      const nodeBinding = (node.extra ??= {})[kNodeBinding4] = createBinding(
        "#text",
        0 /* dom */,
        section
      );
      analyzeSiblingText(placeholder);
      addBindingSerializeReasonExpr(section, nodeBinding, valueExtra);
    }
  },
  translate: {
    exit(placeholder) {
      if (isNonHTMLText(placeholder)) return;
      const { node } = placeholder;
      const { value } = node;
      const valueExtra = evaluate(value);
      const { confident, computed } = valueExtra;
      if (confident && isVoid2(computed)) {
        placeholder.remove();
        return;
      }
      const isHTML = isOutputHTML();
      const write2 = writeTo(placeholder);
      const extra = node.extra || {};
      const nodeBinding = extra[kNodeBinding4];
      const canWriteHTML = isHTML || confident && node.escape;
      const method = canWriteHTML ? node.escape ? "escapeXML" : "toString" : node.escape ? "data" : "html";
      if (confident && canWriteHTML) {
        write2`${getHTMLRuntime()[method](computed)}`;
      } else {
        const section = getSection(placeholder);
        const siblingText = extra[kSiblingText];
        const markerSerializeReason = nodeBinding && getBindingSerializeReason(section, nodeBinding);
        if (siblingText === 1 /* Before */) {
          if (isHTML && markerSerializeReason) {
            if (markerSerializeReason === true || markerSerializeReason.state) {
              write2`<!>`;
            } else {
              write2`${callRuntime("commentSeparator", getSerializeGuard(markerSerializeReason, true))}`;
            }
          }
          visit(placeholder, 37 /* Replace */);
        } else if (siblingText === 2 /* After */) {
          visit(placeholder, 37 /* Replace */);
        } else {
          if (!isHTML) write2` `;
          visit(placeholder, 32 /* Get */);
        }
        if (isHTML) {
          write2`${callRuntime(method, value)}`;
          if (nodeBinding) {
            markNode(placeholder, nodeBinding, markerSerializeReason);
          }
        } else {
          addStatement(
            "render",
            getSection(placeholder),
            valueExtra.referencedBindings,
            import_compiler53.types.expressionStatement(
              method === "data" ? callRuntime(
                "data",
                import_compiler53.types.memberExpression(
                  scopeIdentifier,
                  getScopeAccessorLiteral(nodeBinding),
                  true
                ),
                value
              ) : callRuntime(
                "html",
                scopeIdentifier,
                value,
                getScopeAccessorLiteral(nodeBinding)
              )
            )
          );
        }
      }
      if (!extra[kSharedText]) {
        enterShallow(placeholder);
      }
      placeholder.remove();
    }
  }
};
function analyzeSiblingText(placeholder) {
  const placeholderExtra = placeholder.node.extra;
  let prev = placeholder.getPrevSibling();
  while (prev.node) {
    const contentType = getNodeContentType(
      prev,
      "endType"
    );
    if (contentType === null) {
      prev = prev.getPrevSibling();
    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {
      return placeholderExtra[kSiblingText] = 1 /* Before */;
    } else {
      break;
    }
  }
  if (!prev.node && import_compiler53.types.isProgram(placeholder.parentPath)) {
    return placeholderExtra[kSiblingText] = 1 /* Before */;
  }
  let next = placeholder.getNextSibling();
  while (next.node) {
    const contentType = getNodeContentType(
      next,
      "startType"
    );
    if (contentType === null) {
      next = next.getNextSibling();
    } else if (contentType === 4 /* Text */ || contentType === 1 /* Dynamic */ || contentType === 2 /* Placeholder */) {
      return placeholderExtra[kSiblingText] = 2 /* After */;
    } else {
      break;
    }
  }
  if (!next.node && import_compiler53.types.isProgram(placeholder.parentPath)) {
    return placeholderExtra[kSiblingText] = 2 /* After */;
  }
  return placeholderExtra[kSiblingText] = 0 /* None */;
}
function isVoid2(value) {
  return value == null || value === false;
}
function isStaticText(node) {
  switch (node?.type) {
    case "MarkoText":
      return true;
    case "MarkoPlaceholder": {
      if (node.escape) {
        const { confident, computed } = evaluate(node.value);
        return confident && !isVoid2(computed);
      } else {
        return false;
      }
    }
  }
}
function getPrev(path5) {
  let prev = path5.getPrevSibling();
  while (prev.node && (prev.isMarkoComment() || prev.isMarkoPlaceholder() && isEmptyPlaceholder(prev.node))) {
    prev = prev.getPrevSibling();
  }
  return prev.node;
}
function isEmptyPlaceholder(placeholder) {
  const { confident, computed } = evaluate(placeholder.value);
  return confident && isVoid2(computed);
}

// src/translator/visitors/referenced-identifier.ts
var import_compiler54 = require("@marko/compiler");
var abortIdsByExpressionForSection = /* @__PURE__ */ new WeakMap();
var referenced_identifier_default = {
  migrate(identifier) {
    const { name: name2 } = identifier.node;
    if (identifier.scope.hasBinding(name2)) return;
    switch (name2) {
      case "out":
        if (import_compiler54.types.isMemberExpression(identifier.parent) && import_compiler54.types.isIdentifier(identifier.parent.property) && identifier.parent.property.name === "global") {
          identifier.parentPath.replaceWith(import_compiler54.types.identifier("$global"));
        } else {
          throw identifier.buildCodeFrameError(
            "Only `out.global` is supported for compatibility."
          );
        }
        break;
    }
  },
  analyze(identifier) {
    const { name: name2 } = identifier.node;
    if (identifier.scope.hasBinding(name2)) return;
    if (name2 === "$global") {
      setReferencesScope(identifier);
    } else if (name2 === "$signal") {
      const section = getOrCreateSection(identifier);
      section.hasAbortSignal = true;
      setReferencesScope(identifier);
    }
  },
  translate(identifier) {
    const { name: name2 } = identifier.node;
    if (identifier.scope.hasBinding(name2)) return;
    switch (name2) {
      case "$global":
        if (isOutputHTML()) {
          identifier.replaceWith(
            import_compiler54.types.callExpression(importRuntime("$global"), [])
          );
        } else {
          identifier.replaceWith(
            import_compiler54.types.memberExpression(scopeIdentifier, import_compiler54.types.identifier("$global"))
          );
        }
        break;
      case "$signal":
        if (isOutputHTML()) {
          identifier.replaceWith(
            import_compiler54.types.callExpression(
              import_compiler54.types.arrowFunctionExpression(
                [],
                import_compiler54.types.blockStatement([
                  import_compiler54.types.throwStatement(
                    import_compiler54.types.newExpression(import_compiler54.types.identifier("Error"), [
                      import_compiler54.types.stringLiteral("Cannot use $signal in a server render.")
                    ])
                  )
                ])
              ),
              []
            )
          );
        } else {
          const section = getSection(identifier);
          const exprRoot = getExprRoot(identifier);
          let abortIdsByExpression = abortIdsByExpressionForSection.get(section);
          let exprId;
          if (abortIdsByExpression) {
            exprId = abortIdsByExpression.get(exprRoot);
          } else {
            abortIdsByExpression = /* @__PURE__ */ new Map();
            abortIdsByExpressionForSection.set(section, abortIdsByExpression);
          }
          if (!exprId) {
            exprId = abortIdsByExpression.size;
            abortIdsByExpression.set(exprRoot, exprId);
            addStatement(
              "render",
              section,
              exprRoot.node.extra?.referencedBindings,
              import_compiler54.types.expressionStatement(
                import_compiler54.types.callExpression(importRuntime("resetAbortSignal"), [
                  scopeIdentifier,
                  import_compiler54.types.numericLiteral(exprId)
                ])
              ),
              false
            );
          }
          identifier.replaceWith(
            import_compiler54.types.callExpression(importRuntime("getAbortSignal"), [
              scopeIdentifier,
              import_compiler54.types.numericLiteral(exprId)
            ])
          );
        }
    }
  }
};

// src/translator/visitors/scriptlet.ts
var scriptlet_default = {
  analyze(scriptlet) {
    if (!scriptlet.node.static) {
      throw scriptlet.buildCodeFrameError(
        "Scriptlets are not supported when using the tags api."
      );
    }
    mergeReferences(
      getOrCreateSection(scriptlet),
      scriptlet.node,
      scriptlet.node.body
    );
  },
  translate: {
    exit(scriptlet) {
      const { node } = scriptlet;
      const isHTML = isOutputHTML();
      if (node.target && node.target !== (isHTML ? "server" : "client")) {
        scriptlet.remove();
        return;
      }
      if (isHTML) {
      } else {
        traverseReplace(node, "body", replaceRegisteredFunctionNode2);
        scriptlet.replaceWithMultiple(node.body);
      }
    }
  }
};

// src/translator/visitors/tag/index.ts
var import_compiler58 = require("@marko/compiler");
var import_babel_utils49 = require("@marko/compiler/babel-utils");

// src/translator/visitors/tag/attribute-tag.ts
var import_compiler55 = require("@marko/compiler");
var import_babel_utils46 = require("@marko/compiler/babel-utils");
var attribute_tag_default = {
  analyze: {
    enter(tag) {
      (0, import_babel_utils46.assertNoVar)(tag);
      (0, import_babel_utils46.assertNoArgs)(tag);
      const body = tag.get("body");
      startSection(body);
      trackParamsReferences(body, 3 /* param */);
      if (!(0, import_babel_utils46.findParentTag)(tag)) {
        throw tag.get("name").buildCodeFrameError("@tags must be nested within another tag.");
      }
    }
  },
  translate: {
    enter(tag) {
      if (isOutputHTML()) {
        flushBefore(tag);
      }
    },
    exit(tag) {
      if (isOutputHTML()) {
        flushInto(tag);
        writeHTMLResumeStatements(tag.get("body"));
      }
    }
  }
};

// src/translator/visitors/tag/custom-tag.ts
var import_compiler56 = require("@marko/compiler");
var import_babel_utils47 = require("@marko/compiler/babel-utils");
var import_path4 = __toESM(require("path"));
var kChildScopeBinding = Symbol("custom tag child scope");
var kChildOffsetScopeBinding = Symbol("custom tag scope offset");
var kChildInputSerializePropIds = Symbol(
  "custom tag child serialize reasons"
);
var custom_tag_default = {
  analyze: {
    enter(tag) {
      (0, import_babel_utils47.assertAttributesOrSingleArg)(tag);
      analyzeAttributeTags(tag);
      const templateFile = (0, import_babel_utils47.getTagTemplate)(tag);
      if (!templateFile) {
        const tagName = getTagName(tag);
        if (tagName && tag.scope.hasBinding(tagName)) {
          throw tag.get("name").buildCodeFrameError(
            `Local variables must be in a dynamic tag unless they are PascalCase. Use \`<\${${tagName}}/>\` or rename to \`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\`.`
          );
        }
        throw tag.get("name").buildCodeFrameError("Unable to find entry point for custom tag.");
      }
      const section = getOrCreateSection(tag);
      const tagBody = tag.get("body");
      const tagExtra = tag.node.extra ??= {};
      const childScopeBinding = tagExtra[kChildScopeBinding] = createBinding(
        "#childScope",
        0 /* dom */,
        section
      );
      const attrExprs = /* @__PURE__ */ new Set([tagExtra]);
      startSection(tagBody);
      trackParamsReferences(tagBody, 3 /* param */);
      const childFile = (0, import_babel_utils47.loadFileForTag)(tag);
      if (!childFile) {
        throw tag.get("name").buildCodeFrameError("Unable to resolve file for tag.");
      }
      const varBinding = trackVarReferences(tag, 5 /* derived */);
      if (varBinding) {
        varBinding.scopeOffset = tagExtra[kChildOffsetScopeBinding] = createBinding("#scopeOffset", 0 /* dom */, section);
      }
      if (childFile.opts.filename === tag.hub.file.opts.filename) {
        mergeReferences(section, tag.node, getAllTagReferenceNodes(tag.node));
        if (varBinding) {
          const varSerializeReason = (0, import_babel_utils47.getProgram)().node.extra.returnValueExpr;
          setBindingValueExpr(varBinding, varSerializeReason);
          addBindingSerializeReasonExpr(
            section,
            childScopeBinding,
            varSerializeReason
          );
        }
      } else {
        const childProgram = childFile.ast.program;
        const childExtra = childProgram.extra;
        const childInputBinding = childProgram.params[0].extra?.binding;
        const inputExpr = {};
        analyzeAttrs(
          tagExtra,
          section,
          tag,
          childExtra?.domExports.input,
          attrExprs,
          inputExpr
        );
        if (varBinding) {
          const varSerializeReason = mapChildReasonToLocalReason(
            childExtra.returnSerializeReason,
            childInputBinding,
            inputExpr
          );
          setBindingValueExpr(varBinding, varSerializeReason);
          addBindingSerializeReasonExpr(
            section,
            childScopeBinding,
            varSerializeReason
          );
        }
        if (childExtra.inputSerializeReasons) {
          const childInputSerializePropIds = tagExtra[kChildInputSerializePropIds] = [];
          for (const reason of childExtra.inputSerializeReasons) {
            const propId = Symbol();
            childInputSerializePropIds.push(propId);
            addBindingSerializeReasonExpr(
              section,
              childScopeBinding,
              mapChildReasonToLocalReason(reason, childInputBinding, inputExpr),
              propId
            );
          }
        }
        (0, import_babel_utils47.getProgram)().node.extra.hasInteractiveChild = childExtra?.isInteractive || childExtra?.hasInteractiveChild || false;
      }
      addBindingSerializeReasonExpr(
        section,
        childScopeBinding,
        fromIter(attrExprs)
      );
    }
  },
  translate: {
    enter(tag) {
      visit(tag);
      if (isOutputHTML()) {
        flushBefore(tag);
      }
    },
    exit(tag) {
      if (isOutputHTML()) {
        translateHTML(tag);
      } else {
        translateDOM(tag);
      }
    }
  }
};
function translateHTML(tag) {
  const tagBody = tag.get("body");
  const { node } = tag;
  const tagExtra = node.extra;
  let tagIdentifier;
  flushInto(tag);
  writeHTMLResumeStatements(tagBody);
  if (import_compiler56.types.isStringLiteral(node.name)) {
    const relativePath = getTagRelativePath(tag);
    tagIdentifier = isCircularRequest(tag.hub.file, relativePath) ? import_compiler56.types.identifier(getTemplateContentName()) : (0, import_babel_utils47.importDefault)(tag.hub.file, relativePath, getTagName(tag));
  } else {
    tagIdentifier = node.name;
  }
  const tagVar = node.var;
  const section = getSection(tag);
  const childProgram = (0, import_babel_utils47.loadFileForTag)(tag).ast.program;
  const childExtra = childProgram.extra;
  const inputExport = childExtra.domExports?.input;
  const { properties, statements } = inputExport ? translateAttrs(tag, inputExport.props) : {
    properties: [],
    statements: []
  };
  const childScopeBinding = tagExtra[kChildScopeBinding];
  const childScopeSerializeReason = getBindingSerializeReason(
    section,
    childScopeBinding
  );
  const childSerializeReasonIds = tagExtra[kChildInputSerializePropIds];
  let childSerializeReasonExpr;
  if (childSerializeReasonIds) {
    if (childSerializeReasonIds.length === 1) {
      const reason = getBindingSerializeReason(
        section,
        childScopeBinding,
        childSerializeReasonIds[0]
      );
      childSerializeReasonExpr = !reason ? void 0 : reason == true || reason.state ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason, true);
    } else {
      const props = [];
      let hasDynamicReasons = false;
      let hasSkippedReasons = false;
      for (let i = 0; i < childSerializeReasonIds.length; i++) {
        const reason = getBindingSerializeReason(
          section,
          childScopeBinding,
          childSerializeReasonIds[i]
        );
        if (reason) {
          hasDynamicReasons ||= reason !== true && !reason.state;
          const childReason = childExtra.inputSerializeReasons[i];
          props.push(
            import_compiler56.types.objectProperty(
              withLeadingComment(
                import_compiler56.types.numericLiteral(i),
                mapToString(childReason, ", ", getInputDebugName)
              ),
              reason === true || reason.state ? import_compiler56.types.numericLiteral(1) : getSerializeGuard(reason, false)
            )
          );
        } else {
          hasSkippedReasons = true;
        }
      }
      if (props.length) {
        childSerializeReasonExpr = hasDynamicReasons || hasSkippedReasons ? import_compiler56.types.objectExpression(props) : import_compiler56.types.numericLiteral(1);
      }
    }
  }
  if (childScopeSerializeReason) {
    const peekScopeId = generateUidIdentifier(childScopeBinding?.name);
    tag.insertBefore(
      import_compiler56.types.variableDeclaration("const", [
        import_compiler56.types.variableDeclarator(peekScopeId, callRuntime("peekNextScopeId"))
      ])
    );
    setBindingSerializedValue(
      section,
      childScopeBinding,
      callRuntime("writeExistingScope", peekScopeId)
    );
    if (tagVar) {
      statements.push(
        import_compiler56.types.expressionStatement(
          callRuntime(
            "setTagVar",
            getScopeIdIdentifier(section),
            getScopeAccessorLiteral(tag.node.extra[kChildOffsetScopeBinding]),
            peekScopeId,
            import_compiler56.types.stringLiteral(
              getResumeRegisterId(
                section,
                node.var.extra?.binding,
                // TODO: node.var is not always an identifier.
                "var"
              )
            )
          )
        )
      );
    }
  }
  if (node.extra.tagNameNullable) {
    const contentProp = getTranslatedBodyContentProperty(properties);
    let contentId = void 0;
    if (contentProp) {
      const contentExpression = contentProp.value;
      contentProp.value = contentId = generateUidIdentifier("content");
      const [contentPath] = tag.insertBefore(
        import_compiler56.types.variableDeclaration("const", [
          import_compiler56.types.variableDeclarator(
            contentId,
            // TODO: only register if needed (child template analysis)
            contentExpression
          )
        ])
      );
      contentPath.skip();
    }
    let renderTagExpr = callExpression(
      tagIdentifier,
      propsToExpression(properties),
      childSerializeReasonExpr
    );
    if (tagVar) {
      translateVar(tag, import_compiler56.types.unaryExpression("void", import_compiler56.types.numericLiteral(0)), "let");
      renderTagExpr = import_compiler56.types.assignmentExpression("=", tagVar, renderTagExpr);
    }
    statements.push(
      import_compiler56.types.ifStatement(
        tagIdentifier,
        import_compiler56.types.expressionStatement(renderTagExpr),
        contentId && callStatement(contentId)
      )
    );
  } else if (tagVar) {
    translateVar(
      tag,
      callExpression(
        tagIdentifier,
        propsToExpression(properties),
        childSerializeReasonExpr
      ),
      "let"
    );
  } else {
    statements.push(
      callStatement(
        tagIdentifier,
        propsToExpression(properties),
        childSerializeReasonExpr
      )
    );
  }
  for (const replacement of tag.replaceWithMultiple(statements)) {
    replacement.skip();
  }
}
function translateDOM(tag) {
  const tagSection = getSection(tag);
  const { node } = tag;
  const extra = node.extra;
  const childScopeBinding = extra[kChildScopeBinding];
  const write2 = writeTo(tag);
  const { file } = tag.hub;
  const tagName = import_compiler56.types.isIdentifier(node.name) ? node.name.name : import_compiler56.types.isStringLiteral(node.name) ? node.name.value : "tag";
  const relativePath = getTagRelativePath(tag);
  const childFile = (0, import_babel_utils47.loadFileForTag)(tag);
  const childExports = childFile.ast.program.extra.domExports;
  const tagIdentifier = importOrSelfReferenceName(
    file,
    relativePath,
    childExports.setup,
    tagName
  );
  const inputExport = childExports.input;
  if (node.var) {
    const source = initValue(
      // TODO: support destructuring
      node.var.extra.binding
    );
    source.register = true;
    source.buildAssignment = (valueSection, value) => {
      return import_compiler56.types.callExpression(importRuntime("tagVarSignalChange"), [
        createScopeReadExpression(valueSection, childScopeBinding),
        value
      ]);
    };
    addStatement(
      "render",
      tagSection,
      void 0,
      import_compiler56.types.expressionStatement(
        callRuntime(
          "setTagVar",
          scopeIdentifier,
          getScopeAccessorLiteral(childScopeBinding),
          source.identifier
        )
      )
    );
  }
  addStatement(
    "render",
    tagSection,
    void 0,
    import_compiler56.types.expressionStatement(
      import_compiler56.types.callExpression(tagIdentifier, [
        createScopeReadExpression(tagSection, childScopeBinding)
      ])
    )
  );
  if (inputExport) {
    writeAttrsToExports(tag, inputExport, `${getTagName(tag) || "tag"}_input`, {
      circular: childFile.opts.filename === file.opts.filename,
      tagSection,
      relativePath,
      childScopeBinding,
      attrTagCallsByTag: void 0
    });
  }
  write2`${(0, import_babel_utils47.importNamed)(file, relativePath, childExports.template, `${tagName}_template`)}`;
  injectWalks(
    tag,
    (0, import_babel_utils47.importNamed)(file, relativePath, childExports.walks, `${tagName}_walks`)
  );
  tag.remove();
}
function getTagRelativePath(tag) {
  const {
    node,
    hub: { file }
  } = tag;
  let relativePath;
  if (import_compiler56.types.isStringLiteral(node.name)) {
    const template = (0, import_babel_utils47.getTagTemplate)(tag);
    relativePath = template && (0, import_babel_utils47.resolveRelativePath)(file, template);
  } else if (node.extra?.tagNameImported) {
    relativePath = node.extra.tagNameImported;
  }
  if (!relativePath) {
    const tagName = getTagName(tag);
    if (tagName && tag.scope.hasBinding(tagName)) {
      throw tag.get("name").buildCodeFrameError(
        `Local variables must be in a dynamic tag unless they are PascalCase. Use \`<\${${tagName}}/>\` or rename to \`${tagName.charAt(0).toUpperCase() + tagName.slice(1)}\`.`
      );
    }
    throw tag.get("name").buildCodeFrameError("Unable to find entry point for custom tag.");
  }
  return relativePath;
}
function analyzeAttrs(rootTagExtra, section, tag, templateExport, rootAttrExprs, inputExpr) {
  if (!templateExport) {
    dropReferences(getAllTagReferenceNodes(tag.node));
    return;
  }
  if (!templateExport.props || tag.node.arguments?.length) {
    inputExpr.value = mergeReferences(
      section,
      tag.node,
      getAllTagReferenceNodes(tag.node)
    );
    return;
  }
  const known = inputExpr.known = {};
  const attrTagLookup = analyzeAttributeTags(tag);
  const seen = /* @__PURE__ */ new Set();
  if (attrTagLookup) {
    const nodeReferencesByGroup = /* @__PURE__ */ new Map();
    const analyzeDynamicChildGroup = (group, child) => {
      const referenceNodes = getAllTagReferenceNodes(child.node);
      const groupReferences = nodeReferencesByGroup.get(group);
      if (groupReferences) {
        groupReferences.referenceNodes = groupReferences.referenceNodes.concat(referenceNodes);
      } else {
        nodeReferencesByGroup.set(group, {
          firstTag: child,
          referenceNodes
        });
      }
    };
    for (const attrTagName in attrTagLookup) {
      seen.add(attrTagLookup[attrTagName].name);
    }
    const attrTags2 = tag.node.body.attributeTags ? tag.get("body").get("body") : tag.get("attributeTags");
    for (const child of attrTags2) {
      if (child.isMarkoTag()) {
        if ((0, import_babel_utils47.isAttributeTag)(child)) {
          const attrTagMeta = attrTagLookup[getTagName(child)];
          const childAttrExports = templateExport.props[attrTagMeta.name];
          if (childAttrExports) {
            if (childAttrExports.props && !attrTagMeta.dynamic) {
              analyzeAttrs(
                rootTagExtra,
                section,
                child,
                childAttrExports,
                rootAttrExprs,
                known[attrTagMeta.name] = {}
              );
            } else {
              analyzeDynamicChildGroup(attrTagMeta.group, child);
            }
          } else {
            dropReferences(getAllTagReferenceNodes(child.node));
          }
        } else {
          const group = child.node.extra.attributeTagGroup;
          let childUsesGroupProp = false;
          for (const name2 of group) {
            if (templateExport.props[attrTagLookup[name2].name]) {
              childUsesGroupProp = true;
              break;
            }
          }
          if (childUsesGroupProp) {
            analyzeDynamicChildGroup(group, child);
          } else {
            dropReferences(getAllTagReferenceNodes(child.node));
          }
        }
      }
    }
    for (const [
      group,
      {
        firstTag: { node },
        referenceNodes
      }
    ] of nodeReferencesByGroup) {
      const groupExtra = mergeReferences(section, node, referenceNodes);
      const groupKnownValue = { value: groupExtra };
      rootAttrExprs.add(groupExtra);
      for (const name2 of group) {
        known[attrTagLookup[name2].name] = groupKnownValue;
      }
    }
  }
  if (!seen.has("content")) {
    const bodySection = getSectionForBody(tag.get("body"));
    if (bodySection) {
      seen.add("content");
      known.content = { value: void 0 };
      bodySection.downstreamBinding = (templateExport.props.content || templateExport.props).binding;
    }
  }
  const { attributes } = tag.node;
  let spreadReferenceNodes;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    if (import_compiler56.types.isMarkoAttribute(attr2)) {
      if (seen.has(attr2.name) || !templateExport.props[attr2.name]) {
        dropReferences(attr2.value);
        continue;
      }
      seen.add(attr2.name);
    }
    if (spreadReferenceNodes) {
      spreadReferenceNodes.push(attr2.value);
    } else if (import_compiler56.types.isMarkoSpreadAttribute(attr2)) {
      spreadReferenceNodes = [attr2.value];
    } else {
      const attrValueExtra = attr2.value.extra ??= {};
      known[attr2.name] = { value: attrValueExtra };
      rootAttrExprs.add(attrValueExtra);
    }
  }
  if (spreadReferenceNodes) {
    inputExpr.value = mergeReferences(section, tag.node, spreadReferenceNodes);
  }
}
function writeAttrsToExports(tag, templateExport, importAlias, info) {
  if (tag.node.arguments?.length) {
    const [arg] = tag.node.arguments;
    const tagInputIdentifier = importOrSelfReferenceName(
      tag.hub.file,
      info.relativePath,
      templateExport.id,
      importAlias
    );
    addStatement(
      "render",
      info.tagSection,
      // technically this should be `arg.extra?.referencedBindings`
      // but we should probably ensure all other references are dropped in this case before we do that.
      tag.node.extra?.referencedBindings,
      import_compiler56.types.expressionStatement(
        import_compiler56.types.callExpression(tagInputIdentifier, [
          createScopeReadExpression(info.tagSection, info.childScopeBinding),
          import_compiler56.types.isSpreadElement(arg) ? import_compiler56.types.memberExpression(arg.argument, import_compiler56.types.numericLiteral(0), true) : arg
        ])
      )
    );
    return;
  }
  if (!templateExport.props || info.circular) {
    const referencedBindings = tag.node.extra?.referencedBindings;
    const tagInputIdentifier = importOrSelfReferenceName(
      tag.hub.file,
      info.relativePath,
      templateExport.id,
      importAlias
    );
    const translatedAttrs = translateAttrs(tag);
    if (translatedAttrs.statements.length) {
      addStatement(
        "render",
        info.tagSection,
        referencedBindings,
        translatedAttrs.statements
      );
    }
    let translatedProps = propsToExpression(translatedAttrs.properties);
    if ((0, import_babel_utils47.isAttributeTag)(tag)) {
      const attrTagName = getTagName(tag);
      const parentTag = tag.parentPath;
      const repeated = analyzeAttributeTags(parentTag)?.[attrTagName]?.repeated;
      if (repeated) {
        let attrTagCallsForTag = (info.attrTagCallsByTag ||= /* @__PURE__ */ new Map()).get(
          parentTag
        );
        if (!attrTagCallsForTag) {
          info.attrTagCallsByTag.set(
            parentTag,
            attrTagCallsForTag = /* @__PURE__ */ new Map()
          );
        }
        const attrTagCall = attrTagCallsForTag.get(attrTagName);
        if (attrTagCall) {
          attrTagCall.expression = callRuntime(
            "attrTags",
            attrTagCall.expression,
            translatedProps
          );
          return;
        } else {
          attrTagCallsForTag.set(
            attrTagName,
            translatedProps = import_compiler56.types.parenthesizedExpression(
              callRuntime("attrTag", translatedProps)
            )
          );
        }
      } else {
        translatedProps = callRuntime("attrTag", translatedProps);
      }
    }
    addStatement(
      "render",
      info.tagSection,
      referencedBindings,
      import_compiler56.types.expressionStatement(
        import_compiler56.types.callExpression(tagInputIdentifier, [
          createScopeReadExpression(info.tagSection, info.childScopeBinding),
          translatedProps
        ])
      )
    );
    return;
  }
  const seen = /* @__PURE__ */ new Set();
  const attrTagLookup = analyzeAttributeTags(tag);
  if (attrTagLookup) {
    const attrTags2 = tag.get("attributeTags");
    const statementsByGroup = /* @__PURE__ */ new Map();
    const translateDynamicAttrTagChildInGroup = (group, index) => {
      const child = attrTags2[index];
      let statements = statementsByGroup.get(group)?.statements;
      if (!statements) {
        statements = [];
        statementsByGroup.set(group, {
          referencedBindings: child.node.extra?.referencedBindings,
          statements
        });
      }
      return addDynamicAttrTagStatements(
        attrTags2,
        index,
        attrTagLookup,
        statements,
        templateExport.props
      );
    };
    for (const attrTagName in attrTagLookup) {
      seen.add(attrTagLookup[attrTagName].name);
    }
    for (let i = 0; i < attrTags2.length; i++) {
      const child = attrTags2[i];
      if (child.isMarkoTag()) {
        if ((0, import_babel_utils47.isAttributeTag)(child)) {
          const attrTagMeta = attrTagLookup[getTagName(child)];
          const childAttrExport = templateExport.props[attrTagMeta.name];
          if (childAttrExport) {
            if (attrTagMeta.dynamic) {
              i = translateDynamicAttrTagChildInGroup(attrTagMeta.group, i);
            } else {
              writeAttrsToExports(
                child,
                childAttrExport,
                `${importAlias}_${attrTagMeta.name}`,
                info
              );
            }
          }
        } else if (child.node.extra?.attributeTagGroup) {
          i = translateDynamicAttrTagChildInGroup(
            child.node.extra.attributeTagGroup,
            i
          );
        }
      }
    }
    for (const [
      group,
      { referencedBindings, statements }
    ] of statementsByGroup) {
      const decls = [];
      for (const name2 of group) {
        const attrTagMeta = attrTagLookup[name2];
        const childAttrExports = templateExport.props[attrTagMeta.name];
        if (!childAttrExports) continue;
        const attrExportIdentifier = importOrSelfReferenceName(
          tag.hub.file,
          info.relativePath,
          childAttrExports.id,
          `${importAlias}_${attrTagMeta.name}`
        );
        decls.push(import_compiler56.types.variableDeclarator(getAttrTagIdentifier(attrTagMeta)));
        addStatement("render", info.tagSection, referencedBindings, [
          import_compiler56.types.variableDeclaration("let", decls),
          ...statements
        ]);
        addStatement(
          "render",
          info.tagSection,
          referencedBindings,
          import_compiler56.types.expressionStatement(
            import_compiler56.types.callExpression(attrExportIdentifier, [
              createScopeReadExpression(
                info.tagSection,
                info.childScopeBinding
              ),
              getAttrTagIdentifier(attrTagMeta)
            ])
          )
        );
      }
    }
  }
  const bodySection = tag.node.body.extra?.section;
  if (bodySection && !seen.has("content")) {
    seen.add("content");
    if (templateExport.props.content) {
      const contentExportIdentifier = (0, import_babel_utils47.importNamed)(
        tag.hub.file,
        info.relativePath,
        templateExport.props.content.id,
        `${importAlias}_content`
      );
      addStatement(
        "render",
        info.tagSection,
        void 0,
        // TODO: pretty sure content needs to have the reference group of it's param defaults.
        import_compiler56.types.expressionStatement(
          import_compiler56.types.callExpression(contentExportIdentifier, [
            createScopeReadExpression(info.tagSection, info.childScopeBinding),
            import_compiler56.types.callExpression(import_compiler56.types.identifier(bodySection.name), [scopeIdentifier])
          ])
        )
      );
    }
  }
  const { attributes } = tag.node;
  const staticAttrs = [];
  let spreadProps;
  for (let i = attributes.length; i--; ) {
    const attr2 = attributes[i];
    if (import_compiler56.types.isMarkoAttribute(attr2)) {
      const childAttrExports = templateExport.props[attr2.name];
      if (!childAttrExports || seen.has(attr2.name)) continue;
      seen.add(attr2.name);
      if (spreadProps) {
        spreadProps.push(toObjectProperty(attr2.name, attr2.value));
        continue;
      }
      staticAttrs.push(attr2);
    } else if (spreadProps) {
      spreadProps.push(import_compiler56.types.spreadElement(attr2.value));
    } else {
      spreadProps = [import_compiler56.types.spreadElement(attr2.value)];
    }
  }
  for (const attr2 of staticAttrs.reverse()) {
    const childAttrExports = templateExport.props[attr2.name];
    const attrExportIdentifier = importOrSelfReferenceName(
      tag.hub.file,
      info.relativePath,
      childAttrExports.id,
      `${importAlias}_${attr2.name}`
    );
    addStatement(
      "render",
      info.tagSection,
      attr2.value.extra?.referencedBindings,
      import_compiler56.types.expressionStatement(
        import_compiler56.types.callExpression(attrExportIdentifier, [
          createScopeReadExpression(info.tagSection, info.childScopeBinding),
          attr2.value
        ])
      )
    );
  }
  const missing = new Set(Object.keys(templateExport.props));
  for (const name2 of seen) missing.delete(name2);
  if (missing.size) {
    const referencedBindings = tag.node.extra?.referencedBindings;
    let getMissingPropValue = buildUndefined2;
    if (spreadProps) {
      const spreadId = generateUidIdentifier(`${importAlias}_spread`);
      spreadProps.reverse();
      getMissingPropValue = (name2) => toMemberExpression(spreadId, name2);
      addStatement("render", info.tagSection, referencedBindings, [
        import_compiler56.types.variableDeclaration("const", [
          import_compiler56.types.variableDeclarator(spreadId, propsToExpression(spreadProps))
        ])
      ]);
    }
    for (const name2 of missing) {
      const childAttrExports = templateExport.props[name2];
      const attrExportIdentifier = importOrSelfReferenceName(
        tag.hub.file,
        info.relativePath,
        childAttrExports.id,
        `${importAlias}_${name2}`
      );
      addStatement(
        "render",
        info.tagSection,
        referencedBindings,
        import_compiler56.types.expressionStatement(
          import_compiler56.types.callExpression(attrExportIdentifier, [
            createScopeReadExpression(info.tagSection, info.childScopeBinding),
            getMissingPropValue(name2)
          ])
        )
      );
    }
  }
}
function importOrSelfReferenceName(file, request, name2, nameHint) {
  if (isCircularRequest(file, request)) {
    return import_compiler56.types.identifier(name2);
  }
  return (0, import_babel_utils47.importNamed)(file, request, name2, nameHint);
}
function mapChildReasonToLocalReason(childReason, childInputBinding, inputExpr) {
  if (childReason) {
    if (childReason === true) return true;
    return filterMap(
      childReason,
      (inputBinding) => resolveChildInputExpr(childInputBinding, inputBinding, inputExpr)
    );
  }
}
function resolveChildInputExpr(inputBinding, propBinding, expr) {
  if (expr) {
    let curExpr = expr;
    if (inputBinding !== propBinding) {
      const props = [propBinding.property];
      let curBinding = propBinding;
      while (inputBinding !== (curBinding = curBinding.upstreamAlias)) {
        props.push(curBinding.property);
      }
      for (let i = props.length; i--; ) {
        const nestedExpr = curExpr.known?.[props[i]];
        if (nestedExpr) {
          curExpr = nestedExpr;
        } else {
          break;
        }
      }
    }
    return curExpr.value;
  }
}
function isCircularRequest(file, request) {
  const { filename } = file.opts;
  return request === filename || request[0] === "." && import_path4.default.resolve(filename, "..", request) === filename;
}
function callStatement(id, ...args) {
  return import_compiler56.types.expressionStatement(callExpression(id, ...args));
}
function callExpression(id, ...args) {
  return import_compiler56.types.callExpression(id, args.filter(Boolean));
}
function buildUndefined2() {
  return import_compiler56.types.unaryExpression("void", import_compiler56.types.numericLiteral(0));
}

// src/translator/visitors/tag/dynamic-tag.ts
var import_compiler57 = require("@marko/compiler");
var import_babel_utils48 = require("@marko/compiler/babel-utils");
var kDOMBinding3 = Symbol("dynamic tag dom binding");
var kChildOffsetScopeBinding2 = Symbol("custom tag scope offset");
var dynamic_tag_default = {
  analyze: {
    enter(tag) {
      (0, import_babel_utils48.assertAttributesOrArgs)(tag);
      analyzeAttributeTags(tag);
      const tagSection = getOrCreateSection(tag);
      const tagExtra = mergeReferences(tagSection, tag.node, [
        tag.node.name,
        ...getAllTagReferenceNodes(tag.node)
      ]);
      const tagBody = tag.get("body");
      const isClassAPI = tagExtra.featureType === "class";
      const hasVar = !!tag.node.var;
      const nodeBinding = tagExtra[kDOMBinding3] = createBinding(
        "#text",
        0 /* dom */,
        tagSection
      );
      if (hasVar) {
        trackVarReferences(tag, 5 /* derived */);
        tag.node.var.extra.binding.scopeOffset = tagExtra[kChildOffsetScopeBinding2] = createBinding("#scopeOffset", 0 /* dom */, tagSection);
      }
      startSection(tagBody);
      trackParamsReferences(tagBody, 3 /* param */);
      addBindingSerializeReasonExpr(
        tagSection,
        nodeBinding,
        isClassAPI || hasVar || tagExtra
      );
    }
  },
  translate: {
    enter(tag) {
      visit(
        tag,
        tag.node.var ? 49 /* DynamicTagWithVar */ : 37 /* Replace */
      );
      enterShallow(tag);
      if (isOutputHTML()) {
        flushBefore(tag);
      }
    },
    exit(tag) {
      const { node } = tag;
      const tagExtra = node.extra;
      const nodeBinding = tagExtra[kDOMBinding3];
      const tagSection = getSection(tag);
      const isClassAPI = tagExtra.featureType === "class";
      let tagExpression = node.name;
      if (import_compiler57.types.isStringLiteral(tagExpression)) {
        tagExpression = (0, import_babel_utils48.importDefault)(
          tag.hub.file,
          getTagRelativePath(tag),
          tagExpression.value
        );
      }
      if (isClassAPI) {
        if (isOutputHTML()) {
          (0, import_babel_utils48.getProgram)().node.body.push(
            import_compiler57.types.markoScriptlet(
              [
                import_compiler57.types.expressionStatement(
                  import_compiler57.types.callExpression(
                    (0, import_babel_utils48.importNamed)(tag.hub.file, getCompatRuntimeFile(), "s"),
                    [
                      import_compiler57.types.identifier(tagExpression.name),
                      import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id)
                    ]
                  )
                )
              ],
              true
            )
          );
        } else {
          (0, import_babel_utils48.getProgram)().node.body.push(
            import_compiler57.types.expressionStatement(
              callRuntime(
                "register",
                import_compiler57.types.stringLiteral((0, import_babel_utils48.loadFileForTag)(tag).metadata.marko.id),
                import_compiler57.types.identifier(tagExpression.name)
              )
            )
          );
        }
      }
      const { properties, statements } = translateAttrs(
        tag,
        void 0,
        void 0,
        isClassAPI ? "renderBody" : "content"
      );
      const args = [];
      let hasTagArgs = false;
      if (node.arguments) {
        hasTagArgs = true;
        args.push(...node.arguments);
        if (properties.length) {
          args.push(propsToExpression(properties));
        }
      } else {
        const contentProp = getTranslatedBodyContentProperty(properties);
        if (contentProp) {
          properties.splice(properties.indexOf(contentProp), 1);
          args.push(propsToExpression(properties), contentProp.value);
        } else {
          args.push(propsToExpression(properties));
        }
      }
      if (isOutputHTML()) {
        flushInto(tag);
        writeHTMLResumeStatements(tag.get("body"));
        const serializeArg = getSerializeGuard(
          getBindingSerializeReason(tagSection, nodeBinding),
          true
        );
        const dynamicTagExpr = hasTagArgs ? callRuntime(
          "dynamicTag",
          getScopeIdIdentifier(tagSection),
          getScopeAccessorLiteral(nodeBinding),
          tagExpression,
          import_compiler57.types.arrayExpression(args),
          import_compiler57.types.numericLiteral(0),
          import_compiler57.types.numericLiteral(1),
          serializeArg
        ) : callRuntime(
          "dynamicTag",
          getScopeIdIdentifier(tagSection),
          getScopeAccessorLiteral(nodeBinding),
          tagExpression,
          args[0],
          args[1] || (serializeArg ? import_compiler57.types.numericLiteral(0) : void 0),
          serializeArg ? import_compiler57.types.numericLiteral(0) : void 0,
          serializeArg
        );
        if (node.var) {
          const dynamicScopeIdentifier = generateUidIdentifier(
            tag.get("name").toString() + "_scope"
          );
          statements.push(
            import_compiler57.types.variableDeclaration("const", [
              import_compiler57.types.variableDeclarator(
                dynamicScopeIdentifier,
                callRuntime("peekNextScopeId")
              )
            ])
          );
          statements.push(
            import_compiler57.types.variableDeclaration("const", [
              import_compiler57.types.variableDeclarator(node.var, dynamicTagExpr)
            ]),
            import_compiler57.types.expressionStatement(
              callRuntime(
                "setTagVar",
                getScopeIdIdentifier(tagSection),
                getScopeAccessorLiteral(
                  tag.node.extra[kChildOffsetScopeBinding2]
                ),
                dynamicScopeIdentifier,
                import_compiler57.types.stringLiteral(
                  getResumeRegisterId(
                    tagSection,
                    node.var.extra?.binding,
                    // TODO: node.var is not always an identifier.
                    "var"
                  )
                )
              )
            )
          );
        } else {
          statements.push(import_compiler57.types.expressionStatement(dynamicTagExpr));
        }
        for (const replacement of tag.replaceWithMultiple(statements)) {
          replacement.skip();
        }
      } else {
        const section = getSection(tag);
        const bodySection = getSectionForBody(tag.get("body"));
        const signal = getSignal(section, nodeBinding, "dynamicTag");
        let tagVarSignal;
        if (tag.node.var) {
          tagVarSignal = initValue(
            // TODO: support destructuring
            tag.node.var.extra.binding
          );
          tagVarSignal.register = true;
          tagVarSignal.buildAssignment = (valueSection, value) => {
            return import_compiler57.types.callExpression(importRuntime("tagVarSignalChange"), [
              import_compiler57.types.memberExpression(
                getScopeExpression(tagVarSignal.section, valueSection),
                import_compiler57.types.stringLiteral(
                  getAccessorPrefix().ConditionalScope + getScopeAccessor(nodeBinding)
                ),
                true
              ),
              value
            ]);
          };
        }
        signal.build = () => {
          return callRuntime(
            "dynamicTag",
            getScopeAccessorLiteral(nodeBinding),
            bodySection && import_compiler57.types.identifier(bodySection.name),
            tagVarSignal ? import_compiler57.types.arrowFunctionExpression([], tagVarSignal.identifier) : void 0,
            hasTagArgs && import_compiler57.types.numericLiteral(1)
          );
        };
        if (args.length) {
          const argsOrInput = hasTagArgs ? import_compiler57.types.arrayExpression(args) : args[0];
          if (!import_compiler57.types.isObjectExpression(argsOrInput) || argsOrInput.properties.length) {
            signal.extraArgs = [
              import_compiler57.types.arrowFunctionExpression(
                [],
                statements.length ? import_compiler57.types.blockStatement(
                  statements.concat(import_compiler57.types.returnStatement(argsOrInput))
                ) : argsOrInput
              )
            ];
          }
        }
        addValue(section, tagExtra.referencedBindings, signal, tagExpression);
        tag.remove();
      }
    }
  }
};

// src/translator/visitors/tag/index.ts
var TAG_NAME_IDENTIFIER_REG = /^[A-Z][a-zA-Z0-9_$]*$/;
var BINDING_CHANGE_HANDLER = /* @__PURE__ */ new WeakMap();
var tag_default = {
  transform: {
    enter(tag) {
      const { node } = tag;
      const { name: name2, attributes } = tag.node;
      let crawl = false;
      if (import_compiler58.types.isStringLiteral(name2)) {
        const tagName = name2.value;
        if (tag.scope.getBinding(tagName) && TAG_NAME_IDENTIFIER_REG.test(tagName)) {
          node.name = withPreviousLocation(import_compiler58.types.identifier(tagName), name2);
          crawl = true;
        }
      }
      for (let i = 0; i < attributes.length; i++) {
        const attr2 = attributes[i];
        if (import_compiler58.types.isMarkoAttribute(attr2) && attr2.bound) {
          attr2.bound = false;
          attributes.splice(++i, 0, getChangeHandler(tag, attr2));
          crawl = true;
        }
      }
      if (crawl) {
        tag.scope.crawl();
      }
    }
  },
  analyze: {
    enter(tag) {
      const tagDef = (0, import_babel_utils49.getTagDef)(tag);
      const type = analyzeTagNameType(tag);
      const hook = tagDef?.analyzer?.hook;
      if (hook) {
        enter(hook, tag);
        return;
      }
      if (type === 0 /* NativeTag */) {
        native_tag_default.analyze.enter(tag);
        return;
      }
      switch (type) {
        case 1 /* CustomTag */:
          custom_tag_default.analyze.enter(tag);
          break;
        case 3 /* AttributeTag */:
          attribute_tag_default.analyze.enter(tag);
          break;
        case 2 /* DynamicTag */:
          dynamic_tag_default.analyze.enter(tag);
          break;
      }
    },
    exit(tag) {
      const hook = (0, import_babel_utils49.getTagDef)(tag)?.analyzer?.hook;
      if (hook) {
        exit(hook, tag);
        return;
      }
    }
  },
  translate: {
    enter(tag) {
      const tagDef = (0, import_babel_utils49.getTagDef)(tag);
      const extra = tag.node.extra;
      if (tagDef?.translator) {
        if (tagDef.translator.path) {
          tag.hub.file.metadata.marko.watchFiles.push(tagDef.translator.path);
        }
        enter(tagDef.translator.hook, tag);
        return;
      }
      for (const attr2 of tag.get("attributes")) {
        if (attr2.isMarkoAttribute()) {
          if (attr2.node.arguments) {
            throw attr2.buildCodeFrameError(
              `Unsupported arguments on the \`${attr2.node.name}\` attribute.`
            );
          }
          if (attr2.node.modifier) {
            if ((0, import_babel_utils49.isNativeTag)(attr2.parentPath)) {
              attr2.node.name += `:${attr2.node.modifier}`;
            } else {
              throw attr2.buildCodeFrameError(
                `Unsupported modifier \`${attr2.node.modifier}\`.`
              );
            }
          }
        }
      }
      if (extra.tagNameDynamic && extra.tagNameNullable && !tag.get("name").isIdentifier() && isOutputHTML()) {
        const tagNameId = generateUidIdentifier("tagName");
        const [tagNameVarPath] = tag.insertBefore(
          import_compiler58.types.variableDeclaration("const", [
            import_compiler58.types.variableDeclarator(tagNameId, tag.node.name)
          ])
        );
        tagNameVarPath.skip();
        tag.set("name", tagNameId);
      }
      switch (extra.tagNameType) {
        case 0 /* NativeTag */:
          native_tag_default.translate.enter(tag);
          break;
        case 1 /* CustomTag */:
          custom_tag_default.translate.enter(tag);
          break;
        case 2 /* DynamicTag */:
          dynamic_tag_default.translate.enter(tag);
          break;
        case 3 /* AttributeTag */:
          attribute_tag_default.translate.enter(tag);
          break;
      }
    },
    exit(tag) {
      const translator = (0, import_babel_utils49.getTagDef)(tag)?.translator;
      if (translator) {
        exit(translator.hook, tag);
        return;
      }
      switch (tag.node.extra.tagNameType) {
        case 0 /* NativeTag */:
          native_tag_default.translate.exit(tag);
          break;
        case 1 /* CustomTag */:
          custom_tag_default.translate.exit(tag);
          break;
        case 2 /* DynamicTag */:
          dynamic_tag_default.translate.exit(tag);
          break;
        case 3 /* AttributeTag */:
          attribute_tag_default.translate.exit(tag);
          break;
      }
    }
  }
};
function getChangeHandler(tag, attr2) {
  const attrName = attr2.name;
  const changeAttrName = attrName + "Change";
  if (import_compiler58.types.isIdentifier(attr2.value)) {
    const binding = tag.scope.getBinding(attr2.value.name);
    if (!binding)
      return import_compiler58.types.markoAttribute(
        changeAttrName,
        buildChangeHandlerFunction(attr2.value)
      );
    const existingChangedAttr = BINDING_CHANGE_HANDLER.get(binding.identifier);
    if (!existingChangedAttr) {
      const changeHandlerAttr = import_compiler58.types.markoAttribute(
        changeAttrName,
        buildChangeHandlerFunction(attr2.value)
      );
      BINDING_CHANGE_HANDLER.set(binding.identifier, changeHandlerAttr);
      return changeHandlerAttr;
    }
    if (existingChangedAttr.type === "Identifier") {
      return import_compiler58.types.markoAttribute(
        changeAttrName,
        withPreviousLocation(
          import_compiler58.types.identifier(existingChangedAttr.name),
          attr2.value
        )
      );
    }
    const markoRoot = isMarko(binding.path) ? binding.path : getMarkoRoot(binding.path);
    if (!(markoRoot?.isMarkoTag() || markoRoot?.isMarkoTagBody())) {
      throw tag.hub.buildError(attr2.value, "Unable to bind to value.");
    }
    const changeHandlerId = generateUid(changeAttrName);
    const changeHandlerConst = import_compiler58.types.markoTag(
      import_compiler58.types.stringLiteral("const"),
      [import_compiler58.types.markoAttribute("value", existingChangedAttr.value, null, null, true)],
      import_compiler58.types.markoTagBody([]),
      null,
      import_compiler58.types.identifier(changeHandlerId)
    );
    BINDING_CHANGE_HANDLER.set(
      binding.identifier,
      existingChangedAttr.value = import_compiler58.types.identifier(changeHandlerId)
    );
    if (markoRoot.isMarkoTag()) {
      markoRoot.insertAfter(changeHandlerConst);
    } else {
      markoRoot.unshiftContainer("body", changeHandlerConst);
    }
    return import_compiler58.types.markoAttribute(
      changeAttrName,
      withPreviousLocation(import_compiler58.types.identifier(changeHandlerId), attr2.value)
    );
  } else if (import_compiler58.types.isMemberExpression(attr2.value)) {
    const prop = attr2.value.property;
    if (!import_compiler58.types.isPrivateName(attr2.value.property)) {
      return import_compiler58.types.markoAttribute(
        changeAttrName,
        import_compiler58.types.memberExpression(
          import_compiler58.types.cloneNode(attr2.value.object),
          prop.type === "Identifier" ? withPreviousLocation(import_compiler58.types.identifier(prop.name + "Change"), prop) : import_compiler58.types.binaryExpression(
            "+",
            import_compiler58.types.cloneNode(prop),
            import_compiler58.types.stringLiteral("Change")
          ),
          prop.type !== "Identifier"
        )
      );
    }
  }
  throw tag.hub.buildError(
    attr2.value,
    "Attributes may only be bound to identifiers or member expressions"
  );
}
function buildChangeHandlerFunction(id) {
  const newId = "_new_" + id.name;
  return import_compiler58.types.arrowFunctionExpression(
    [withPreviousLocation(import_compiler58.types.identifier(newId), id)],
    import_compiler58.types.blockStatement([
      import_compiler58.types.expressionStatement(
        import_compiler58.types.assignmentExpression(
          "=",
          withPreviousLocation(import_compiler58.types.identifier(id.name), id),
          withPreviousLocation(import_compiler58.types.identifier(newId), id)
        )
      )
    ])
  );
}

// src/translator/visitors/text.ts
var import_compiler59 = require("@marko/compiler");
var text_default = {
  translate: {
    exit(text) {
      if (isNonHTMLText(text)) return;
      writeTo(text)`${text.node.value}`;
      enterShallow(text);
      text.remove();
    }
  }
};

// src/translator/index.ts
var visitors = extractVisitors({
  Program: program_default,
  Function: function_default,
  ReferencedIdentifier: referenced_identifier_default,
  ImportDeclaration: import_declaration_default,
  MarkoDocumentType: document_type_default,
  MarkoDeclaration: declaration_default,
  MarkoCDATA: cdata_default,
  MarkoText: text_default,
  MarkoTag: tag_default,
  MarkoPlaceholder: placeholder_default,
  MarkoScriptlet: scriptlet_default,
  MarkoComment: comment_default
});
var tagDiscoveryDirs = ["tags"];
var preferAPI = "tags";
var { transform, analyze, translate } = visitors;
var taglibs = [
  [
    __dirname,
    {
      ...core_default,
      migrate: visitors.migrate
    }
  ]
];
function getRuntimeEntryFiles(output, optimize) {
  return [
    `${runtime_info_default.name}${optimize ? "" : "/debug"}/${output === "html" ? "html" : "dom"}`
  ];
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  analyze,
  getRuntimeEntryFiles,
  internalEntryBuilder,
  preferAPI,
  tagDiscoveryDirs,
  taglibs,
  transform,
  translate
});
