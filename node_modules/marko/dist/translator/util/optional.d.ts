export type Many<T> = [T, T, ...T[]];
export type OneMany<T> = T | Many<T>;
export type Opt<T> = undefined | OneMany<T>;
export type Compare<T> = (a: T, b: T) => number;
export declare class Sorted<T> {
    compare: Compare<T>;
    constructor(compare: Compare<T>);
    add<U extends NonNullable<T>>(data: Opt<U>, item: U): OneMany<U>;
    union<U extends NonNullable<T>>(a: Opt<U>, b: Opt<U>): Opt<U>;
    find<U extends NonNullable<T>>(data: Opt<U>, item: U): U | undefined;
    has<U extends NonNullable<T>>(data: Opt<U>, item: U): boolean;
    findIndex<U extends NonNullable<T>>(data: Opt<U>, item: U): number;
    isSuperset<U extends NonNullable<T>>(superset: Opt<U>, subset: Opt<U>): boolean;
}
export declare function push<T>(data: Opt<T>, item: T): Opt<T>;
export declare function concat<T>(a: Opt<T>, b: Opt<T>): Opt<T>;
export declare function size<T>(data: Opt<T>): number;
export declare function filter<T>(data: Opt<T>, cb: (item: T) => boolean): Opt<T>;
export declare function forEach<T>(data: Opt<T>, cb: (item: T, index: number) => void): void;
export declare function fromIter<T>(data: Iterable<T>): T | Many<T> | undefined;
export declare function find<T>(data: Opt<T>, cb: (item: T, index: number) => boolean): Opt<T>;
export declare function toArray<T, R>(data: Opt<T>, cb: (item: T, index: number) => R): R[];
export declare function mapToString<T>(data: Opt<T>, sep: string, cb: (item: T, index: number) => string): string;
export declare function filterMap<T, R>(data: Opt<T>, cb: (item: T) => undefined | R): Opt<R>;
export declare function findSorted<T>(compare: Compare<T>, data: T[], item: T): T | undefined;
export declare function findIndexSorted<T>(compare: Compare<T>, data: T[], item: T): number;
export declare function addSorted<T, U extends T[]>(compare: Compare<T>, data: U, item: T): U;
