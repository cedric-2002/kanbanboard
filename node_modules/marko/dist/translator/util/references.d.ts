import { types as t } from "@marko/compiler";
import { type Many, type Opt, Sorted } from "./optional";
import { type Section } from "./sections";
declare const kIsInvoked: unique symbol;
export declare const kBranchSerializeReason: unique symbol;
export type Aliases = undefined | Binding | {
    [property: string]: Aliases;
};
export declare enum BindingType {
    dom = 0,
    let = 1,
    input = 2,
    param = 3,
    local = 4,
    derived = 5,
    hoist = 6
}
export interface Sources {
    state: Opt<Binding>;
    input: Opt<InputBinding>;
}
export interface Binding {
    id: number;
    name: string;
    type: BindingType;
    loc: t.SourceLocation | null;
    section: Section;
    closureSections: Opt<Section>;
    assignmentSections: Opt<Section>;
    sources: undefined | Sources;
    aliases: Set<Binding>;
    hoists: Map<Section, Binding>;
    property: string | undefined;
    propertyAliases: Map<string, Binding>;
    excludeProperties: Opt<string>;
    upstreamAlias: Binding | undefined;
    downstreamExpressions: Set<ReferencedExtra>;
    scopeOffset: Binding | undefined;
    export: string | undefined;
    declared: boolean;
    nullable: boolean;
}
export interface InputBinding extends Binding {
    type: BindingType.input;
}
export type ReferencedBindings = Opt<Binding>;
export type Intersection = Many<Binding>;
type FnExtra = (t.FunctionExpressionExtra | t.ArrowFunctionExpressionExtra | t.FunctionDeclarationExtra) & {
    section: Section;
};
declare module "@marko/compiler/dist/types" {
    interface NodeExtra {
        section?: Section;
        referencedBindings?: ReferencedBindings;
        binding?: Binding;
        assignment?: Binding;
        assignmentTo?: Binding;
        read?: {
            binding: Binding;
            props: Opt<string>;
        };
        pruned?: true;
        isEffect?: true;
        [kIsInvoked]?: true;
    }
    interface FunctionExtra {
        referencedBindingsInFunction?: ReferencedBindings;
    }
    interface ArrowFunctionExpressionExtra extends FunctionExtra {
    }
    interface FunctionDeclarationExtra extends FunctionExtra {
    }
    interface FunctionExpressionExtra extends FunctionExtra {
    }
}
export declare function createBinding(name: string, type: Binding["type"], section: Section, upstreamAlias?: Binding["upstreamAlias"], property?: string, excludeProperties?: Opt<string>, loc?: t.SourceLocation | null, declared?: boolean): Binding;
export declare function trackVarReferences(tag: t.NodePath<t.MarkoTag>, type: BindingType, upstreamAlias?: Binding["upstreamAlias"]): Binding | undefined;
export declare function trackParamsReferences(body: t.NodePath<t.MarkoTagBody | t.Program>, type: BindingType, upstreamAlias?: Binding["upstreamAlias"]): Binding | undefined;
export declare function trackHoistedReference(referencePath: t.NodePath<t.Identifier>, binding: Binding): void;
export declare function setReferencesScope(path: t.NodePath<any>): void;
export declare function mergeReferences<T extends t.Node>(section: Section, target: T, nodes: (t.Node | undefined)[]): NonNullable<T["extra"]> & ReferencedExtra;
export declare function compareReferences(a: ReferencedBindings, b: ReferencedBindings): number;
export declare function finalizeReferences(): void;
export declare const intersectionMeta: WeakMap<Intersection, {
    id: number;
    scopeOffset: Binding | undefined;
}>;
export declare function setBindingValueExpr(binding: Binding, valueExpr: boolean | Opt<t.NodeExtra>): void;
export declare function createSources(state: Sources["state"], input: Sources["input"]): Sources;
export declare function compareSources(a: Sources, b: Sources): number;
export declare function mergeSources(a: undefined | Sources, b: undefined | Sources): Sources | undefined;
export declare const bindingUtil: Sorted<Binding>;
export declare function dropReferences(node: t.Node | t.Node[]): void;
export declare function getCanonicalBinding(binding?: Binding): Binding | undefined;
export declare function getAllTagReferenceNodes(tag: t.MarkoTag, referenceNodes?: t.Node[]): t.Node[];
export declare function getScopeAccessorLiteral(binding: Binding, includeId?: boolean): t.StringLiteral | t.NumericLiteral;
export declare function getScopeAccessor(binding: Binding, includeId?: boolean): string;
export declare function getDebugScopeAccess(binding: Binding): {
    root: Binding;
    access: string;
};
export declare function getDebugName(binding: Binding): string;
export declare function getInputDebugName(binding: InputBinding): string;
export declare function getSectionInstancesAccessor(section: Section): string;
export declare function getSectionInstancesAccessorLiteral(section: Section): t.StringLiteral | t.NumericLiteral | undefined;
export declare function getReadReplacement(node: t.Identifier | t.MemberExpression): t.Node | undefined;
export interface ReferencedExtra extends t.NodeExtra {
    section: Section;
    fnExtra?: FnExtra;
}
export declare function isReferencedExtra(extra: t.NodeExtra | undefined): extra is ReferencedExtra;
export interface AssignedBindingExtra extends ReferencedExtra {
    assignment: Binding;
}
export declare function isAssignedBindingExtra(extra: t.NodeExtra | undefined): extra is AssignedBindingExtra;
export interface RegisteredFnExtra extends ReferencedExtra {
    registerId: string;
    name: string;
    referencesScope?: boolean;
    referencedBindingsInFunction: ReferencedBindings;
}
export declare function isRegisteredFnExtra(extra: t.NodeExtra | undefined): extra is RegisteredFnExtra;
export {};
