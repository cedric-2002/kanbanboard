import { types as t } from "@marko/compiler";
import type { AccessorPrefix, AccessorProp } from "../../common/types";
import { type Opt } from "./optional";
import { type Binding, type ReferencedBindings } from "./references";
import { type Section } from "./sections";
export type Signal = {
    identifier: t.Identifier;
    valueAccessor?: t.Expression;
    referencedBindings: ReferencedBindings;
    section: Section;
    build: undefined | (() => t.Expression);
    register?: boolean;
    values: Array<{
        signal: Signal;
        value: t.Expression;
    }>;
    intersection: Opt<Signal>;
    render: t.Statement[];
    renderReferencedBindings: ReferencedBindings;
    effect: t.Statement[];
    effectReferencedBindings: ReferencedBindings;
    hasDynamicSubscribers?: true;
    export: boolean;
    extraArgs?: t.Expression[];
    prependStatements?: t.Statement[];
    buildAssignment?: (valueSection: Section, value: t.Expression) => t.Expression;
};
type closureSignalBuilder = (closure: Binding, render: t.Expression) => t.Expression;
export declare function setClosureSignalBuilder(tag: t.NodePath<t.MarkoTag>, builder: closureSignalBuilder): void;
export declare function setSectionSerializedValue(section: Section, prop: AccessorProp, expression: t.Expression): void;
export declare function setBindingSerializedValue(section: Section, binding: Binding, expression: t.Expression, prefix?: AccessorPrefix): void;
export declare function setSerializedValue(section: Section, key: string, expression: t.Expression): void;
export declare const getHTMLSectionStatements: (section: Section) => t.Statement[];
export declare function getHoistFunctionIdentifier(hoistedBinding: Binding): t.Identifier;
export declare function getSignal(section: Section, referencedBindings: ReferencedBindings, name?: string): Signal;
export declare function initValue(binding: Binding, runtimeHelper?: "value" | "state"): Signal;
export declare function getSignalFn(signal: Signal): t.Expression;
export declare function subscribe(references: ReferencedBindings, subscriber: Signal): void;
export declare function replaceNullishAndEmptyFunctionsWith0(args: (t.Expression | undefined | false)[]): t.Expression[];
export declare function addStatement(type: "render" | "effect", targetSection: Section, referencedBindings: ReferencedBindings, statement: t.Statement | t.Statement[], usedReferences?: ReferencedBindings[] | false): void;
export declare function addValue(targetSection: Section, referencedBindings: ReferencedBindings, signal: Signal["values"][number]["signal"], value: t.Expression): void;
export declare function getResumeRegisterId(section: Section, referencedBindings: string | ReferencedBindings, type?: string): string;
export declare function getRegisterUID(section: Section, name: string): string;
export declare function writeSignals(section: Section): void;
export declare function writeRegisteredFns(): void;
export declare function addHTMLEffectCall(section: Section, referencedBindings?: ReferencedBindings): void;
export declare function writeHTMLResumeStatements(path: t.NodePath<t.MarkoTagBody | t.Program>): void;
export declare function getSetup(section: Section): t.Identifier | undefined;
export declare function replaceRegisteredFunctionNode(node: t.Node): t.CallExpression | t.ClassPrivateProperty | t.ClassProperty | t.VariableDeclaration | t.Identifier | t.ObjectProperty | undefined;
export {};
