import { types as t } from "@marko/compiler";
import type { AccessorPrefix } from "../../common/accessor.debug";
import { Sorted } from "./optional";
import type { Binding, ReferencedBindings } from "./references";
import { type SerializeReason } from "./serialize-reasons";
export declare enum ContentType {
    Comment = 0,
    Dynamic = 1,
    Placeholder = 2,
    Tag = 3,
    Text = 4
}
export interface Section {
    id: number;
    name: string;
    loc: t.SourceLocation | undefined;
    depth: number;
    parent: Section | undefined;
    sectionAccessor: {
        binding: Binding;
        prefix: AccessorPrefix;
    } | undefined;
    params: undefined | Binding;
    referencedLocalClosures: ReferencedBindings;
    referencedClosures: ReferencedBindings;
    referencedHoists: ReferencedBindings;
    bindings: ReferencedBindings;
    hoisted: ReferencedBindings;
    serializeReason: undefined | SerializeReason;
    serializeReasons: Map<symbol, SerializeReason>;
    isHoistThrough: true | undefined;
    upstreamExpression: t.NodeExtra | undefined;
    downstreamBinding: Binding | undefined;
    hasAbortSignal: boolean;
    isBranch: boolean;
    content: null | {
        startType: ContentType;
        endType: ContentType;
        singleChild: boolean;
    };
}
declare module "@marko/compiler/dist/types" {
    interface ProgramExtra {
        section?: Section;
        sections?: Section[];
    }
    interface MarkoTagBodyExtra {
        section?: Section;
    }
}
export declare const sectionUtil: Sorted<Section>;
export declare function startSection(path: t.NodePath<t.MarkoTagBody | t.Program>): Section | undefined;
export declare function getOrCreateSection(path: t.NodePath<any>): Section;
export declare function getSectionForBody(body: t.NodePath<t.MarkoTagBody | t.Program>): Section | undefined;
export declare function getSection(path: t.NodePath): Section;
export declare const getScopeIdIdentifier: (section: Section) => t.Identifier;
export declare const getSectionParentIsOwner: (section: Section) => boolean, setSectionParentIsOwner: (section: Section, value: boolean) => void;
export declare const getScopeIdentifier: (section: Section, ignoreDefault?: boolean) => t.Identifier;
export declare function forEachSection(fn: (section: Section) => void): void;
export declare function forEachSectionReverse(fn: (section: Section) => void): void;
export declare function getNodeContentType(path: t.NodePath<t.Statement>, extraMember: "startType" | "endType", contentInfo?: Section["content"]): ContentType | null;
export declare const isSerializedSection: (section: Section) => boolean;
export declare function isSectionWithHoists(section: Section): boolean;
export declare function isImmediateOwner(section: Section, binding: Binding): boolean;
export declare function isDirectClosure(section: Section, closure: Binding): boolean;
export declare function isDynamicClosure(section: Section, closure: Binding): boolean;
export declare function getDynamicClosureIndex(closure: Binding, closureSection: Section): number;
export declare function getDirectClosures(section: Section): import("./optional").Opt<Binding>;
export declare function isSameOrChildSection(section: Section, other: Section): boolean;
export declare function getCommonSection(section: Section, other: Section): Section;
