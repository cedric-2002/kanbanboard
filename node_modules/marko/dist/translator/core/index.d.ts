declare const _default: {
    taglibId: string;
    "<attrs>": import("@marko/compiler/babel-utils").Tag;
    "<await>": import("@marko/compiler/babel-utils").Tag;
    "<client>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<const>": import("@marko/compiler/babel-utils").Tag;
    "<debug>": import("@marko/compiler/babel-utils").Tag;
    "<define>": import("@marko/compiler/babel-utils").Tag;
    "<effect>": import("@marko/compiler/babel-utils").Tag;
    "<else-if>": {
        autocomplete: {
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        }[];
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
    };
    "<else>": {
        autocomplete: {
            description: string;
            descriptionMoreURL: string;
        }[];
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
    };
    "<export>": import("@marko/compiler/babel-utils").Tag;
    "<for>": {
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
        attributes: {
            of: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            in: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            to: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            from: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
            step: {
                type: string;
                autocomplete: {
                    description: string;
                }[];
            };
        };
        autocomplete: ({
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        } | {
            snippet: string;
            descriptionMoreURL: string;
            description?: undefined;
        })[];
    };
    "<html-comment>": import("@marko/compiler/babel-utils").Tag;
    "<html-script>": import("@marko/compiler/babel-utils").Tag;
    "<html-style>": import("@marko/compiler/babel-utils").Tag;
    "<id>": import("@marko/compiler/babel-utils").Tag;
    "<if>": {
        analyze(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        translate: {
            readonly enter: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
            readonly exit: (path: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>) => void;
        };
        parseOptions: {
            controlFlow: true;
        };
        autocomplete: {
            snippet: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<import>": import("@marko/compiler/babel-utils").Tag;
    "<let>": import("@marko/compiler/babel-utils").Tag;
    "<lifecycle>": import("@marko/compiler/babel-utils").Tag;
    "<log>": import("@marko/compiler/babel-utils").Tag;
    "<return>": import("@marko/compiler/babel-utils").Tag;
    "<script>": import("@marko/compiler/babel-utils").Tag;
    "<server>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<static>": {
        parse(tag: import("@marko/compiler/babel-types").NodePath<import("@marko/compiler/babel-types").MarkoTag>): void;
        parseOptions: {
            statement: boolean;
            rawOpenTag: boolean;
        };
        autocomplete: {
            displayText: string;
            description: string;
            descriptionMoreURL: string;
        }[];
    };
    "<style>": import("@marko/compiler/babel-utils").Tag;
    "<try>": import("@marko/compiler/babel-utils").Tag;
};
export default _default;
