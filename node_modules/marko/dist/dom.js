"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: !0 });
}, __copyProps = (to, from, except, desc) => {
  if (from && typeof from == "object" || typeof from == "function")
    for (let key of __getOwnPropNames(from))
      !__hasOwnProp.call(to, key) && key !== except && __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: !0 }), mod);

// src/dom.ts
var dom_exports = {};
__export(dom_exports, {
  attr: () => attr,
  attrTag: () => attrTag,
  attrTags: () => attrTags,
  attrs: () => attrs,
  attrsAndContent: () => attrsAndContent,
  attrsEvents: () => attrsEvents,
  awaitTag: () => awaitTag,
  classAttr: () => classAttr,
  classItem: () => classItem,
  classItems: () => classItems,
  compat: () => compat,
  conditional: () => conditional,
  conditionalClosure: () => conditionalClosure,
  controllable_detailsOrDialog_open: () => controllable_detailsOrDialog_open,
  controllable_detailsOrDialog_open_effect: () => controllable_detailsOrDialog_open_effect,
  controllable_input_checked: () => controllable_input_checked,
  controllable_input_checkedValue: () => controllable_input_checkedValue,
  controllable_input_checkedValue_effect: () => controllable_input_checkedValue_effect,
  controllable_input_checked_effect: () => controllable_input_checked_effect,
  controllable_input_value: () => controllable_input_value,
  controllable_input_value_effect: () => controllable_input_value_effect,
  controllable_select_value: () => controllable_select_value,
  controllable_select_value_effect: () => controllable_select_value_effect,
  controllable_textarea_value: () => controllable_input_value,
  controllable_textarea_value_effect: () => controllable_input_value_effect,
  createContent: () => createContent,
  createRenderer: () => createRenderer,
  createTemplate: () => createTemplate,
  createTry: () => createTry,
  data: () => data,
  dynamicClosure: () => dynamicClosure,
  dynamicClosureRead: () => dynamicClosureRead,
  dynamicTag: () => dynamicTag,
  effect: () => effect,
  enableCatch: () => enableCatch,
  forIn: () => forIn,
  forOf: () => forOf,
  forTo: () => forTo,
  getAbortSignal: () => getAbortSignal,
  hoist: () => hoist,
  html: () => html,
  init: () => init,
  insertContent: () => insertContent,
  intersection: () => intersection,
  lifecycle: () => lifecycle,
  localClosures: () => localClosures,
  loopClosure: () => loopClosure,
  loopIn: () => loopIn,
  loopOf: () => loopOf,
  loopTo: () => loopTo,
  nextTagId: () => nextTagId,
  nodeRef: () => nodeRef,
  on: () => on,
  partialAttrs: () => partialAttrs,
  partialAttrsAndContent: () => partialAttrsAndContent,
  props: () => props,
  register: () => register,
  registerBoundSignal: () => registerBoundSignal,
  registerContent: () => registerContent,
  resetAbortSignal: () => resetAbortSignal,
  run: () => run,
  setTagVar: () => setTagVar,
  setTagVarChange: () => setTagVarChange,
  state: () => state,
  styleAttr: () => styleAttr,
  styleItem: () => styleItem,
  styleItems: () => styleItems,
  tagVarSignal: () => tagVarSignal,
  tagVarSignalChange: () => tagVarSignalChange,
  textContent: () => textContent,
  value: () => value
});
module.exports = __toCommonJS(dom_exports);

// src/common/attr-tag.ts
var empty = [], rest = Symbol();
function attrTag(attrs2) {
  return attrs2[Symbol.iterator] = attrTagIterator, attrs2[rest] = empty, attrs2;
}
function attrTags(first, attrs2) {
  return first ? (first[rest] === empty ? first[rest] = [attrs2] : first[rest].push(attrs2), first) : attrTag(attrs2);
}
function* attrTagIterator() {
  yield this, yield* this[rest];
}

// src/common/for.ts
function forIn(obj, cb) {
  for (let key in obj)
    cb(key, obj[key]);
}
function forOf(list, cb) {
  if (list) {
    let i = 0;
    for (let item of list)
      cb(item, i++);
  }
}
function forTo(to, from, step, cb) {
  let start = from || 0, delta = step || 1;
  for (let steps = (to - start) / delta, i = 0; i <= steps; i++)
    cb(start + i * delta);
}

// src/common/helpers.ts
function classValue(classValue2) {
  return toDelimitedString(classValue2, " ", stringifyClassObject);
}
function stringifyClassObject(name, value2) {
  return value2 ? name : "";
}
function styleValue(styleValue2) {
  return toDelimitedString(styleValue2, ";", stringifyStyleObject);
}
function stringifyStyleObject(name, value2) {
  return value2 || value2 === 0 ? name + ":" + value2 : "";
}
function toDelimitedString(val, delimiter, stringify) {
  let str = "", sep = "", part;
  if (val)
    if (typeof val != "object")
      str += val;
    else if (Array.isArray(val))
      for (let v of val)
        part = toDelimitedString(v, delimiter, stringify), part && (str += sep + part, sep = delimiter);
    else
      for (let name in val)
        part = stringify(name, val[name]), part && (str += sep + part, sep = delimiter);
  return str;
}
function isEventHandler(name) {
  return /^on[A-Z-]/.test(name);
}
function getEventHandlerName(name) {
  return name[2] === "-" ? name.slice(3) : name.slice(2).toLowerCase();
}
function normalizeDynamicRenderer(value2) {
  return value2 ? value2.content || value2.default || value2 : void 0;
}

// src/dom/event.ts
var defaultDelegator = createDelegator();
function on(element, type, handler) {
  element["$" + type] === void 0 && defaultDelegator(element, type, handleDelegated), element["$" + type] = handler || null;
}
function createDelegator() {
  let kEvents = Symbol();
  return function(node, type, handler) {
    ((node = node.getRootNode())[kEvents] ||= {})[type] ||= (node.addEventListener(type, handler, !0), 1);
  };
}
function handleDelegated(ev) {
  let target = !rendering && ev.target;
  for (; target; )
    target["$" + ev.type]?.(ev, target), target = ev.bubbles && !ev.cancelBubble && target.parentNode;
}

// src/dom/resolve-cursor-position.ts
function resolveCursorPosition(inputType2, initialPosition, initialValue, updatedValue) {
  if (
    // If initial position is null or false then
    // either this node is not the active element
    // or does not support selection ranges.
    (initialPosition || initialPosition === 0) && (initialPosition !== initialValue.length || // short regex to match input types that delete backwards
    /kw/.test(inputType2))
  ) {
    let before = initialValue.slice(0, initialPosition), after = initialValue.slice(initialPosition);
    if (updatedValue.startsWith(before))
      return initialPosition;
    if (updatedValue.endsWith(after))
      return updatedValue.length - after.length;
    {
      let relevantChars = stripSpacesAndPunctuation(before).length, pos = 0, relevantIndex = 0;
      for (; relevantIndex < relevantChars; )
        stripSpacesAndPunctuation(updatedValue[pos]) && relevantIndex++, pos++;
      return pos;
    }
  }
  return -1;
}
function stripSpacesAndPunctuation(str) {
  return str.replace(/[^\p{L}\p{N}]/gu, "");
}

// src/common/meta.ts
var DEFAULT_RUNTIME_ID = "M", DEFAULT_RENDER_ID = "_";

// src/dom/resume.ts
var registeredValues = {}, branchesEnabled;
function enableBranches() {
  branchesEnabled = 1;
}
function init(runtimeId = DEFAULT_RUNTIME_ID) {
  let renders = self[runtimeId], defineRuntime = (desc) => Object.defineProperty(self, runtimeId, desc), resumeRender, initRuntime = (renders2) => {
    defineRuntime({
      value: resumeRender = (renderId) => {
        let render = resumeRender[renderId] = renders2[renderId] || renders2(renderId), walk2 = render.w, commentPrefixLen = render.i.length, scopeLookup = render.s = {}, serializeContext = {
          _: registeredValues
        }, branches = branchesEnabled && /* @__PURE__ */ (() => {
          let branchStack = [], branchIds = /* @__PURE__ */ new Set(), parentBranchIds = /* @__PURE__ */ new Map(), lastEndNode, currentBranchId, endBranch = (branchId, reference) => {
            let branch = scopeLookup[branchId] ||= {}, endNode = reference, prevNode;
            for (; (prevNode = endNode.previousSibling) !== branch.h && ~visits.indexOf(endNode = prevNode); ) ;
            return branch.j = lastEndNode = endNode === lastEndNode ? reference.parentNode.insertBefore(new Text(), reference) : endNode, branch.h ||= lastEndNode, branchIds.add(branchId), branch;
          };
          return {
            J() {
              if (visitToken === "[" /* BranchStart */)
                currentBranchId && visitDataIndex && (endBranch(currentBranchId, visit), currentBranchId = branchStack.pop()), currentBranchId && (branchStack.push(currentBranchId), parentBranchIds.set(scopeId, currentBranchId)), currentBranchId = scopeId, visitScope.h = visit;
              else if (visitToken === "]" /* BranchEnd */) {
                let curParent = visit.parentNode, startNode = endBranch(
                  currentBranchId,
                  visit
                ).h;
                visitScope[visitData] = visit, curParent !== startNode.parentNode && curParent.prepend(startNode), currentBranchId = branchStack.pop();
              } else {
                let next = visitData.indexOf(" "), curNode = visit;
                for (visitScope[~next ? visitData.slice(0, next) : visitData] = visitToken === "=" /* BranchSingleNodeOnlyChildInParent */ ? visit.parentNode : visit; ~next; ) {
                  let start = next + 1;
                  next = visitData.indexOf(" ", start);
                  let childScopeId = +visitData.slice(
                    start,
                    ~next ? next : visitData.length
                  );
                  curNode = endBranch(childScopeId, curNode).j, parentBranchIds.set(childScopeId, scopeId);
                }
              }
            },
            p(scope) {
              let parentBranchId = scope.g || parentBranchIds.get(scopeId);
              if (parentBranchId && (scope.k = scopeLookup[parentBranchId]), branchIds.has(scopeId)) {
                let branch = scope, parentBranch = branch.k;
                scope.k = branch, parentBranch && (branch.y = parentBranch, (parentBranch.A ||= /* @__PURE__ */ new Set()).add(branch));
              }
            }
          };
        })(), $global, lastScopeId = 0, lastEffect, visits, resumes, scopeId, visit, visitText, visitData, visitDataIndex, visitToken, visitScope;
        return render.w = () => {
          try {
            walk2(), isResuming = 1;
            for (visit of visits = render.v)
              visitText = visit.data, visitDataIndex = visitText.indexOf(" ") + 1, scopeId = +visitText.slice(
                commentPrefixLen + 1,
                visitDataIndex ? visitDataIndex - 1 : visitText.length
              ), visitData = visitDataIndex ? visitText.slice(visitDataIndex) : "", visitToken = visitText[commentPrefixLen], visitScope = scopeLookup[scopeId] ||= {
                l: scopeId
              }, visitToken === "*" /* Node */ ? visitScope["j" /* Getter */ + visitData] = /* @__PURE__ */ ((node) => () => node)(visitScope[visitData] = visit.previousSibling) : branches && branches.J();
            for (let serialized of resumes = render.r || [])
              if (typeof serialized == "string")
                lastEffect = serialized;
              else if (typeof serialized == "number")
                registeredValues[lastEffect](
                  scopeLookup[serialized] ||= {
                    l: scopeId
                  },
                  scopeLookup[serialized]
                );
              else
                for (let scope of serialized(serializeContext))
                  $global ? typeof scope == "number" ? lastScopeId += scope : (scopeId = ++lastScopeId, scope.$global = $global, scope.l = scopeId, scopeLookup[scopeId] !== scope && (scopeLookup[scopeId] = Object.assign(
                    scope,
                    scopeLookup[scopeId]
                  )), branches && branches.p(scope)) : ($global = scope || {}, $global.runtimeId = runtimeId, $global.renderId = renderId, $global.q = 1e6);
          } finally {
            isResuming = visits.length = resumes.length = 0;
          }
        }, render;
      }
    });
  };
  if (renders) {
    initRuntime(renders);
    for (let renderId in renders)
      resumeRender(renderId).w();
  } else
    defineRuntime({
      configurable: !0,
      set: initRuntime
    });
}
var isResuming;
function register(id, obj) {
  return registeredValues[id] = obj, obj;
}
function registerBoundSignal(id, signal) {
  return registeredValues[id] = (scope) => (value2) => signal(scope, value2), signal;
}
function getRegisteredWithScope(id, scope) {
  let val = registeredValues[id];
  return scope ? val(scope) : val;
}
function nodeRef(id, key) {
  return register(id, (scope) => () => scope[key]());
}

// src/dom/controllable.ts
function controllable_input_checked(scope, nodeAccessor, checked, checkedChange) {
  setCheckboxValue(
    scope,
    nodeAccessor,
    0 /* InputChecked */,
    normalizeBoolProp(checked),
    checkedChange
  );
}
function controllable_input_checked_effect(scope, nodeAccessor) {
  let el = scope[nodeAccessor];
  syncControllable(el, "input", hasCheckboxChanged, () => {
    let checkedChange = scope["e" /* ControlledHandler */ + nodeAccessor];
    if (checkedChange) {
      let newValue = el.checked;
      el.checked = !newValue, checkedChange(newValue), run();
    }
  });
}
function controllable_input_checkedValue(scope, nodeAccessor, checkedValue, checkedValueChange, value2) {
  scope["g" /* ControlledValue */ + nodeAccessor] = checkedValue, attr(scope[nodeAccessor], "value", value2), setCheckboxValue(
    scope,
    nodeAccessor,
    1 /* InputCheckedValue */,
    Array.isArray(checkedValue) ? checkedValue.includes(value2) : checkedValue === value2,
    checkedValueChange
  );
}
function controllable_input_checkedValue_effect(scope, nodeAccessor) {
  let el = scope[nodeAccessor];
  syncControllable(el, "input", hasCheckboxChanged, () => {
    let checkedValueChange = scope["e" /* ControlledHandler */ + nodeAccessor];
    if (checkedValueChange) {
      let oldValue = scope["g" /* ControlledValue */ + nodeAccessor], newValue = Array.isArray(oldValue) ? updateList(oldValue, el.value, el.checked) : el.checked ? el.value : void 0;
      if (el.name && el.type[0] === "r")
        for (let radio of el.getRootNode().querySelectorAll(
          `[type=radio][name=${CSS.escape(el.name)}]`
        ))
          radio.form === el.form && (radio.checked = Array.isArray(oldValue) ? oldValue.includes(radio.value) : oldValue === radio.value);
      else
        el.checked = !el.checked;
      checkedValueChange(newValue), run();
    }
  });
}
function controllable_input_value(scope, nodeAccessor, value2, valueChange) {
  let el = scope[nodeAccessor], normalizedValue = normalizeStrProp(value2);
  scope["e" /* ControlledHandler */ + nodeAccessor] = valueChange, valueChange ? (scope["f" /* ControlledType */ + nodeAccessor] = 0 /* InputChecked */, scope["g" /* ControlledValue */ + nodeAccessor] = value2, el.isConnected ? setValueAndUpdateSelection(el, normalizedValue) : el.defaultValue = normalizedValue) : (scope["f" /* ControlledType */ + nodeAccessor] = 5 /* None */, el.defaultValue = normalizedValue);
}
function controllable_input_value_effect(scope, nodeAccessor) {
  let el = scope[nodeAccessor];
  isResuming && (scope["g" /* ControlledValue */ + nodeAccessor] = el.defaultValue), syncControllable(el, "input", hasValueChanged, (ev) => {
    let valueChange = scope["e" /* ControlledHandler */ + nodeAccessor];
    valueChange && (inputType = ev?.inputType, valueChange(el.value), run(), setValueAndUpdateSelection(
      el,
      scope["g" /* ControlledValue */ + nodeAccessor]
    ), inputType = "");
  });
}
function controllable_select_value(scope, nodeAccessor, value2, valueChange) {
  scope["e" /* ControlledHandler */ + nodeAccessor] = valueChange, valueChange ? (scope["f" /* ControlledType */ + nodeAccessor] = 3 /* SelectValue */, scope["g" /* ControlledValue */ + nodeAccessor] = value2) : scope["f" /* ControlledType */ + nodeAccessor] = 5 /* None */, pendingEffects.unshift(
    () => setSelectOptions(
      scope[nodeAccessor],
      value2,
      valueChange
    ),
    scope
  );
}
function controllable_select_value_effect(scope, nodeAccessor) {
  let el = scope[nodeAccessor], onChange = () => {
    let valueChange = scope["e" /* ControlledHandler */ + nodeAccessor];
    if (valueChange) {
      let newValue = Array.isArray(
        scope["g" /* ControlledValue */ + nodeAccessor]
      ) ? Array.from(el.selectedOptions, toValueProp) : el.value;
      setSelectOptions(
        el,
        scope["g" /* ControlledValue */ + nodeAccessor],
        valueChange
      ), valueChange(newValue), run();
    }
  };
  el._ || new MutationObserver(() => {
    let value2 = scope["g" /* ControlledValue */ + nodeAccessor];
    (Array.isArray(value2) ? value2.length !== el.selectedOptions.length || value2.some((value3, i) => value3 != el.selectedOptions[i].value) : el.value != value2) && onChange();
  }).observe(el, {
    childList: !0,
    subtree: !0
  }), syncControllable(el, "input", hasSelectChanged, onChange);
}
function setSelectOptions(el, value2, valueChange) {
  if (Array.isArray(value2))
    for (let opt of el.options) {
      let selected = value2.includes(opt.value);
      valueChange ? opt.selected = selected : opt.defaultSelected = selected;
    }
  else {
    let normalizedValue = normalizeStrProp(value2);
    if (valueChange)
      el.value = normalizedValue;
    else
      for (let opt of el.options)
        opt.defaultSelected = opt.value === normalizedValue;
  }
}
function controllable_detailsOrDialog_open(scope, nodeAccessor, open, openChange) {
  scope["e" /* ControlledHandler */ + nodeAccessor] = openChange, openChange ? scope["f" /* ControlledType */ + nodeAccessor] = 4 /* DetailsOrDialogOpen */ : scope["f" /* ControlledType */ + nodeAccessor] = 5 /* None */, scope[nodeAccessor].open = scope["g" /* ControlledValue */ + nodeAccessor] = normalizeBoolProp(open);
}
function controllable_detailsOrDialog_open_effect(scope, nodeAccessor) {
  let el = scope[nodeAccessor], hasChanged = () => el.open !== scope["g" /* ControlledValue */ + nodeAccessor];
  syncControllable(
    el,
    el.tagName === "DIALOG" ? "close" : "toggle",
    hasChanged,
    () => {
      let openChange = scope["e" /* ControlledHandler */ + nodeAccessor];
      if (openChange && hasChanged()) {
        let newValue = el.open;
        el.open = !newValue, openChange(newValue), run();
      }
    }
  );
}
var inputType = "";
function setValueAndUpdateSelection(el, value2) {
  if (el.value !== value2) {
    let updatedPosition = resolveCursorPosition(
      inputType,
      el.getRootNode().activeElement === el && el.selectionStart,
      el.value,
      el.value = value2
    );
    ~updatedPosition && el.setSelectionRange(updatedPosition, updatedPosition);
  }
}
function setCheckboxValue(scope, nodeAccessor, type, checked, checkedChange) {
  scope["e" /* ControlledHandler */ + nodeAccessor] = checkedChange, checkedChange ? (scope["f" /* ControlledType */ + nodeAccessor] = type, scope[nodeAccessor].checked = checked) : (scope["f" /* ControlledType */ + nodeAccessor] = 5 /* None */, scope[nodeAccessor].defaultChecked = checked);
}
var controllableDelegate = createDelegator();
function syncControllable(el, event, hasChanged, onChange) {
  el._ || (controllableDelegate(el, event, handleChange), el.form && controllableDelegate(el.form, "reset", handleFormReset), isResuming && hasChanged(el) && queueMicrotask(onChange)), el._ = onChange;
}
function handleChange(ev) {
  ev.target._?.(ev);
}
function handleFormReset(ev) {
  let handlers = [];
  for (let el of ev.target.elements)
    el._ && hasFormElementChanged(el) && handlers.push(el._);
  requestAnimationFrame(() => {
    if (!ev.defaultPrevented)
      for (let change of handlers)
        change();
  });
}
function hasValueChanged(el) {
  return el.value !== el.defaultValue;
}
function hasCheckboxChanged(el) {
  return el.checked !== el.defaultChecked;
}
function hasSelectChanged(el) {
  for (let opt of el.options)
    if (opt.selected !== opt.defaultSelected)
      return !0;
}
function hasFormElementChanged(el) {
  return el.options ? hasSelectChanged(el) : hasValueChanged(el) || hasCheckboxChanged(el);
}
function normalizeStrProp(value2) {
  return normalizeAttrValue(value2) || "";
}
function normalizeBoolProp(value2) {
  return value2 != null && value2 !== !1;
}
function updateList(arr, val, push) {
  let index = arr.indexOf(val);
  return (push ? !~index && [...arr, val] : ~index && arr.slice(0, index).concat(arr.slice(index + 1))) || arr;
}
function toValueProp(it) {
  return it.value;
}

// src/dom/parse-html.ts
var parsers = {};
function parseHTML(html2, ns) {
  let parser = parsers[ns] ||= document.createElementNS(ns, "template");
  return parser.innerHTML = html2, parser.content || parser;
}

// src/dom/scope.ts
function createScope($global, closestBranch) {
  let scope = {
    l: $global.q++,
    t: 1,
    k: closestBranch,
    $global
  };
  return pendingScopes.push(scope), scope;
}
function skipScope(scope) {
  return scope.$global.q++;
}
function findBranchWithKey(scope, key) {
  let branch = scope.k;
  for (; branch && !branch[key]; )
    branch = branch.y;
  return branch;
}
function destroyBranch(branch) {
  branch.y?.A?.delete(branch), destroyNestedBranches(branch);
}
function destroyNestedBranches(branch) {
  branch.B = 1, branch.A?.forEach(destroyNestedBranches), branch.K?.forEach((scope) => {
    for (let id in scope.z)
      scope.z[id]?.abort();
  });
}
function removeAndDestroyBranch(branch) {
  destroyBranch(branch), removeChildNodes(branch.h, branch.j);
}
function insertBranchBefore(branch, parentNode, nextSibling) {
  insertChildNodes(
    parentNode,
    nextSibling,
    branch.h,
    branch.j
  );
}
function tempDetachBranch(branch) {
  let fragment = new DocumentFragment();
  fragment.namespaceURI = branch.h.parentNode.namespaceURI, insertChildNodes(fragment, null, branch.h, branch.j);
}

// src/dom/schedule.ts
var isScheduled, channel;
function schedule() {
  isScheduled || (isScheduled = 1, queueMicrotask(flushAndWaitFrame));
}
function flushAndWaitFrame() {
  run(), requestAnimationFrame(triggerMacroTask);
}
function triggerMacroTask() {
  channel || (channel = new MessageChannel(), channel.port1.onmessage = () => {
    isScheduled = 0, run();
  }), channel.port2.postMessage(0);
}

// src/dom/signals.ts
function state(valueAccessor, fn) {
  if (0)
    var id;
  let valueChangeAccessor = "o" /* TagVariableChange */ + valueAccessor, update = (scope, value2) => {
    scope[valueAccessor] !== value2 && (scope[valueAccessor] = value2, fn(scope, value2));
  };
  return (scope, value2, valueChange) => (rendering ? ((scope[valueChangeAccessor] = valueChange) && scope[valueAccessor] !== value2 || !(valueAccessor in scope)) && (scope[valueAccessor] = value2, fn(scope, value2)) : scope[valueChangeAccessor] ? scope[valueChangeAccessor](value2) : (schedule(), queueRender(
    scope,
    update,
    valueAccessor,
    value2
  )), value2);
}
function value(valueAccessor, fn = () => {
}) {
  return (scope, value2) => {
    (!(valueAccessor in scope) || scope[valueAccessor] !== value2) && (scope[valueAccessor] = value2, fn(scope, value2));
  };
}
function intersection(id, fn, defaultPending = 1, scopeIdAccessor = /* @__KEY__ */ "l") {
  return (scope) => {
    scope.t ? scope[id] === void 0 ? scope[id] = defaultPending : --scope[id] || fn(scope) : queueRender(scope, fn, id, 0, scope[scopeIdAccessor]);
  };
}
function loopClosure(valueAccessor, ownerLoopNodeAccessor, fn) {
  let childSignal = closure(valueAccessor, fn), loopScopeAccessor = "l" /* LoopScopeArray */ + ownerLoopNodeAccessor, loopScopeMapAccessor = "m" /* LoopScopeMap */ + ownerLoopNodeAccessor, ownerSignal = (ownerScope) => {
    let scopes = ownerScope[loopScopeAccessor] ||= ownerScope[loopScopeMapAccessor] ? [...ownerScope[loopScopeMapAccessor].values()] : [], [firstScope] = scopes;
    firstScope && queueRender(
      ownerScope,
      () => {
        for (let scope of scopes)
          !scope.t && !scope.B && childSignal(scope);
      },
      -1,
      0,
      firstScope.l
    );
  };
  return ownerSignal._ = childSignal, ownerSignal;
}
function conditionalClosure(valueAccessor, ownerConditionalNodeAccessor, branch, fn) {
  let childSignal = closure(valueAccessor, fn), scopeAccessor = "d" /* ConditionalScope */ + ownerConditionalNodeAccessor, branchAccessor = "c" /* ConditionalRenderer */ + ownerConditionalNodeAccessor, ownerSignal = (scope) => {
    let ifScope = scope[scopeAccessor];
    ifScope && !ifScope.t && scope[branchAccessor] === branch && queueRender(ifScope, childSignal, -1);
  };
  return ownerSignal._ = childSignal, ownerSignal;
}
function subscribeToScopeSet(ownerScope, accessor, scope) {
  let subscribers = ownerScope[accessor] ||= /* @__PURE__ */ new Set();
  subscribers.has(scope) || (subscribers.add(scope), getAbortSignal(scope, -1).addEventListener(
    "abort",
    () => ownerScope[accessor].delete(scope)
  ));
}
function dynamicClosure(...closureSignals) {
  let [{ E: ___scopeInstancesAccessor, F: ___signalIndexAccessor }] = closureSignals;
  for (let i = closureSignals.length; i--; )
    closureSignals[i].L = i;
  return (scope) => {
    if (scope[___scopeInstancesAccessor])
      for (let childScope of scope[___scopeInstancesAccessor])
        childScope.t || queueRender(
          childScope,
          closureSignals[childScope[___signalIndexAccessor]],
          -1
        );
  };
}
function dynamicClosureRead(valueAccessor, fn, getOwnerScope) {
  let childSignal = closure(valueAccessor, fn, getOwnerScope), closureSignal = (scope) => {
    scope[closureSignal.F] = closureSignal.L, childSignal(scope), subscribeToScopeSet(
      getOwnerScope ? getOwnerScope(scope) : scope._,
      closureSignal.E,
      scope
    );
  };
  return closureSignal.E = "a" /* ClosureScopes */ + valueAccessor, closureSignal.F = "b" /* ClosureSignalIndex */ + valueAccessor, closureSignal;
}
function closure(valueAccessor, fn, getOwnerScope) {
  return (scope) => {
    fn(
      scope,
      (getOwnerScope ? getOwnerScope(scope) : scope._)[valueAccessor]
    );
  };
}
function setTagVar(scope, childAccessor, tagVarSignal2) {
  scope[childAccessor].e = (value2) => tagVarSignal2(scope, value2);
}
var tagVarSignal = (scope, value2) => scope.e?.(value2);
function setTagVarChange(scope, changeHandler) {
  scope.f = changeHandler;
}
var tagVarSignalChange = (scope, value2) => scope.f?.(value2), tagIdsByGlobal = /* @__PURE__ */ new WeakMap();
function nextTagId({ $global }) {
  let id = tagIdsByGlobal.get($global) || 0;
  return tagIdsByGlobal.set($global, id + 1), "c" + $global.runtimeId + $global.renderId + id.toString(36);
}
function effect(id, fn) {
  return register(id, fn), (scope) => {
    queueEffect(scope, fn);
  };
}
function* traverseAllHoisted(scope, path, curIndex = path.length - 1) {
  if (scope)
    if (Symbol.iterator in scope)
      for (let s of scope instanceof Map ? scope.values() : scope)
        yield* traverseAllHoisted(s, path, curIndex);
    else curIndex ? yield* traverseAllHoisted(scope[path[curIndex]], path, curIndex - 1) : yield scope[path[0]];
}
function hoist(...path) {
  return (scope) => {
    let getOne = (...args) => iterator().next().value(...args), iterator = getOne[Symbol.iterator] = () => traverseAllHoisted(scope, path);
    return getOne;
  };
}

// src/dom/walker.ts
var walker = /* @__PURE__ */ document.createTreeWalker(document);
function walk(startNode, walkCodes, branch) {
  walker.currentNode = startNode, walkInternal(0, walkCodes, branch);
}
function walkInternal(currentWalkIndex, walkCodes, scope) {
  let value2, storedMultiplier = 0, currentMultiplier = 0, currentScopeIndex = 0;
  for (; currentWalkIndex < walkCodes.length; )
    if (value2 = walkCodes.charCodeAt(currentWalkIndex++), currentMultiplier = storedMultiplier, storedMultiplier = 0, value2 === 32 /* Get */) {
      let node = walker.currentNode;
      scope[currentScopeIndex] = node, scope["j" /* Getter */ + currentScopeIndex++] = () => node;
    } else if (value2 === 37 /* Replace */ || value2 === 49 /* DynamicTagWithVar */)
      walker.currentNode.replaceWith(
        walker.currentNode = scope[currentScopeIndex++] = new Text()
      ), value2 === 49 /* DynamicTagWithVar */ && (scope[currentScopeIndex++] = skipScope(scope));
    else {
      if (value2 === 38 /* EndChild */)
        return currentWalkIndex;
      if (value2 === 47 /* BeginChild */ || value2 === 48 /* BeginChildWithVar */)
        currentWalkIndex = walkInternal(
          currentWalkIndex,
          walkCodes,
          scope[currentScopeIndex++] = createScope(scope.$global, scope.k)
        ), value2 === 48 /* BeginChildWithVar */ && (scope[currentScopeIndex++] = skipScope(scope));
      else if (value2 < 92)
        for (value2 = 20 /* Next */ * currentMultiplier + value2 - 67 /* Next */; value2--; )
          walker.nextNode();
      else if (value2 < 107)
        for (value2 = 10 /* Over */ * currentMultiplier + value2 - 97 /* Over */; value2--; )
          walker.nextSibling();
      else if (value2 < 117) {
        for (value2 = 10 /* Out */ * currentMultiplier + value2 - 107 /* Out */; value2--; )
          walker.parentNode();
        walker.nextSibling();
      } else
        storedMultiplier = currentMultiplier * 10 /* Multiplier */ + value2 - 117 /* Multiplier */;
    }
}

// src/dom/renderer.ts
function createBranch($global, renderer, parentScope, parentNode) {
  let branch = createScope($global), parentBranch = parentScope?.k;
  return branch._ = renderer.u || parentScope, branch.k = branch, parentBranch && (branch.y = parentBranch, (parentBranch.A ||= /* @__PURE__ */ new Set()).add(branch)), renderer.C?.(
    branch,
    parentNode.namespaceURI
  ), branch;
}
function createAndSetupBranch($global, renderer, parentScope, parentNode) {
  return setupBranch(
    renderer,
    createBranch($global, renderer, parentScope, parentNode)
  );
}
function setupBranch(renderer, branch) {
  return renderer.D && queueRender(branch, renderer.D, -1), branch;
}
function createContent(id, template, walks, setup, params, dynamicScopesAccessor) {
  walks = walks ? walks.replace(/[^\0-1]+$/, "") : "", setup = setup ? setup._ || setup : void 0, params ||= void 0;
  let clone = template ? (branch, ns) => {
    ((cloneCache[ns] ||= {})[template] ||= createCloneableHTML(
      template,
      ns
    ))(branch, walks);
  } : (branch) => {
    walk(
      branch.h = branch.j = new Text(),
      walks,
      branch
    );
  };
  return (owner) => ({
    l: id,
    C: clone,
    u: owner,
    D: setup,
    m: params,
    n: dynamicScopesAccessor
  });
}
function registerContent(id, template, walks, setup, params, dynamicScopesAccessor) {
  return register(
    id,
    createContent(id, template, walks, setup, params, dynamicScopesAccessor)
  );
}
function localClosures(renderer, closureFns) {
  let closureSignals = {};
  for (let key in closureFns)
    closureSignals[key] = value(key, closureFns[key]);
  return (owner, closureValues) => {
    let instance = renderer(owner);
    return instance.G = closureSignals, instance.M = closureValues, instance;
  };
}
function createRenderer(template, walks, setup, params) {
  return createContent("", template, walks, setup, params)();
}
var cloneCache = {};
function createCloneableHTML(html2, ns) {
  let { firstChild, lastChild } = parseHTML(html2, ns), parent = document.createElementNS(ns, "t");
  return insertChildNodes(parent, null, firstChild, lastChild), firstChild === lastChild && firstChild.nodeType < 8 /* Comment */ ? (branch, walks) => {
    walk(
      branch.h = branch.j = firstChild.cloneNode(!0),
      walks,
      branch
    );
  } : (branch, walks) => {
    let clone = parent.cloneNode(!0);
    walk(clone.firstChild, walks, branch), branch.h = clone.firstChild, branch.j = clone.lastChild;
  };
}

// src/dom/dom.ts
function attr(element, name, value2) {
  setAttribute(element, name, normalizeAttrValue(value2));
}
function setAttribute(element, name, value2) {
  element.getAttribute(name) != value2 && (value2 === void 0 ? element.removeAttribute(name) : element.setAttribute(name, value2));
}
function classAttr(element, value2) {
  setAttribute(element, "class", classValue(value2) || void 0);
}
function classItems(element, items) {
  for (let key in items)
    classItem(element, key, items[key]);
}
function classItem(element, name, value2) {
  element.classList.toggle(name, !!value2);
}
function styleAttr(element, value2) {
  setAttribute(element, "style", styleValue(value2) || void 0);
}
function styleItems(element, items) {
  for (let key in items)
    styleItem(element, key, items[key]);
}
function styleItem(element, name, value2) {
  element.style.setProperty(name, value2 || value2 === 0 ? value2 + "" : "");
}
function data(node, value2) {
  let normalizedValue = normalizeString(value2);
  node.data !== normalizedValue && (node.data = normalizedValue);
}
function textContent(node, value2) {
  let normalizedValue = normalizeString(value2);
  node.textContent !== normalizedValue && (node.textContent = normalizedValue);
}
function attrs(scope, nodeAccessor, nextAttrs) {
  let el = scope[nodeAccessor];
  for (let i = el.attributes.length; i--; ) {
    let { name } = el.attributes.item(i);
    nextAttrs && (name in nextAttrs || hasAttrAlias(el, name, nextAttrs)) || el.removeAttribute(name);
  }
  attrsInternal(scope, nodeAccessor, nextAttrs);
}
function attrsAndContent(scope, nodeAccessor, nextAttrs) {
  attrs(scope, nodeAccessor, nextAttrs), insertContent(scope, nodeAccessor, nextAttrs?.content);
}
function hasAttrAlias(element, attr2, nextAttrs) {
  return attr2 === "checked" && element.tagName === "INPUT" && "checkedValue" in nextAttrs;
}
function partialAttrs(scope, nodeAccessor, nextAttrs, skip) {
  let el = scope[nodeAccessor], partial = {};
  for (let i = el.attributes.length; i--; ) {
    let { name } = el.attributes.item(i);
    !skip[name] && !(nextAttrs && name in nextAttrs) && el.removeAttribute(name);
  }
  for (let key in nextAttrs)
    skip[key] || (partial[key] = nextAttrs[key]);
  attrsInternal(scope, nodeAccessor, partial);
}
function partialAttrsAndContent(scope, nodeAccessor, nextAttrs, skip) {
  partialAttrs(scope, nodeAccessor, nextAttrs, skip), insertContent(scope, nodeAccessor, nextAttrs?.content);
}
function attrsInternal(scope, nodeAccessor, nextAttrs) {
  let el = scope[nodeAccessor], events, skip;
  switch (el.tagName) {
    case "INPUT":
      if ("checked" in nextAttrs || "checkedChange" in nextAttrs)
        controllable_input_checked(
          scope,
          nodeAccessor,
          nextAttrs.checked,
          nextAttrs.checkedChange
        );
      else if ("checkedValue" in nextAttrs || "checkedValueChange" in nextAttrs)
        controllable_input_checkedValue(
          scope,
          nodeAccessor,
          nextAttrs.checkedValue,
          nextAttrs.checkedValueChange,
          nextAttrs.value
        );
      else if ("value" in nextAttrs || "valueChange" in nextAttrs)
        controllable_input_value(
          scope,
          nodeAccessor,
          nextAttrs.value,
          nextAttrs.valueChange
        );
      else
        break;
      skip = /^(?:value|checked(?:Value)?)(?:Change)?$/;
      break;
    case "SELECT":
      ("value" in nextAttrs || "valueChange" in nextAttrs) && (controllable_select_value(
        scope,
        nodeAccessor,
        nextAttrs.value,
        nextAttrs.valueChange
      ), skip = /^value(?:Change)?$/);
      break;
    case "TEXTAREA":
      ("value" in nextAttrs || "valueChange" in nextAttrs) && (controllable_input_value(
        scope,
        nodeAccessor,
        nextAttrs.value,
        nextAttrs.valueChange
      ), skip = /^value(?:Change)?$/);
      break;
    case "DETAILS":
    case "DIALOG":
      ("open" in nextAttrs || "openChange" in nextAttrs) && (controllable_detailsOrDialog_open(
        scope,
        nodeAccessor,
        nextAttrs.open,
        nextAttrs.openChange
      ), skip = /^open(?:Change)?$/);
      break;
  }
  for (let name in nextAttrs) {
    let value2 = nextAttrs[name];
    switch (name) {
      case "class":
        classAttr(el, value2);
        break;
      case "style":
        styleAttr(el, value2);
        break;
      case "content":
        break;
      default:
        isEventHandler(name) ? (events ||= scope["i" /* EventAttributes */ + nodeAccessor] = {})[getEventHandlerName(name)] = value2 : skip?.test(name) || attr(el, name, value2);
    }
  }
}
function insertContent(scope, nodeAccessor, value2) {
  let content = normalizeClientRender(value2), rendererAccessor = "c" /* ConditionalRenderer */ + nodeAccessor;
  scope[rendererAccessor] !== (scope[rendererAccessor] = content?.l) && (setConditionalRenderer(scope, nodeAccessor, content, createAndSetupBranch), content?.n && subscribeToScopeSet(
    content.u,
    content.n,
    scope["d" /* ConditionalScope */ + nodeAccessor]
  ));
}
function attrsEvents(scope, nodeAccessor) {
  let el = scope[nodeAccessor], events = scope["i" /* EventAttributes */ + nodeAccessor];
  switch (scope["f" /* ControlledType */ + nodeAccessor]) {
    case 0 /* InputChecked */:
      controllable_input_checked_effect(scope, nodeAccessor);
      break;
    case 1 /* InputCheckedValue */:
      controllable_input_checkedValue_effect(scope, nodeAccessor);
      break;
    case 2 /* InputValue */:
      controllable_input_value_effect(scope, nodeAccessor);
      break;
    case 3 /* SelectValue */:
      controllable_select_value_effect(scope, nodeAccessor);
      break;
    case 4 /* DetailsOrDialogOpen */:
      controllable_detailsOrDialog_open_effect(scope, nodeAccessor);
      break;
  }
  for (let name in events)
    on(el, name, events[name]);
}
function html(scope, value2, accessor) {
  let firstChild = scope[accessor], parentNode = firstChild.parentNode, lastChild = scope["h" /* DynamicPlaceholderLastChild */ + accessor] || firstChild, newContent = parseHTML(
    value2 || value2 === 0 ? value2 + "" : "",
    parentNode.namespaceURI
  );
  insertChildNodes(
    parentNode,
    firstChild,
    scope[accessor] = newContent.firstChild || newContent.appendChild(new Text()),
    scope["h" /* DynamicPlaceholderLastChild */ + accessor] = newContent.lastChild
  ), removeChildNodes(firstChild, lastChild);
}
function normalizeClientRender(value2) {
  let renderer = normalizeDynamicRenderer(value2);
  if (renderer && renderer.l)
    return renderer;
}
function props(scope, nodeIndex, index) {
  let nextProps = scope[index], prevProps = scope[index + "-"], node = scope[nodeIndex];
  if (prevProps)
    for (let name in prevProps)
      name in nextProps || (node[name] = void 0);
  for (let name in nextProps)
    node[name] = nextProps[name];
  scope[index + "-"] = nextProps;
}
function normalizeAttrValue(value2) {
  if (value2 || value2 === 0)
    return value2 === !0 ? "" : value2 + "";
}
function normalizeString(value2) {
  return value2 || value2 === 0 ? value2 + "" : "\u200D";
}
function lifecycle(scope, index, thisObj) {
  let instance = scope[index];
  instance ? (Object.assign(instance, thisObj), instance.onUpdate?.()) : (scope[index] = thisObj, thisObj.onMount?.(), getAbortSignal(
    scope,
    "k" /* LifecycleAbortController */ + index
  ).onabort = () => thisObj.onDestroy?.());
}
function removeChildNodes(startNode, endNode) {
  let stop = endNode.nextSibling, current = startNode;
  for (; current !== stop; ) {
    let next = current.nextSibling;
    current.remove(), current = next;
  }
}
function insertChildNodes(parentNode, referenceNode, startNode, endNode) {
  parentNode.insertBefore(toInsertNode(startNode, endNode), referenceNode);
}
function toInsertNode(startNode, endNode) {
  if (startNode === endNode) return startNode;
  let parent = new DocumentFragment(), stop = endNode.nextSibling, current = startNode;
  for (; current !== stop; ) {
    let next = current.nextSibling;
    parent.appendChild(current), current = next;
  }
  return parent;
}

// src/dom/reconcile.ts
var WRONG_POS = 2147483647;
function reconcile(parent, oldBranches, newBranches, afterReference) {
  let oldStart = 0, newStart = 0, oldEnd = oldBranches.length - 1, newEnd = newBranches.length - 1, oldStartBranch = oldBranches[oldStart], newStartBranch = newBranches[newStart], oldEndBranch = oldBranches[oldEnd], newEndBranch = newBranches[newEnd], i, j, k, nextSibling, oldBranch, newBranch;
  outer: {
    for (; oldStartBranch === newStartBranch; ) {
      if (++oldStart, ++newStart, oldStart > oldEnd || newStart > newEnd)
        break outer;
      oldStartBranch = oldBranches[oldStart], newStartBranch = newBranches[newStart];
    }
    for (; oldEndBranch === newEndBranch; ) {
      if (--oldEnd, --newEnd, oldStart > oldEnd || newStart > newEnd)
        break outer;
      oldEndBranch = oldBranches[oldEnd], newEndBranch = newBranches[newEnd];
    }
  }
  if (oldStart > oldEnd) {
    if (newStart <= newEnd) {
      k = newEnd + 1, nextSibling = k < newBranches.length ? newBranches[k].h : afterReference;
      do
        insertBranchBefore(newBranches[newStart++], parent, nextSibling);
      while (newStart <= newEnd);
    }
  } else if (newStart > newEnd)
    do
      removeAndDestroyBranch(oldBranches[oldStart++]);
    while (oldStart <= oldEnd);
  else {
    let oldLength = oldEnd - oldStart + 1, newLength = newEnd - newStart + 1, aNullable = oldBranches, sources = new Array(newLength);
    for (i = 0; i < newLength; ++i)
      sources[i] = -1;
    let pos = 0, synced = 0, keyIndex = /* @__PURE__ */ new Map();
    for (j = newStart; j <= newEnd; ++j)
      keyIndex.set(newBranches[j], j);
    for (i = oldStart; i <= oldEnd && synced < newLength; ++i)
      oldBranch = oldBranches[i], j = keyIndex.get(oldBranch), j !== void 0 && (pos = pos > j ? WRONG_POS : j, ++synced, newBranch = newBranches[j], sources[j - newStart] = i, aNullable[i] = null);
    if (oldLength === oldBranches.length && synced === 0) {
      for (; newStart < newLength; ++newStart)
        insertBranchBefore(newBranches[newStart], parent, afterReference);
      for (; oldStart < oldLength; ++oldStart)
        removeAndDestroyBranch(oldBranches[oldStart]);
    } else {
      for (i = oldLength - synced; i > 0; )
        oldBranch = aNullable[oldStart++], oldBranch !== null && (removeAndDestroyBranch(oldBranch), i--);
      if (pos === WRONG_POS) {
        let seq = longestIncreasingSubsequence(sources);
        for (j = seq.length - 1, k = newBranches.length, i = newLength - 1; i >= 0; --i)
          sources[i] === -1 ? (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling)) : j < 0 || i !== seq[j] ? (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling)) : --j;
      } else if (synced !== newLength)
        for (k = newBranches.length, i = newLength - 1; i >= 0; --i)
          sources[i] === -1 && (pos = i + newStart, newBranch = newBranches[pos++], nextSibling = pos < k ? newBranches[pos].h : afterReference, insertBranchBefore(newBranch, parent, nextSibling));
    }
  }
}
function longestIncreasingSubsequence(a) {
  let p = a.slice(), result = [0], u, v;
  for (let i = 0, il = a.length; i < il; ++i) {
    if (a[i] === -1)
      continue;
    let j = result[result.length - 1];
    if (a[j] < a[i]) {
      p[i] = j, result.push(i);
      continue;
    }
    for (u = 0, v = result.length - 1; u < v; ) {
      let c = (u + v) / 2 | 0;
      a[result[c]] < a[i] ? u = c + 1 : v = c;
    }
    a[i] < a[result[u]] && (u > 0 && (p[i] = result[u - 1]), result[u] = i);
  }
  for (u = result.length, v = result[u - 1]; u-- > 0; )
    result[u] = v, v = p[v];
  return result;
}

// src/dom/control-flow.ts
function awaitTag(nodeAccessor, renderer) {
  let promiseAccessor = "n" /* Promise */ + nodeAccessor, branchAccessor = "d" /* ConditionalScope */ + nodeAccessor;
  return (scope, promise) => {
    let referenceNode = scope[nodeAccessor], tryWithPlaceholder = findBranchWithKey(
      scope,
      "d" /* PlaceholderContent */
    ), awaitBranch = scope[branchAccessor];
    tryWithPlaceholder ? (placeholderShown.add(pendingEffects), !scope[promiseAccessor] && (tryWithPlaceholder.o = (tryWithPlaceholder.o || 0) + 1) === 1 && requestAnimationFrame(
      () => tryWithPlaceholder.o && runEffects(
        prepareEffects(
          () => queueRender(
            tryWithPlaceholder,
            () => {
              insertBranchBefore(
                tryWithPlaceholder.c = createAndSetupBranch(
                  scope.$global,
                  tryWithPlaceholder.d,
                  tryWithPlaceholder._,
                  tryWithPlaceholder.h.parentNode
                ),
                tryWithPlaceholder.h.parentNode,
                tryWithPlaceholder.h
              ), tempDetachBranch(tryWithPlaceholder);
            },
            -1
          )
        )
      )
    )) : awaitBranch && !scope[promiseAccessor] && (awaitBranch.h.parentNode.insertBefore(
      referenceNode,
      awaitBranch.h
    ), tempDetachBranch(awaitBranch));
    let thisPromise = scope[promiseAccessor] = promise.then(
      (data2) => {
        thisPromise === scope[promiseAccessor] && (scope[promiseAccessor] = 0, schedule(), queueRender(
          scope,
          () => {
            if (awaitBranch ? tryWithPlaceholder || referenceNode.replaceWith(
              awaitBranch.h.parentNode
            ) : (insertBranchBefore(
              awaitBranch = scope[branchAccessor] = createAndSetupBranch(
                scope.$global,
                renderer,
                scope,
                referenceNode.parentNode
              ),
              referenceNode.parentNode,
              referenceNode
            ), referenceNode.remove()), renderer.m?.(awaitBranch, [data2]), tryWithPlaceholder && (placeholderShown.add(pendingEffects), !--tryWithPlaceholder.o)) {
              let placeholderBranch = tryWithPlaceholder.c;
              tryWithPlaceholder.c = 0, placeholderBranch && (placeholderBranch.h.parentNode.insertBefore(
                tryWithPlaceholder.h.parentNode,
                placeholderBranch.h
              ), removeAndDestroyBranch(placeholderBranch)), tryWithPlaceholder.H && runEffects(tryWithPlaceholder.H, !0);
            }
          },
          -1
        ));
      },
      (error) => {
        thisPromise === scope[promiseAccessor] && (tryWithPlaceholder && (tryWithPlaceholder.o = 0), scope[promiseAccessor] = 0, schedule(), queueRender(scope, renderCatch, -1, error));
      }
    );
  };
}
function createTry(nodeAccessor, tryContent) {
  let branchAccessor = "d" /* ConditionalScope */ + nodeAccessor;
  return (scope, input) => {
    scope[branchAccessor] || setConditionalRenderer(
      scope,
      nodeAccessor,
      tryContent,
      createAndSetupBranch
    );
    let branch = scope[branchAccessor];
    branch && (branch.a = nodeAccessor, branch.b = normalizeDynamicRenderer(input.catch), branch.d = normalizeDynamicRenderer(
      input.placeholder
    ));
  };
}
function renderCatch(scope, error) {
  let tryWithCatch = findBranchWithKey(scope, "b" /* CatchContent */);
  if (tryWithCatch) {
    let owner = tryWithCatch._, placeholderBranch = tryWithCatch.c;
    placeholderBranch && (tryWithCatch.o = 0, owner["d" /* ConditionalScope */ + tryWithCatch.a] = placeholderBranch, destroyBranch(tryWithCatch)), caughtError.add(pendingEffects), setConditionalRenderer(
      owner,
      tryWithCatch.a,
      tryWithCatch.b,
      createAndSetupBranch
    ), tryWithCatch.b.m?.(
      owner["d" /* ConditionalScope */ + tryWithCatch.a],
      [error]
    );
  } else
    throw error;
}
function conditional(nodeAccessor, ...branches) {
  let branchAccessor = "c" /* ConditionalRenderer */ + nodeAccessor;
  return enableBranches(), (scope, newBranch) => {
    newBranch !== scope[branchAccessor] && setConditionalRenderer(
      scope,
      nodeAccessor,
      branches[scope[branchAccessor] = newBranch],
      createAndSetupBranch
    );
  };
}
function patchDynamicTag(fn) {
  dynamicTag = fn(dynamicTag);
}
var dynamicTag = function(nodeAccessor, getContent, getTagVar, inputIsArgs) {
  let childScopeAccessor = "d" /* ConditionalScope */ + nodeAccessor, rendererAccessor = "c" /* ConditionalRenderer */ + nodeAccessor;
  return enableBranches(), (scope, newRenderer, getInput) => {
    let normalizedRenderer = normalizeDynamicRenderer(newRenderer);
    if (scope[rendererAccessor] !== (scope[rendererAccessor] = normalizedRenderer?.l || normalizedRenderer) || getContent && !(normalizedRenderer || scope[childScopeAccessor]))
      if (setConditionalRenderer(
        scope,
        nodeAccessor,
        normalizedRenderer || (getContent ? getContent(scope) : void 0),
        createBranchWithTagNameOrRenderer
      ), getTagVar && setTagVar(scope, childScopeAccessor, getTagVar()), typeof normalizedRenderer == "string") {
        if (getContent) {
          let content = getContent(scope);
          setConditionalRenderer(
            scope[childScopeAccessor],
            0,
            content,
            createAndSetupBranch
          ), content.n && subscribeToScopeSet(
            content.u,
            content.n,
            scope[childScopeAccessor]["d" /* ConditionalScope */ + 0]
          );
        }
      } else normalizedRenderer?.n && subscribeToScopeSet(
        normalizedRenderer.u,
        normalizedRenderer.n,
        scope[childScopeAccessor]
      );
    if (normalizedRenderer) {
      let childScope = scope[childScopeAccessor], args = getInput?.();
      if (typeof normalizedRenderer == "string")
        attrs(
          childScope,
          0,
          (inputIsArgs ? args[0] : args) || {}
        );
      else {
        for (let accessor in normalizedRenderer.G)
          normalizedRenderer.G[accessor](
            childScope,
            normalizedRenderer.M[accessor]
          );
        if (normalizedRenderer.m)
          if (inputIsArgs)
            normalizedRenderer.m(
              childScope,
              normalizedRenderer._ ? args[0] : args
            );
          else {
            let inputWithContent = getContent ? { ...args, content: getContent(scope) } : args || {};
            normalizedRenderer.m(
              childScope,
              normalizedRenderer._ ? inputWithContent : [inputWithContent]
            );
          }
      }
    }
  };
};
function setConditionalRenderer(scope, nodeAccessor, newRenderer, createBranch2) {
  let referenceNode = scope[nodeAccessor], prevBranch = scope["d" /* ConditionalScope */ + nodeAccessor], parentNode = referenceNode.nodeType > 1 /* Element */ ? (prevBranch?.h || referenceNode).parentNode : referenceNode, newBranch = scope["d" /* ConditionalScope */ + nodeAccessor] = newRenderer && createBranch2(scope.$global, newRenderer, scope, parentNode);
  referenceNode === parentNode ? (prevBranch && (destroyBranch(prevBranch), referenceNode.textContent = ""), newBranch && insertBranchBefore(newBranch, parentNode, null)) : prevBranch ? (newBranch ? insertBranchBefore(newBranch, parentNode, prevBranch.h) : parentNode.insertBefore(referenceNode, prevBranch.h), removeAndDestroyBranch(prevBranch)) : newBranch && (insertBranchBefore(newBranch, parentNode, referenceNode), referenceNode.remove());
}
function loopOf(nodeAccessor, renderer) {
  return loop(
    nodeAccessor,
    renderer,
    ([all, by = bySecondArg], cb) => {
      typeof by == "string" ? forOf(
        all,
        (item, i) => cb(item[by], [item, i])
      ) : forOf(all, (item, i) => cb(by(item, i), [item, i]));
    }
  );
}
function loopIn(nodeAccessor, renderer) {
  return loop(
    nodeAccessor,
    renderer,
    ([obj, by = byFirstArg], cb) => forIn(obj, (key, value2) => cb(by(key, value2), [key, value2]))
  );
}
function loopTo(nodeAccessor, renderer) {
  return loop(
    nodeAccessor,
    renderer,
    ([to, from, step, by = byFirstArg], cb) => forTo(to, from, step, (v) => cb(by(v), [v]))
  );
}
function loop(nodeAccessor, renderer, forEach) {
  let params = renderer.m;
  return enableBranches(), (scope, value2) => {
    let referenceNode = scope[nodeAccessor], oldMap = scope["m" /* LoopScopeMap */ + nodeAccessor], oldArray = oldMap ? scope["l" /* LoopScopeArray */ + nodeAccessor] || [
      ...oldMap.values()
    ] : [], parentNode = referenceNode.nodeType > 1 /* Element */ ? referenceNode.parentNode || oldArray[0].h.parentNode : referenceNode, newMap = scope["m" /* LoopScopeMap */ + nodeAccessor] = /* @__PURE__ */ new Map(), newArray = scope["l" /* LoopScopeArray */ + nodeAccessor] = [];
    forEach(value2, (key, args) => {
      let branch = oldMap?.get(key) || createAndSetupBranch(scope.$global, renderer, scope, parentNode);
      params?.(branch, args), newMap.set(key, branch), newArray.push(branch);
    });
    let afterReference = null;
    referenceNode !== parentNode && (oldArray.length ? (afterReference = oldArray[oldArray.length - 1].j.nextSibling, newArray.length || parentNode.insertBefore(referenceNode, afterReference)) : newArray.length && (afterReference = referenceNode.nextSibling, referenceNode.remove())), reconcile(parentNode, oldArray, newArray, afterReference);
  };
}
function createBranchWithTagNameOrRenderer($global, tagNameOrRenderer, parentScope, parentNode) {
  let branch = createBranch(
    $global,
    tagNameOrRenderer,
    parentScope,
    parentNode
  );
  return typeof tagNameOrRenderer == "string" ? branch[0] = branch.h = branch.j = document.createElementNS(
    tagNameOrRenderer === "svg" ? "http://www.w3.org/2000/svg" : tagNameOrRenderer === "math" ? "http://www.w3.org/1998/Math/MathML" : parentNode.namespaceURI,
    tagNameOrRenderer
  ) : setupBranch(tagNameOrRenderer, branch), branch;
}
function bySecondArg(_item, index) {
  return index;
}
function byFirstArg(name) {
  return name;
}

// src/dom/queue.ts
var pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map(), caughtError = /* @__PURE__ */ new WeakSet(), placeholderShown = /* @__PURE__ */ new WeakSet(), pendingEffects = [], pendingScopes = [], rendering, scopeKeyOffset = 1e3;
function queueRender(scope, signal, signalKey, value2, scopeKey = scope.l) {
  let key = scopeKey * scopeKeyOffset + signalKey, existingRender = signalKey >= 0 && pendingRendersLookup.get(key);
  if (existingRender)
    existingRender.I = value2;
  else {
    let render = {
      x: key,
      p: scope,
      N: signal,
      I: value2
    }, i = pendingRenders.push(render) - 1;
    for (; i; ) {
      let parentIndex = i - 1 >> 1, parent = pendingRenders[parentIndex];
      if (key - parent.x >= 0) break;
      pendingRenders[i] = parent, i = parentIndex;
    }
    signalKey >= 0 && pendingRendersLookup.set(key, render), pendingRenders[i] = render;
  }
}
function queueEffect(scope, fn) {
  pendingEffects.push(fn, scope);
}
function run() {
  let effects = pendingEffects;
  try {
    rendering = 1, runRenders();
  } finally {
    pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map(), pendingEffects = [], rendering = 0;
  }
  runEffects(effects);
}
function prepareEffects(fn) {
  let prevRenders = pendingRenders, prevRendersLookup = pendingRendersLookup, prevEffects = pendingEffects, preparedEffects = pendingEffects = [];
  pendingRenders = [], pendingRendersLookup = /* @__PURE__ */ new Map();
  try {
    rendering = 1, fn(), runRenders();
  } finally {
    rendering = 0, pendingRenders = prevRenders, pendingRendersLookup = prevRendersLookup, pendingEffects = prevEffects;
  }
  return preparedEffects;
}
var runEffects = (effects) => {
  for (let i = 0, scope; i < effects.length; )
    effects[i++](
      scope = effects[i++],
      scope
    );
};
function runRenders() {
  for (; pendingRenders.length; ) {
    let render = pendingRenders[0], item = pendingRenders.pop();
    if (render !== item) {
      let i = 0, mid = pendingRenders.length >> 1, key = (pendingRenders[0] = item).x;
      for (; i < mid; ) {
        let bestChild = (i << 1) + 1, right = bestChild + 1;
        if (right < pendingRenders.length && pendingRenders[right].x - pendingRenders[bestChild].x < 0 && (bestChild = right), pendingRenders[bestChild].x - key >= 0)
          break;
        pendingRenders[i] = pendingRenders[bestChild], i = bestChild;
      }
      pendingRenders[i] = item;
    }
    render.p.k?.B || runRender(render);
  }
  for (let scope of pendingScopes)
    scope.t = 0;
  pendingScopes = [];
}
var runRender = (render) => render.N(render.p, render.I), enableCatch = () => {
  enableCatch = () => {
  }, enableBranches();
  let handlePendingTry = (fn, scope, branch) => {
    for (; branch; ) {
      if (branch.o)
        return (branch.H ||= []).push(fn, scope);
      branch = branch.y;
    }
  };
  runEffects = /* @__PURE__ */ ((runEffects2) => (effects, checkPending = placeholderShown.has(effects)) => {
    if (checkPending || caughtError.has(effects)) {
      let i = 0, fn, scope, branch;
      for (; i < effects.length; )
        fn = effects[i++], scope = effects[i++], branch = scope.k, !branch?.B && !(checkPending && handlePendingTry(fn, scope, branch)) && fn(scope, scope);
    } else
      runEffects2(effects);
  })(runEffects), runRender = /* @__PURE__ */ ((runRender2) => (render) => {
    try {
      runRender2(render);
    } catch (error) {
      renderCatch(render.p, error);
    }
  })(runRender);
};

// src/dom/abort-signal.ts
function resetAbortSignal(scope, id) {
  let ctrl = scope.z?.[id];
  ctrl && (queueEffect(ctrl, abort), scope.z[id] = void 0);
}
function getAbortSignal(scope, id) {
  return scope.k && (scope.k.K ||= /* @__PURE__ */ new Set()).add(scope), ((scope.z ||= {})[id] ||= new AbortController()).signal;
}
function abort(ctrl) {
  ctrl.abort();
}

// src/common/compat-meta.ts
var prefix = "$C_", RENDERER_REGISTER_ID = prefix + "r", SET_SCOPE_REGISTER_ID = prefix + "s", RENDER_BODY_ID = prefix + "b";

// src/dom/compat.ts
var classIdToBranch = /* @__PURE__ */ new Map(), compat = {
  patchDynamicTag,
  queueEffect,
  init(warp10Noop) {
    register(SET_SCOPE_REGISTER_ID, (branch) => {
      classIdToBranch.set(branch.m5c, branch);
    }), register(RENDER_BODY_ID, warp10Noop);
  },
  registerRenderer(fn) {
    register(RENDERER_REGISTER_ID, fn);
  },
  isRenderer(renderer) {
    return renderer.C;
  },
  getStartNode(branch) {
    return branch.h;
  },
  setScopeNodes(branch, startNode, endNode) {
    branch.h = startNode, branch.j = endNode;
  },
  runComponentEffects() {
    runEffects(this.effects);
  },
  runComponentDestroy() {
    this.scope && destroyBranch(this.scope);
  },
  resolveRegistered(value2, {
    runtimeId,
    componentIdPrefix
  }) {
    return Array.isArray(value2) && typeof value2[0] == "string" ? getRegisteredWithScope(
      value2[0],
      value2.length === 2 && self[runtimeId]?.[componentIdPrefix === "s" ? "_" : componentIdPrefix]?.s[value2[1]]
    ) : value2;
  },
  createRenderer(params, clone) {
    let renderer = createRenderer(0, 0, 0, params);
    return renderer.C = (branch) => {
      let cloned = clone();
      branch.h = cloned.startNode, branch.j = cloned.endNode;
    }, renderer;
  },
  render(out, component, renderer, args) {
    let branch = component.scope;
    branch || (branch = classIdToBranch.get(component.id), branch && (component.scope = branch, classIdToBranch.delete(component.id)));
    let existing;
    if (typeof args[0] == "object" && "renderBody" in args[0]) {
      let input = args[0], normalizedInput = args[0] = {};
      for (let key in input)
        normalizedInput[key === "renderBody" ? "content" : key] = input[key];
    }
    if (component.effects = prepareEffects(() => {
      branch ? existing = 1 : (out.global.q ||= 0, branch = component.scope = createAndSetupBranch(
        out.global,
        renderer,
        renderer.u,
        document.body
      )), renderer.m?.(branch, renderer._ ? args[0] : args);
    }), !existing)
      return toInsertNode(branch.h, branch.j);
  }
};

// src/dom/template.ts
var createTemplate = (id, template, walks, setup, inputSignal) => {
  let renderer = createContent(
    id,
    template,
    walks,
    setup,
    inputSignal
  )();
  return renderer.mount = mount, renderer._ = renderer, register(id, renderer);
};
function mount(input = {}, reference, position) {
  let branch, parentNode = reference, nextSibling = null, { $global } = input;
  switch ($global ? ({ $global, ...input } = input, $global = {
    q: 0,
    runtimeId: DEFAULT_RUNTIME_ID,
    renderId: DEFAULT_RENDER_ID,
    ...$global
  }) : $global = {
    q: 0,
    runtimeId: DEFAULT_RUNTIME_ID,
    renderId: DEFAULT_RENDER_ID
  }, position) {
    case "beforebegin":
      parentNode = reference.parentNode, nextSibling = reference;
      break;
    case "afterbegin":
      nextSibling = reference.firstChild;
      break;
    case "afterend":
      parentNode = reference.parentNode, nextSibling = reference.nextSibling;
      break;
  }
  let curValue, args = this.m, effects = prepareEffects(() => {
    branch = createBranch(
      $global,
      this,
      void 0,
      parentNode
    ), branch.e = (newValue) => {
      curValue = newValue;
    }, this.D?.(branch), args?.(branch, input);
  });
  return insertChildNodes(
    parentNode,
    nextSibling,
    branch.h,
    branch.j
  ), runEffects(effects), {
    get value() {
      return curValue;
    },
    set value(newValue) {
      tagVarSignalChange(branch, newValue);
    },
    update(newInput) {
      args && runEffects(
        prepareEffects(() => {
          args(branch, newInput);
        })
      );
    },
    destroy() {
      removeAndDestroyBranch(branch);
    }
  };
}
