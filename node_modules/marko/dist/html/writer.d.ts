import { type $Global, type Accessor, type Falsy, ResumeSymbol } from "../common/types";
import { Serializer } from "./serializer";
import type { ServerRenderer } from "./template";
export type PartialScope = Record<Accessor, unknown>;
type ScopeInternals = PartialScope & {
    [K_SCOPE_ID]?: number;
};
declare const K_SCOPE_ID: unique symbol;
declare enum Mark {
    Placeholder = "!^",
    PlaceholderEnd = "!",
    ReorderMarker = "#"
}
export declare function getChunk(): Chunk | undefined;
export declare function getContext(key: keyof NonNullable<Chunk["context"]>): unknown;
export declare function getState(): State;
export declare function getScopeId(scope: unknown): number | undefined;
export declare function write(html: string): void;
export declare function writeScript(script: string): void;
export declare function writeEffect(scopeId: number, registryId: string): void;
export declare function writeContent(nodeAccessor: Accessor, scopeId: number, content: unknown, serializeReason?: 1 | 0): void;
export declare function normalizeServerRender(value: unknown): ServerRenderer | undefined;
export declare function withContext<T>(key: PropertyKey, value: unknown, cb: () => T): T;
export declare function setTagVar(parentScopeId: number, scopeOffsetAccessor: Accessor, childScopeId: number, registryId: string): void;
export declare function register<T extends WeakKey>(val: T, id: string, scopeId?: number): T;
export declare function nextTagId(): string;
export declare function nextScopeId(): number;
export declare function peekNextScopeId(): number;
export declare function getScopeById(scopeId: number | undefined): PartialScope | undefined;
export declare function serializeIf(condition: undefined | 1 | Record<string, 1>, key: string): 1 | undefined;
export declare function serializeGuard(condition: undefined | 1 | Record<string, 1>, key: string): 0 | 1;
export declare function markResumeNode(scopeId: number, accessor: Accessor, shouldResume?: 0 | 1): string;
export declare function commentSeparator(shouldResume: 0 | 1): "" | "<!>";
export declare function nodeRef(scopeId: number, id?: string): () => void;
export declare function hoist(scopeId: number, id?: string): {
    (): void;
    [Symbol.iterator]: /*elided*/ any;
};
export declare function resumeClosestBranch(scopeId: number): void;
export declare function withBranchId<T>(branchId: number, cb: () => T): T;
export declare function resumeForOf(list: Falsy | Iterable<unknown>, cb: (item: unknown, index: number) => void, by: Falsy | ((item: unknown, index: number) => unknown), scopeId: number, accessor: Accessor, serializeBranch?: 0 | 1, serializeMarker?: 0 | 1, parentEndTag?: string | 0, singleNode?: 1): void;
export declare function resumeForIn(obj: Falsy | {}, cb: (key: string, value: unknown) => void, by: Falsy | ((key: string, v: unknown) => unknown), scopeId: number, accessor: Accessor, serializeBranch?: 0 | 1, serializeMarker?: 0 | 1, parentEndTag?: string | 0, singleNode?: 1): void;
export declare function resumeForTo(to: number, from: number | Falsy, step: number | Falsy, cb: (index: number) => void, by: Falsy | ((v: number) => unknown), scopeId: number, accessor: Accessor, serializeBranch?: 0 | 1, serializeMarker?: 0 | 1, parentEndTag?: string | 0, singleNode?: 1): void;
export declare function resumeConditional(cb: () => void | number, scopeId: number, accessor: Accessor, serializeBranch?: 0 | 1, serializeMarker?: 0 | 1, parentEndTag?: string | 0, singleNode?: 1): void;
declare let writeScope: (scopeId: number, partialScope: PartialScope) => ScopeInternals;
export { writeScope };
export declare function writeExistingScope(scopeId: number): ScopeInternals;
export declare function ensureScopeWithId(scopeId: number): PartialScope;
export declare function $global(): $Global & {
    renderId: string;
    runtimeId: string;
};
export declare function fork<T>(scopeId: number, accessor: Accessor, promise: Promise<T> | T, content: (value: T) => void, serializeMarker?: 0 | 1): void;
export declare function tryContent(scopeId: number, accessor: Accessor, content: () => void, input: {
    placeholder?: {
        content?(): void;
    };
    catch?: {
        content?(err: unknown): void;
    };
}): void;
export declare class State {
    $global: $Global & {
        renderId: string;
        runtimeId: string;
    };
    tagId: number;
    scopeId: number;
    reorderId: number;
    lastSerializedScopeId: number;
    hasGlobals: boolean;
    needsMainRuntime: boolean;
    hasMainRuntime: boolean;
    hasReorderRuntime: boolean;
    hasWrittenResume: boolean;
    walkOnNextFlush: boolean;
    trailerHTML: string;
    resumes: string;
    nonceAttr: string;
    serializer: Serializer;
    writeReorders: Chunk[] | null;
    scopes: Map<number, PartialScope>;
    writeScopes: null | Record<number, PartialScope>;
    constructor($global: $Global & {
        renderId: string;
        runtimeId: string;
    });
    get runtimePrefix(): string;
    get commentPrefix(): string;
    reorder(chunk: Chunk): void;
    nextReorderId(): string;
    mark(code: ResumeSymbol | Mark, str: string): string;
}
export declare class Boundary extends AbortController {
    state: State;
    onNext: () => void;
    count: number;
    constructor(state: State, parent?: AbortSignal);
    get done(): boolean;
    startAsync(): void;
    endAsync(chunk?: Chunk): void;
}
export declare class Chunk {
    boundary: Boundary;
    next: Chunk | null;
    context: Record<string | symbol, unknown> | null;
    html: string;
    scripts: string;
    effects: string;
    lastEffect: string;
    async: boolean;
    consumed: boolean;
    reorderId: string | null;
    placeholderBody: Chunk | null;
    placeholderRender: (() => void) | null;
    constructor(boundary: Boundary, next: Chunk | null, context: Record<string | symbol, unknown> | null);
    writeHTML(html: string): void;
    writeEffect(scopeId: number, registryId: string): void;
    writeScript(script: string): void;
    append(chunk: Chunk): void;
    flushPlaceholder(): void;
    consume(): Chunk;
    render(content: () => void): Chunk;
    render<T>(content: (val: T) => void, val: T): Chunk;
    flushScript(): this;
    flushHTML(): string;
}
export declare function writeTrailers(html: string): void;
type QueueCallback = (ticked: true) => void;
export declare function queueTick(cb: QueueCallback): void;
export declare function offTick(cb: QueueCallback): void;
export declare function writeSubscribe(subscribers: Set<ScopeInternals>, scope: ScopeInternals): ScopeInternals;
